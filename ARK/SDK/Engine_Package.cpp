/**
 * Name: ARK
 * Version: 1.0.1
 */

#include "pch.h"

namespace CG
{
	// --------------------------------------------------
	// # Structs Static Fields
	// --------------------------------------------------
	class UWorld**                                              UWorld::GWorld = nullptr;                                // 0x0000(0x0008) PREDEFINED PROPERTY

	// --------------------------------------------------
	// # Structs Functions
	// --------------------------------------------------
	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEngineBaseTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEngineBaseTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EngineBaseTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEngineTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEngineTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EngineTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.UserConstructionScript
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::UserConstructionScript()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.UserConstructionScript");
		
		AActor_UserConstructionScript_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01C23FA0
	 * 		Name   -> Function Engine.Actor.Unstasis
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AActor::Unstasis()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.Unstasis");
		
		AActor_Unstasis_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027487F0
	 * 		Name   -> Function Engine.Actor.TryMultiUse
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            UseIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::TryMultiUse(class APlayerController* ForPC, int32_t UseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.TryMultiUse");
		
		AActor_TryMultiUse_Params params {};
		params.ForPC = ForPC;
		params.UseIndex = UseIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748950
	 * 		Name   -> Function Engine.Actor.ThrottledTick
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ThrottledTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ThrottledTick");
		
		AActor_ThrottledTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.TargetingTeamChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::TargetingTeamChanged__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.TargetingTeamChanged__DelegateSignature");
		
		AActor_TargetingTeamChanged__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748990
	 * 		Name   -> Function Engine.Actor.TargetingTeamChanged
	 * 		Flags  -> (Native, Public)
	 */
	void AActor::TargetingTeamChanged()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.TargetingTeamChanged");
		
		AActor_TargetingTeamChanged_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.TakePointDamageSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         FHitComponent                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ShotFromDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::TakePointDamageSignature__DelegateSignature(float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* FHitComponent, const class FName& BoneName, const struct FVector& ShotFromDirection, class UDamageType* DamageType, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.TakePointDamageSignature__DelegateSignature");
		
		AActor_TakePointDamageSignature__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.InstigatedBy = InstigatedBy;
		params.HitLocation = HitLocation;
		params.FHitComponent = FHitComponent;
		params.BoneName = BoneName;
		params.ShotFromDirection = ShotFromDirection;
		params.DamageType = DamageType;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.TakeAnyDamageSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::TakeAnyDamageSignature__DelegateSignature(float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.TakeAnyDamageSignature__DelegateSignature");
		
		AActor_TakeAnyDamageSignature__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027489B0
	 * 		Name   -> Function Engine.Actor.StopActorSound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  SoundAsset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeOutTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::StopActorSound(class USoundBase* SoundAsset, float FadeOutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.StopActorSound");
		
		AActor_StopActorSound_Params params {};
		params.SoundAsset = SoundAsset;
		params.FadeOutTime = FadeOutTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748B10
	 * 		Name   -> Function Engine.Actor.SnapRootComponentTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InParentActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SnapRootComponentTo(class AActor* InParentActor, const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SnapRootComponentTo");
		
		AActor_SnapRootComponentTo_Params params {};
		params.InParentActor = InParentActor;
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748C90
	 * 		Name   -> Function Engine.Actor.SetTickFunctionEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableTick                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetTickFunctionEnabled(bool bEnableTick)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickFunctionEnabled");
		
		AActor_SetTickFunctionEnabled_Params params {};
		params.bEnableTick = bEnableTick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748D60
	 * 		Name   -> Function Engine.Actor.SetTickableWhenPaused
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bTickableWhenPaused                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetTickableWhenPaused(bool bTickableWhenPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetTickableWhenPaused");
		
		AActor_SetTickableWhenPaused_Params params {};
		params.bTickableWhenPaused = bTickableWhenPaused;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748E30
	 * 		Name   -> Function Engine.Actor.SetReplicates
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInReplicates                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetReplicates(bool bInReplicates)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetReplicates");
		
		AActor_SetReplicates_Params params {};
		params.bInReplicates = bInReplicates;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748F00
	 * 		Name   -> Function Engine.Actor.SetOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      NewOwner                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetOwner(class AActor* NewOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetOwner");
		
		AActor_SetOwner_Params params {};
		params.NewOwner = NewOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748FD0
	 * 		Name   -> Function Engine.Actor.SetNetworkSpatializationParent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      NewParent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetNetworkSpatializationParent(class AActor* NewParent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetNetworkSpatializationParent");
		
		AActor_SetNetworkSpatializationParent_Params params {};
		params.NewParent = NewParent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027490A0
	 * 		Name   -> Function Engine.Actor.SetLifeSpan
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InLifespan                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetLifeSpan(float InLifespan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetLifeSpan");
		
		AActor_SetLifeSpan_Params params {};
		params.InLifespan = InLifespan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749170
	 * 		Name   -> Function Engine.Actor.SetActorTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::SetActorTransform(const struct FTransform& NewTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorTransform");
		
		AActor_SetActorTransform_Params params {};
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027492F0
	 * 		Name   -> Function Engine.Actor.SetActorScale3D
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewScale3D                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorScale3D(const struct FVector& NewScale3D)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorScale3D");
		
		AActor_SetActorScale3D_Params params {};
		params.NewScale3D = NewScale3D;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749410
	 * 		Name   -> Function Engine.Actor.SetActorRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::SetActorRotation(const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRotation");
		
		AActor_SetActorRotation_Params params {};
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749570
	 * 		Name   -> Function Engine.Actor.SetActorRelativeTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewRelativeTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorRelativeTransform(const struct FTransform& NewRelativeTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeTransform");
		
		AActor_SetActorRelativeTransform_Params params {};
		params.NewRelativeTransform = NewRelativeTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027496C0
	 * 		Name   -> Function Engine.Actor.SetActorRelativeScale3D
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewRelativeScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorRelativeScale3D(const struct FVector& NewRelativeScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeScale3D");
		
		AActor_SetActorRelativeScale3D_Params params {};
		params.NewRelativeScale = NewRelativeScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027497A0
	 * 		Name   -> Function Engine.Actor.SetActorRelativeRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRelativeRotation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorRelativeRotation(const struct FRotator& NewRelativeRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeRotation");
		
		AActor_SetActorRelativeRotation_Params params {};
		params.NewRelativeRotation = NewRelativeRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749950
	 * 		Name   -> Function Engine.Actor.SetActorRelativeLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewRelativeLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorRelativeLocation(const struct FVector& NewRelativeLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorRelativeLocation");
		
		AActor_SetActorRelativeLocation_Params params {};
		params.NewRelativeLocation = NewRelativeLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749B00
	 * 		Name   -> Function Engine.Actor.SetActorLocationAndRotation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::SetActorLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorLocationAndRotation");
		
		AActor_SetActorLocationAndRotation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749D00
	 * 		Name   -> Function Engine.Actor.SetActorHiddenInGame
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewHidden                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorHiddenInGame(bool bNewHidden)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorHiddenInGame");
		
		AActor_SetActorHiddenInGame_Params params {};
		params.bNewHidden = bNewHidden;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318FB0
	 * 		Name   -> Function Engine.Actor.SetActorEnableCollision
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewActorEnableCollision                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::SetActorEnableCollision(bool bNewActorEnableCollision)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.SetActorEnableCollision");
		
		AActor_SetActorEnableCollision_Params params {};
		params.bNewActorEnableCollision = bNewActorEnableCollision;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02749DE0
	 * 		Name   -> Function Engine.Actor.ServerSendSimpleExecCommandToEveryone
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsReliable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceSendToLocalPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIgnoreRelevancy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ServerSendSimpleExecCommandToEveryone(const class FName& CommandName, bool bIsReliable, bool bForceSendToLocalPlayer, bool bIgnoreRelevancy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ServerSendSimpleExecCommandToEveryone");
		
		AActor_ServerSendSimpleExecCommandToEveryone_Params params {};
		params.CommandName = CommandName;
		params.bIsReliable = bIsReliable;
		params.bForceSendToLocalPlayer = bForceSendToLocalPlayer;
		params.bIgnoreRelevancy = bIgnoreRelevancy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A060
	 * 		Name   -> Function Engine.Actor.ServerSendExecCommandToPlayer
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           ToPC                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		bool                                               bIsReliable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceSendToLocalPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIgnoreRelevancy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ServerSendExecCommandToPlayer(class APlayerController* ToPC, const class FName& CommandName, const struct FBPNetExecParams& ExecParams, bool bIsReliable, bool bForceSendToLocalPlayer, bool bIgnoreRelevancy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ServerSendExecCommandToPlayer");
		
		AActor_ServerSendExecCommandToPlayer_Params params {};
		params.ToPC = ToPC;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		params.bIsReliable = bIsReliable;
		params.bForceSendToLocalPlayer = bForceSendToLocalPlayer;
		params.bIgnoreRelevancy = bIgnoreRelevancy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A3F0
	 * 		Name   -> Function Engine.Actor.ServerSendExecCommandToEveryone
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		bool                                               bIsReliable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceSendToLocalPlayer                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIgnoreRelevancy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ServerSendExecCommandToEveryone(const class FName& CommandName, const struct FBPNetExecParams& ExecParams, bool bIsReliable, bool bForceSendToLocalPlayer, bool bIgnoreRelevancy)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ServerSendExecCommandToEveryone");
		
		AActor_ServerSendExecCommandToEveryone_Params params {};
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		params.bIsReliable = bIsReliable;
		params.bForceSendToLocalPlayer = bForceSendToLocalPlayer;
		params.bIgnoreRelevancy = bIgnoreRelevancy;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A700
	 * 		Name   -> Function Engine.Actor.RerunConstructionScripts
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AActor::RerunConstructionScripts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.RerunConstructionScripts");
		
		AActor_RerunConstructionScripts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A720
	 * 		Name   -> Function Engine.Actor.ReregisterAllComponents
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AActor::ReregisterAllComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReregisterAllComponents");
		
		AActor_ReregisterAllComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A780
	 * 		Name   -> Function Engine.Actor.RemoveTickPrerequisiteComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void AActor::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteComponent");
		
		AActor_RemoveTickPrerequisiteComponent_Params params {};
		params.PrerequisiteComponent = PrerequisiteComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A890
	 * 		Name   -> Function Engine.Actor.RemoveTickPrerequisiteActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.RemoveTickPrerequisiteActor");
		
		AActor_RemoveTickPrerequisiteActor_Params params {};
		params.PrerequisiteActor = PrerequisiteActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.RecieveMatineeUpdated
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::RecieveMatineeUpdated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.RecieveMatineeUpdated");
		
		AActor_RecieveMatineeUpdated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveTick
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveTick(float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveTick");
		
		AActor_ReceiveTick_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveRadialDamage
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DamageReceived                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveRadialDamage(float DamageReceived, class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveRadialDamage");
		
		AActor_ReceiveRadialDamage_Params params {};
		params.DamageReceived = DamageReceived;
		params.DamageType = DamageType;
		params.Origin = Origin;
		params.HitInfo = HitInfo;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceivePointDamage
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitNormal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ShotFromDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceivePointDamage(float Damage, class UDamageType* DamageType, const struct FVector& HitLocation, const struct FVector& HitNormal, class UPrimitiveComponent* HitComponent, const class FName& BoneName, const struct FVector& ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceivePointDamage");
		
		AActor_ReceivePointDamage_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.HitLocation = HitLocation;
		params.HitNormal = HitNormal;
		params.HitComponent = HitComponent;
		params.BoneName = BoneName;
		params.ShotFromDirection = ShotFromDirection;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveInput
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      InputName                                                  (Parm, ZeroConstructor)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     VectorValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bStarted                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnded                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveInput(const class FString& InputName, float Value, const struct FVector& VectorValue, bool bStarted, bool bEnded)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveInput");
		
		AActor_ReceiveInput_Params params {};
		params.InputName = InputName;
		params.Value = Value;
		params.VectorValue = VectorValue;
		params.bStarted = bStarted;
		params.bEnded = bEnded;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveHit
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         MyComp                                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSelfMoved                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitNormal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void AActor::ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveHit");
		
		AActor_ReceiveHit_Params params {};
		params.MyComp = MyComp;
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.bSelfMoved = bSelfMoved;
		params.HitLocation = HitLocation;
		params.HitNormal = HitNormal;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveEndPlay
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		EEndPlayReason                                     EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveEndPlay(EEndPlayReason EndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveEndPlay");
		
		AActor_ReceiveEndPlay_Params params {};
		params.EndPlayReason = EndPlayReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveDestroyed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveDestroyed");
		
		AActor_ReceiveDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveBeginPlay
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveBeginPlay()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveBeginPlay");
		
		AActor_ReceiveBeginPlay_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveAnyDamage
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedBy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveAnyDamage(float Damage, class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveAnyDamage");
		
		AActor_ReceiveAnyDamage_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.InstigatedBy = InstigatedBy;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnReleased
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveActorOnReleased()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnReleased");
		
		AActor_ReceiveActorOnReleased_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchLeave
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorOnInputTouchLeave(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchLeave");
		
		AActor_ReceiveActorOnInputTouchLeave_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchEnter
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorOnInputTouchEnter(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnter");
		
		AActor_ReceiveActorOnInputTouchEnter_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchEnd
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorOnInputTouchEnd(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchEnd");
		
		AActor_ReceiveActorOnInputTouchEnd_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnInputTouchBegin
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorOnInputTouchBegin(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnInputTouchBegin");
		
		AActor_ReceiveActorOnInputTouchBegin_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorOnClicked
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveActorOnClicked()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorOnClicked");
		
		AActor_ReceiveActorOnClicked_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorEndOverlap
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorEndOverlap(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndOverlap");
		
		AActor_ReceiveActorEndOverlap_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorEndCursorOver
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveActorEndCursorOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorEndCursorOver");
		
		AActor_ReceiveActorEndCursorOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorBeginOverlap
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ReceiveActorBeginOverlap(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginOverlap");
		
		AActor_ReceiveActorBeginOverlap_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ReceiveActorBeginCursorOver
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::ReceiveActorBeginCursorOver()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ReceiveActorBeginCursorOver");
		
		AActor_ReceiveActorBeginCursorOver_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274A9A0
	 * 		Name   -> Function Engine.Actor.PropertyServerToClients
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		class AActor*                                      ActorToRep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<unsigned char>                              ReplicationData                                            (ConstParm, Parm, ZeroConstructor)
	 */
	void AActor::PropertyServerToClients(class AActor* ActorToRep, const class FName& PropertyName, TArray<unsigned char> ReplicationData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.PropertyServerToClients");
		
		AActor_PropertyServerToClients_Params params {};
		params.ActorToRep = ActorToRep;
		params.PropertyName = PropertyName;
		params.ReplicationData = ReplicationData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274ABB0
	 * 		Name   -> Function Engine.Actor.PlaySoundOnActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundCue*                                   InSoundCue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::PlaySoundOnActor(class USoundCue* InSoundCue, float VolumeMultiplier, float PitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.PlaySoundOnActor");
		
		AActor_PlaySoundOnActor_Params params {};
		params.InSoundCue = InSoundCue;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274AD90
	 * 		Name   -> Function Engine.Actor.PlaySoundAtLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USoundCue*                                   InSoundCue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SoundLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::PlaySoundAtLocation(class USoundCue* InSoundCue, const struct FVector& SoundLocation, float VolumeMultiplier, float PitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.PlaySoundAtLocation");
		
		AActor_PlaySoundAtLocation_Params params {};
		params.InSoundCue = InSoundCue;
		params.SoundLocation = SoundLocation;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DA30
	 * 		Name   -> Function Engine.Actor.PerformanceThrottledTick
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::PerformanceThrottledTick()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.PerformanceThrottledTick");
		
		AActor_PerformanceThrottledTick_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B020
	 * 		Name   -> Function Engine.Actor.OnRep_ReplicatedMovement
	 * 		Flags  -> (Native, Public)
	 */
	void AActor::OnRep_ReplicatedMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_ReplicatedMovement");
		
		AActor_OnRep_ReplicatedMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B040
	 * 		Name   -> Function Engine.Actor.OnRep_Instigator
	 * 		Flags  -> (Native, Public)
	 */
	void AActor::OnRep_Instigator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_Instigator");
		
		AActor_OnRep_Instigator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B080
	 * 		Name   -> Function Engine.Actor.OnRep_AttachmentReplication
	 * 		Flags  -> (Native, Public)
	 */
	void AActor::OnRep_AttachmentReplication()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnRep_AttachmentReplication");
		
		AActor_OnRep_AttachmentReplication_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B0A0
	 * 		Name   -> Function Engine.Actor.OnInventoryItemGrind
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::OnInventoryItemGrind()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.OnInventoryItemGrind");
		
		AActor_OnInventoryItemGrind_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01B2FDE0
	 * 		Name   -> Function Engine.Actor.NetDetachRootComponentFromAny
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 */
	void AActor::NetDetachRootComponentFromAny()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.NetDetachRootComponentFromAny");
		
		AActor_NetDetachRootComponentFromAny_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B0E0
	 * 		Name   -> Function Engine.Actor.NetAttachRootComponentTo
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     RelativeLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    RelativeRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::NetAttachRootComponentTo(class USceneComponent* InParent, const class FName& InSocketName, const struct FVector& RelativeLocation, const struct FRotator& RelativeRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.NetAttachRootComponentTo");
		
		AActor_NetAttachRootComponentTo_Params params {};
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		params.RelativeLocation = RelativeLocation;
		params.RelativeRotation = RelativeRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B360
	 * 		Name   -> Function Engine.Actor.MulticastPropertyToPlayer
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastPropertyToPlayer(const class FName& PropertyName, class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastPropertyToPlayer");
		
		AActor_MulticastPropertyToPlayer_Params params {};
		params.PropertyName = PropertyName;
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B4B0
	 * 		Name   -> Function Engine.Actor.MulticastProperty
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastProperty(const class FName& PropertyName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastProperty");
		
		AActor_MulticastProperty_Params params {};
		params.PropertyName = PropertyName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B580
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugString
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     TextLocation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor)
	 * 		class AActor*                                      TestBaseActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugString(const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugString");
		
		AActor_MulticastDrawDebugString_Params params {};
		params.TextLocation = TextLocation;
		params.Text = Text;
		params.TestBaseActor = TestBaseActor;
		params.TextColor = TextColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274B930
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugSphere
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugSphere(const struct FVector& Center, float Radius, int32_t Segments, const struct FLinearColor& LineColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugSphere");
		
		AActor_MulticastDrawDebugSphere_Params params {};
		params.Center = Center;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274BCB0
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugPoint
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                PointColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugPoint(const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugPoint");
		
		AActor_MulticastDrawDebugPoint_Params params {};
		params.Position = Position;
		params.Size = Size;
		params.PointColor = PointColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274BFB0
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugPlane
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FPlane                                      PlaneCoordinates                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                PlaneColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugPlane(const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugPlane");
		
		AActor_MulticastDrawDebugPlane_Params params {};
		params.PlaneCoordinates = PlaneCoordinates;
		params.Location = Location;
		params.Size = Size;
		params.PlaneColor = PlaneColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274C350
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugLineTraceHitResult
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm)
	 * 		struct FVector                                     TraceStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TraceEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                StartColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                HitColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LineThickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HitSize                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDrawHitNormal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                HitNormalColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HitNormalLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugLineTraceHitResult(const struct FHitResult& Hit, const struct FVector& TraceStart, const struct FVector& TraceEnd, const struct FLinearColor& StartColor, const struct FLinearColor& HitColor, float LineThickness, float HitSize, bool bDrawHitNormal, const struct FLinearColor& HitNormalColor, float HitNormalLength, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugLineTraceHitResult");
		
		AActor_MulticastDrawDebugLineTraceHitResult_Params params {};
		params.Hit = Hit;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.StartColor = StartColor;
		params.HitColor = HitColor;
		params.LineThickness = LineThickness;
		params.HitSize = HitSize;
		params.bDrawHitNormal = bDrawHitNormal;
		params.HitNormalColor = HitNormalColor;
		params.HitNormalLength = HitNormalLength;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274CB70
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugLine
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugLine(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugLine");
		
		AActor_MulticastDrawDebugLine_Params params {};
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274CF00
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugCylinder
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugCylinder(const struct FVector& Start, const struct FVector& End, float Radius, int32_t Segments, const struct FLinearColor& LineColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugCylinder");
		
		AActor_MulticastDrawDebugCylinder_Params params {};
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274D320
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugCoordinateSystem
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     AxisLoc                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    AxisRot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugCoordinateSystem(const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Duration, float Thickness, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugCoordinateSystem");
		
		AActor_MulticastDrawDebugCoordinateSystem_Params params {};
		params.AxisLoc = AxisLoc;
		params.AxisRot = AxisRot;
		params.Scale = Scale;
		params.Duration = Duration;
		params.Thickness = Thickness;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274D6B0
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugCapsuleWithExtents
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Top                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Bottom                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugCapsuleWithExtents(const struct FVector& Top, const struct FVector& Bottom, float Radius, const struct FLinearColor& LineColor, float Duration, bool bPersistent, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugCapsuleWithExtents");
		
		AActor_MulticastDrawDebugCapsuleWithExtents_Params params {};
		params.Top = Top;
		params.Bottom = Bottom;
		params.Radius = Radius;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274DAD0
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugCapsule
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugCapsule(const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugCapsule");
		
		AActor_MulticastDrawDebugCapsule_Params params {};
		params.Center = Center;
		params.HalfHeight = HalfHeight;
		params.Radius = Radius;
		params.Rotation = Rotation;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274DEF0
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugCamera
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		class ACameraActor*                                CameraActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                CameraColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugCamera(class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugCamera");
		
		AActor_MulticastDrawDebugCamera_Params params {};
		params.CameraActor = CameraActor;
		params.CameraColor = CameraColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274E170
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugBox
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugBox(const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugBox");
		
		AActor_MulticastDrawDebugBox_Params params {};
		params.Center = Center;
		params.Extent = Extent;
		params.LineColor = LineColor;
		params.Rotation = Rotation;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274E520
	 * 		Name   -> Function Engine.Actor.MulticastDrawDebugArrow
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ArrowSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               enableInShipping                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MulticastDrawDebugArrow(const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, bool enableInShipping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MulticastDrawDebugArrow");
		
		AActor_MulticastDrawDebugArrow_Params params {};
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.ArrowSize = ArrowSize;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.enableInShipping = enableInShipping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274E8B0
	 * 		Name   -> Function Engine.Actor.ModifyHudMultiUseLoc
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector2D                                   theVec                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ModifyHudMultiUseLoc(struct FVector2D* theVec, class APlayerController* PC, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ModifyHudMultiUseLoc");
		
		AActor_ModifyHudMultiUseLoc_Params params {};
		params.PC = PC;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (theVec != nullptr)
			*theVec = params.theVec;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274EA80
	 * 		Name   -> Function Engine.Actor.MakeNoise
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APawn*                                       NoiseInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NoiseLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::MakeNoise(float Loudness, class APawn* NoiseInstigator, const struct FVector& NoiseLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeNoise");
		
		AActor_MakeNoise_Params params {};
		params.Loudness = Loudness;
		params.NoiseInstigator = NoiseInstigator;
		params.NoiseLocation = NoiseLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DAB0
	 * 		Name   -> Function Engine.Actor.MakeMIDForMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* AActor::MakeMIDForMaterial(class UMaterialInterface* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.MakeMIDForMaterial");
		
		AActor_MakeMIDForMaterial_Params params {};
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274EC70
	 * 		Name   -> Function Engine.Actor.K2_TeleportTo
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DestLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    DestRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSimpleTeleport                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::K2_TeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bSimpleTeleport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_TeleportTo");
		
		AActor_K2_TeleportTo_Params params {};
		params.DestLocation = DestLocation;
		params.DestRotation = DestRotation;
		params.bSimpleTeleport = bSimpleTeleport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274EE90
	 * 		Name   -> Function Engine.Actor.K2_SetActorLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::K2_SetActorLocation(const struct FVector& NewLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_SetActorLocation");
		
		AActor_K2_SetActorLocation_Params params {};
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.K2_OnEndViewTarget
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::K2_OnEndViewTarget(class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnEndViewTarget");
		
		AActor_K2_OnEndViewTarget_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.K2_OnBecomeViewTarget
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           PC                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::K2_OnBecomeViewTarget(class APlayerController* PC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_OnBecomeViewTarget");
		
		AActor_K2_OnBecomeViewTarget_Params params {};
		params.PC = PC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F000
	 * 		Name   -> Function Engine.Actor.K2_GetWorld
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UWorld* AActor::K2_GetWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetWorld");
		
		AActor_K2_GetWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F040
	 * 		Name   -> Function Engine.Actor.K2_GetRootComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USceneComponent* AActor::K2_GetRootComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetRootComponent");
		
		AActor_K2_GetRootComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F060
	 * 		Name   -> Function Engine.Actor.K2_GetActorRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AActor::K2_GetActorRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorRotation");
		
		AActor_K2_GetActorRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F100
	 * 		Name   -> Function Engine.Actor.K2_GetActorLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::K2_GetActorLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_GetActorLocation");
		
		AActor_K2_GetActorLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F1C0
	 * 		Name   -> Function Engine.Actor.K2_DestroyComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UActorComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void AActor::K2_DestroyComponent(class UActorComponent* Component)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyComponent");
		
		AActor_K2_DestroyComponent_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F2B0
	 * 		Name   -> Function Engine.Actor.K2_DestroyActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AActor::K2_DestroyActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_DestroyActor");
		
		AActor_K2_DestroyActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F2D0
	 * 		Name   -> Function Engine.Actor.K2_AttachRootComponentToActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InParentActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EAttachLocation                                    AttachLocationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::K2_AttachRootComponentToActor(class AActor* InParentActor, const class FName& InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentToActor");
		
		AActor_K2_AttachRootComponentToActor_Params params {};
		params.InParentActor = InParentActor;
		params.InSocketName = InSocketName;
		params.AttachLocationType = AttachLocationType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F530
	 * 		Name   -> Function Engine.Actor.K2_AttachRootComponentTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EAttachLocation                                    AttachLocationType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::K2_AttachRootComponentTo(class USceneComponent* InParent, const class FName& InSocketName, EAttachLocation AttachLocationType, bool bWeldSimulatedBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.K2_AttachRootComponentTo");
		
		AActor_K2_AttachRootComponentTo_Params params {};
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		params.AttachLocationType = AttachLocationType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F7A0
	 * 		Name   -> Function Engine.Actor.IsTargetable
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AActor::IsTargetable()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsTargetable");
		
		AActor_IsTargetable_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F7D0
	 * 		Name   -> Function Engine.Actor.IsShooterCharacter
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsShooterCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsShooterCharacter");
		
		AActor_IsShooterCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F800
	 * 		Name   -> Function Engine.Actor.IsPrimalStructureTurret
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalStructureTurret()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalStructureTurret");
		
		AActor_IsPrimalStructureTurret_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F830
	 * 		Name   -> Function Engine.Actor.IsPrimalStructureItemContainer
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalStructureItemContainer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalStructureItemContainer");
		
		AActor_IsPrimalStructureItemContainer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F860
	 * 		Name   -> Function Engine.Actor.IsPrimalStructure
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalStructure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalStructure");
		
		AActor_IsPrimalStructure_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F890
	 * 		Name   -> Function Engine.Actor.IsPrimalDino
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalDino()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalDino");
		
		AActor_IsPrimalDino_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F8C0
	 * 		Name   -> Function Engine.Actor.IsPrimalCharacterOrStructure
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalCharacterOrStructure()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalCharacterOrStructure");
		
		AActor_IsPrimalCharacterOrStructure_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F920
	 * 		Name   -> Function Engine.Actor.IsPrimalCharacter
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsPrimalCharacter()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsPrimalCharacter");
		
		AActor_IsPrimalCharacter_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274F950
	 * 		Name   -> Function Engine.Actor.IsOwnedOrControlledBy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      TestOwner                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::IsOwnedOrControlledBy(class AActor* TestOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsOwnedOrControlledBy");
		
		AActor_IsOwnedOrControlledBy_Params params {};
		params.TestOwner = TestOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FA30
	 * 		Name   -> Function Engine.Actor.IsLocallyControlledByPlayer
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsLocallyControlledByPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsLocallyControlledByPlayer");
		
		AActor_IsLocallyControlledByPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F2F570
	 * 		Name   -> Function Engine.Actor.IsFirstPersonMeshVisible
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsFirstPersonMeshVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsFirstPersonMeshVisible");
		
		AActor_IsFirstPersonMeshVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F2F7A0
	 * 		Name   -> Function Engine.Actor.IsDead
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsDead()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsDead");
		
		AActor_IsDead_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FA60
	 * 		Name   -> Function Engine.Actor.IsCorruptDino
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::IsCorruptDino()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.IsCorruptDino");
		
		AActor_IsCorruptDino_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E71A00
	 * 		Name   -> Function Engine.Actor.HasAuthority
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AActor::HasAuthority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.HasAuthority");
		
		AActor_HasAuthority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FA90
	 * 		Name   -> Function Engine.Actor.GetVisibleComponentByClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipHiddenComponents                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UPrimitiveComponent* AActor::GetVisibleComponentByClass(class UClass* ComponentClass, bool bSkipHiddenComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVisibleComponentByClass");
		
		AActor_GetVisibleComponentByClass_Params params {};
		params.ComponentClass = ComponentClass;
		params.bSkipHiddenComponents = bSkipHiddenComponents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FBF0
	 * 		Name   -> Function Engine.Actor.GetVerticalDistanceTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetVerticalDistanceTo(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVerticalDistanceTo");
		
		AActor_GetVerticalDistanceTo_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FCD0
	 * 		Name   -> Function Engine.Actor.GetVelocity
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIsForRagdoll                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AActor::GetVelocity(bool bIsForRagdoll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetVelocity");
		
		AActor_GetVelocity_Params params {};
		params.bIsForRagdoll = bIsForRagdoll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FDD0
	 * 		Name   -> Function Engine.Actor.GetUsablePriority
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	float AActor::GetUsablePriority()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetUsablePriority");
		
		AActor_GetUsablePriority_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FE10
	 * 		Name   -> Function Engine.Actor.GetTransform
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTransform AActor::GetTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTransform");
		
		AActor_GetTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FE60
	 * 		Name   -> Function Engine.Actor.GetTargetingLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Attacker                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AActor::GetTargetingLocation(class AActor* Attacker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetTargetingLocation");
		
		AActor_GetTargetingLocation_Params params {};
		params.Attacker = Attacker;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FF50
	 * 		Name   -> Function Engine.Actor.GetSecondaryMountedActor
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	class AActor* AActor::GetSecondaryMountedActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetSecondaryMountedActor");
		
		AActor_GetSecondaryMountedActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FF80
	 * 		Name   -> Function Engine.Actor.GetOwnerController
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class APlayerController* AActor::GetOwnerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOwnerController");
		
		AActor_GetOwnerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FFB0
	 * 		Name   -> Function Engine.Actor.GetOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* AActor::GetOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOwner");
		
		AActor_GetOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0274FFD0
	 * 		Name   -> Function Engine.Actor.GetOverlappingComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UPrimitiveComponent*>                 OverlappingComponents                                      (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void AActor::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* OverlappingComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingComponents");
		
		AActor_GetOverlappingComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OverlappingComponents != nullptr)
			*OverlappingComponents = params.OverlappingComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750090
	 * 		Name   -> Function Engine.Actor.GetOverlappingActors
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AActor*>                              OverlappingActors                                          (Parm, OutParm, ZeroConstructor)
	 * 		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, class UClass* ClassFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetOverlappingActors");
		
		AActor_GetOverlappingActors_Params params {};
		params.ClassFilter = ClassFilter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OverlappingActors != nullptr)
			*OverlappingActors = params.OverlappingActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027501E0
	 * 		Name   -> Function Engine.Actor.GetLifeSpan
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AActor::GetLifeSpan()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetLifeSpan");
		
		AActor_GetLifeSpan_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750220
	 * 		Name   -> Function Engine.Actor.GetInterpolatedTransform
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTransform AActor::GetInterpolatedTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInterpolatedTransform");
		
		AActor_GetInterpolatedTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750290
	 * 		Name   -> Function Engine.Actor.GetInterpolatedRotation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AActor::GetInterpolatedRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInterpolatedRotation");
		
		AActor_GetInterpolatedRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027502D0
	 * 		Name   -> Function Engine.Actor.GetInterpolatedLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetInterpolatedLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInterpolatedLocation");
		
		AActor_GetInterpolatedLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750310
	 * 		Name   -> Function Engine.Actor.GetInstigatorController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* AActor::GetInstigatorController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigatorController");
		
		AActor_GetInstigatorController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750350
	 * 		Name   -> Function Engine.Actor.GetInstigator
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* AActor::GetInstigator()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInstigator");
		
		AActor_GetInstigator_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750370
	 * 		Name   -> Function Engine.Actor.GetInputVectorAxisValue
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        InputAxisKey                                               (ConstParm, Parm)
	 */
	struct FVector AActor::GetInputVectorAxisValue(const struct FKey& InputAxisKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputVectorAxisValue");
		
		AActor_GetInputVectorAxisValue_Params params {};
		params.InputAxisKey = InputAxisKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027504C0
	 * 		Name   -> Function Engine.Actor.GetInputAxisValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InputAxisName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetInputAxisValue(const class FName& InputAxisName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisValue");
		
		AActor_GetInputAxisValue_Params params {};
		params.InputAxisName = InputAxisName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027505A0
	 * 		Name   -> Function Engine.Actor.GetInputAxisKeyValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        InputAxisKey                                               (ConstParm, Parm)
	 */
	float AActor::GetInputAxisKeyValue(const struct FKey& InputAxisKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetInputAxisKeyValue");
		
		AActor_GetInputAxisKeyValue_Params params {};
		params.InputAxisKey = InputAxisKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027506E0
	 * 		Name   -> Function Engine.Actor.GetHorizontalDotProductTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetHorizontalDotProductTo(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDotProductTo");
		
		AActor_GetHorizontalDotProductTo_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027507C0
	 * 		Name   -> Function Engine.Actor.GetHorizontalDistanceTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetHorizontalDistanceTo(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetHorizontalDistanceTo");
		
		AActor_GetHorizontalDistanceTo_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027508A0
	 * 		Name   -> Function Engine.Actor.GetDotProductTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetDotProductTo(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDotProductTo");
		
		AActor_GetDotProductTo_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750980
	 * 		Name   -> Function Engine.Actor.GetDistanceTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float AActor::GetDistanceTo(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetDistanceTo");
		
		AActor_GetDistanceTo_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750A60
	 * 		Name   -> Function Engine.Actor.GetComponentsByCustomTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        TheTag                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	TArray<class UActorComponent*> AActor::GetComponentsByCustomTag(const class FName& TheTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByCustomTag");
		
		AActor_GetComponentsByCustomTag_Params params {};
		params.TheTag = TheTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750B80
	 * 		Name   -> Function Engine.Actor.GetComponentsByClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	TArray<class UActorComponent*> AActor::GetComponentsByClass(class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentsByClass");
		
		AActor_GetComponentsByClass_Params params {};
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750CA0
	 * 		Name   -> Function Engine.Actor.GetComponentByCustomTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        TheTag                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UActorComponent* AActor::GetComponentByCustomTag(const class FName& TheTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByCustomTag");
		
		AActor_GetComponentByCustomTag_Params params {};
		params.TheTag = TheTag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750DC0
	 * 		Name   -> Function Engine.Actor.GetComponentByClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class UClass*                                      ComponentClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UActorComponent* AActor::GetComponentByClass(class UClass* ComponentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetComponentByClass");
		
		AActor_GetComponentByClass_Params params {};
		params.ComponentClass = ComponentClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750EA0
	 * 		Name   -> Function Engine.Actor.GetCharacterController
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* AActor::GetCharacterController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetCharacterController");
		
		AActor_GetCharacterController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750ED0
	 * 		Name   -> Function Engine.Actor.GetAttachedSoundVolumeMultiplier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AActor::GetAttachedSoundVolumeMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedSoundVolumeMultiplier");
		
		AActor_GetAttachedSoundVolumeMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750F10
	 * 		Name   -> Function Engine.Actor.GetAttachedSoundPitchMultiplier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float AActor::GetAttachedSoundPitchMultiplier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedSoundPitchMultiplier");
		
		AActor_GetAttachedSoundPitchMultiplier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02750F50
	 * 		Name   -> Function Engine.Actor.GetAttachedActors
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	void AActor::GetAttachedActors(TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAttachedActors");
		
		AActor_GetAttachedActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751020
	 * 		Name   -> Function Engine.Actor.GetAllSceneComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class USceneComponent*>                     OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void AActor::GetAllSceneComponents(TArray<class USceneComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetAllSceneComponents");
		
		AActor_GetAllSceneComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027510E0
	 * 		Name   -> Function Engine.Actor.GetActorViewDirection
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorViewDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorViewDirection");
		
		AActor_GetActorViewDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751140
	 * 		Name   -> Function Engine.Actor.GetActorUpVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorUpVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorUpVector");
		
		AActor_GetActorUpVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751180
	 * 		Name   -> Function Engine.Actor.GetActorTimeDilation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float AActor::GetActorTimeDilation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorTimeDilation");
		
		AActor_GetActorTimeDilation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027511D0
	 * 		Name   -> Function Engine.Actor.GetActorScale3D
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorScale3D()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorScale3D");
		
		AActor_GetActorScale3D_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751250
	 * 		Name   -> Function Engine.Actor.GetActorRightVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorRightVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRightVector");
		
		AActor_GetActorRightVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751290
	 * 		Name   -> Function Engine.Actor.GetActorRelativeScale3D
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorRelativeScale3D()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorRelativeScale3D");
		
		AActor_GetActorRelativeScale3D_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751300
	 * 		Name   -> Function Engine.Actor.GetActorForwardVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector AActor::GetActorForwardVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorForwardVector");
		
		AActor_GetActorForwardVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751340
	 * 		Name   -> Function Engine.Actor.GetActorEnableCollision
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool AActor::GetActorEnableCollision()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorEnableCollision");
		
		AActor_GetActorEnableCollision_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751370
	 * 		Name   -> Function Engine.Actor.GetActorClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UClass* AActor::GetActorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorClass");
		
		AActor_GetActorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751390
	 * 		Name   -> Function Engine.Actor.GetActorBounds
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bOnlyCollidingComponents                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::GetActorBounds(bool bOnlyCollidingComponents, struct FVector* Origin, struct FVector* BoxExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.GetActorBounds");
		
		AActor_GetActorBounds_Params params {};
		params.bOnlyCollidingComponents = bOnlyCollidingComponents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751560
	 * 		Name   -> Function Engine.Actor.ForceReplicateNowWithChannel
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AActor::ForceReplicateNowWithChannel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceReplicateNowWithChannel");
		
		AActor_ForceReplicateNowWithChannel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751580
	 * 		Name   -> Function Engine.Actor.ForceReplicateNow
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bForceCreateChannel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceCreateChannelIfRelevant                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ForceReplicateNow(bool bForceCreateChannel, bool bForceCreateChannelIfRelevant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceReplicateNow");
		
		AActor_ForceReplicateNow_Params params {};
		params.bForceCreateChannel = bForceCreateChannel;
		params.bForceCreateChannelIfRelevant = bForceCreateChannelIfRelevant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027516E0
	 * 		Name   -> Function Engine.Actor.ForceNetUpdate
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDormantDontReplicateProperties                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAbsoluteForceNetUpdate                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDontUpdateChannel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ForceNetUpdate(bool bDormantDontReplicateProperties, bool bAbsoluteForceNetUpdate, bool bDontUpdateChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceNetUpdate");
		
		AActor_ForceNetUpdate_Params params {};
		params.bDormantDontReplicateProperties = bDormantDontReplicateProperties;
		params.bAbsoluteForceNetUpdate = bAbsoluteForceNetUpdate;
		params.bDontUpdateChannel = bDontUpdateChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027518D0
	 * 		Name   -> Function Engine.Actor.ForceDestroy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AActor::ForceDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ForceDestroy");
		
		AActor_ForceDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751900
	 * 		Name   -> Function Engine.Actor.FlushNetDormancy
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 */
	void AActor::FlushNetDormancy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.FlushNetDormancy");
		
		AActor_FlushNetDormancy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EEBD00
	 * 		Name   -> Function Engine.Actor.EnableInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::EnableInput(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.EnableInput");
		
		AActor_EnableInput_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751920
	 * 		Name   -> Function Engine.Actor.DrawInEditorViewport
	 * 		Flags  -> (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UCanvas*                                     Canvas                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            LHSX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            InOutLHSY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            RHSX                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            InOutRHSY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ViewLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    ViewRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::DrawInEditorViewport(class UCanvas* Canvas, int32_t LHSX, int32_t InOutLHSY, int32_t RHSX, int32_t InOutRHSY, const struct FVector& ViewLocation, const struct FRotator& ViewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.DrawInEditorViewport");
		
		AActor_DrawInEditorViewport_Params params {};
		params.Canvas = Canvas;
		params.LHSX = LHSX;
		params.InOutLHSY = InOutLHSY;
		params.RHSX = RHSX;
		params.InOutRHSY = InOutRHSY;
		params.ViewLocation = ViewLocation;
		params.ViewRotation = ViewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.DrawBasicFloatingHUD
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AHUD*                                        ForHUD                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::DrawBasicFloatingHUD(class AHUD* ForHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.DrawBasicFloatingHUD");
		
		AActor_DrawBasicFloatingHUD_Params params {};
		params.ForHUD = ForHUD;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EEBEA0
	 * 		Name   -> Function Engine.Actor.DisableInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           PlayerController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::DisableInput(class APlayerController* PlayerController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.DisableInput");
		
		AActor_DisableInput_Params params {};
		params.PlayerController = PlayerController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751D40
	 * 		Name   -> Function Engine.Actor.DetachRootComponentFromParent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bMaintainWorldPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::DetachRootComponentFromParent(bool bMaintainWorldPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.DetachRootComponentFromParent");
		
		AActor_DetachRootComponentFromParent_Params params {};
		params.bMaintainWorldPosition = bMaintainWorldPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751E10
	 * 		Name   -> Function Engine.Actor.ClientMultiUse
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            UseIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ClientMultiUse(class APlayerController* ForPC, int32_t UseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ClientMultiUse");
		
		AActor_ClientMultiUse_Params params {};
		params.ForPC = ForPC;
		params.UseIndex = UseIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02751F70
	 * 		Name   -> Function Engine.Actor.CalculateComponentsBoundingBoxInLocalSpace
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bNonColliding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FBox AActor::CalculateComponentsBoundingBoxInLocalSpace(bool bNonColliding)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.CalculateComponentsBoundingBoxInLocalSpace");
		
		AActor_CalculateComponentsBoundingBoxInLocalSpace_Params params {};
		params.bNonColliding = bNonColliding;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752070
	 * 		Name   -> Function Engine.Actor.BPTryMultiUse
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            UseIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPTryMultiUse(class APlayerController* ForPC, int32_t UseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPTryMultiUse");
		
		AActor_BPTryMultiUse_Params params {};
		params.ForPC = ForPC;
		params.UseIndex = UseIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPServerHandleNetExecCommand
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           FromPC                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool AActor::BPServerHandleNetExecCommand(class APlayerController* FromPC, const class FName& CommandName, const struct FBPNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPServerHandleNetExecCommand");
		
		AActor_BPServerHandleNetExecCommand_Params params {};
		params.FromPC = FromPC;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPPreventAttachments
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UObject*                                     ForItem                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPPreventAttachments(class UObject* ForItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPPreventAttachments");
		
		AActor_BPPreventAttachments_Params params {};
		params.ForItem = ForItem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPPreInitializeComponents
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::BPPreInitializeComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPPreInitializeComponents");
		
		AActor_BPPreInitializeComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPPostInitializeComponents
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::BPPostInitializeComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPPostInitializeComponents");
		
		AActor_BPPostInitializeComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPOverrideUILocation
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AActor::BPOverrideUILocation(class APlayerController* ForPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPOverrideUILocation");
		
		AActor_BPOverrideUILocation_Params params {};
		params.ForPC = ForPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027521E0
	 * 		Name   -> Function Engine.Actor.BPIsA
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      anActorClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPIsA(class UClass* anActorClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPIsA");
		
		AActor_BPIsA_Params params {};
		params.anActorClass = anActorClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPInventoryItemUsed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UObject*                                     InventoryItemObject                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::BPInventoryItemUsed(class UObject* InventoryItemObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPInventoryItemUsed");
		
		AActor_BPInventoryItemUsed_Params params {};
		params.InventoryItemObject = InventoryItemObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPInventoryItemDropped
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UObject*                                     InventoryItemObject                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::BPInventoryItemDropped(class UObject* InventoryItemObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPInventoryItemDropped");
		
		AActor_BPInventoryItemDropped_Params params {};
		params.InventoryItemObject = InventoryItemObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPGetShowDebugAnimationComponents
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		TArray<class USkeletalMeshComponent*>              SkelMeshComponents                                         (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void AActor::BPGetShowDebugAnimationComponents(TArray<class USkeletalMeshComponent*>* SkelMeshComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetShowDebugAnimationComponents");
		
		AActor_BPGetShowDebugAnimationComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SkelMeshComponents != nullptr)
			*SkelMeshComponents = params.SkelMeshComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPGetMultiUseEntries
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FMultiUseEntry>                      MultiUseEntries                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference)
	 */
	TArray<struct FMultiUseEntry> AActor::BPGetMultiUseEntries(class APlayerController* ForPC, TArray<struct FMultiUseEntry> MultiUseEntries)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetMultiUseEntries");
		
		AActor_BPGetMultiUseEntries_Params params {};
		params.ForPC = ForPC;
		params.MultiUseEntries = MultiUseEntries;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPGetMultiUseCenterText
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            UseIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      OutCenterText                                              (Parm, OutParm, ZeroConstructor)
	 * 		struct FLinearColor                                OutCenterTextColor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPGetMultiUseCenterText(class APlayerController* ForPC, int32_t UseIndex, class FString* OutCenterText, struct FLinearColor* OutCenterTextColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetMultiUseCenterText");
		
		AActor_BPGetMultiUseCenterText_Params params {};
		params.ForPC = ForPC;
		params.UseIndex = UseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutCenterText != nullptr)
			*OutCenterText = params.OutCenterText;
		if (OutCenterTextColor != nullptr)
			*OutCenterTextColor = params.OutCenterTextColor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPGetExtraSpecialBlueprintInt
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            toCheck                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t AActor::BPGetExtraSpecialBlueprintInt(int32_t toCheck)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetExtraSpecialBlueprintInt");
		
		AActor_BPGetExtraSpecialBlueprintInt_Params params {};
		params.toCheck = toCheck;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPGetBonesToHideOnAllocation
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	TArray<class FName> AActor::BPGetBonesToHideOnAllocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetBonesToHideOnAllocation");
		
		AActor_BPGetBonesToHideOnAllocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027522C0
	 * 		Name   -> Function Engine.Actor.BPGetActorEyesViewPoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::BPGetActorEyesViewPoint(struct FVector* Location, struct FRotator* Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPGetActorEyesViewPoint");
		
		AActor_BPGetActorEyesViewPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPForceAllowsInventoryUse
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class UObject*                                     InventoryItemObject                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPForceAllowsInventoryUse(class UObject* InventoryItemObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPForceAllowsInventoryUse");
		
		AActor_BPForceAllowsInventoryUse_Params params {};
		params.InventoryItemObject = InventoryItemObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPCustomIsRelevantForClient
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPCustomIsRelevantForClient(class APlayerController* ForPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPCustomIsRelevantForClient");
		
		AActor_BPCustomIsRelevantForClient_Params params {};
		params.ForPC = ForPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPConsumeUsePinCode
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      FromKeypadActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            appledPinCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsActivating                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPConsumeUsePinCode(class AActor* FromKeypadActor, class APlayerController* ForPC, int32_t appledPinCode, bool bIsActivating)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPConsumeUsePinCode");
		
		AActor_BPConsumeUsePinCode_Params params {};
		params.FromKeypadActor = FromKeypadActor;
		params.ForPC = ForPC;
		params.appledPinCode = appledPinCode;
		params.bIsActivating = bIsActivating;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPConsumeSetPinCode
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            appledPinCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsSetting                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            TheCustomIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPConsumeSetPinCode(class APlayerController* ForPC, int32_t appledPinCode, bool bIsSetting, int32_t TheCustomIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPConsumeSetPinCode");
		
		AActor_BPConsumeSetPinCode_Params params {};
		params.ForPC = ForPC;
		params.appledPinCode = appledPinCode;
		params.bIsSetting = bIsSetting;
		params.TheCustomIndex = TheCustomIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPClientHandleNetExecCommand
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::BPClientHandleNetExecCommand(const class FName& CommandName, const struct FBPNetExecParams& ExecParams, class APlayerController* ForPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPClientHandleNetExecCommand");
		
		AActor_BPClientHandleNetExecCommand_Params params {};
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		params.ForPC = ForPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPClientDoMultiUse
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ClientUseIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::BPClientDoMultiUse(class APlayerController* ForPC, int32_t ClientUseIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPClientDoMultiUse");
		
		AActor_BPClientDoMultiUse_Params params {};
		params.ForPC = ForPC;
		params.ClientUseIndex = ClientUseIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPCheckForErrors
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	TArray<struct FBPMapCheckEntry> AActor::BPCheckForErrors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPCheckForErrors");
		
		AActor_BPCheckForErrors_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPChangedActorTeam
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::BPChangedActorTeam()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPChangedActorTeam");
		
		AActor_BPChangedActorTeam_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BPAttachedRootComponent
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void AActor::BPAttachedRootComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BPAttachedRootComponent");
		
		AActor_BPAttachedRootComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BP_OverrideTargetingLocation
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Attacker                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AActor::BP_OverrideTargetingLocation(class AActor* Attacker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BP_OverrideTargetingLocation");
		
		AActor_BP_OverrideTargetingLocation_Params params {};
		params.Attacker = Attacker;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.BP_GetHUDWorldDrawLocation
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        HUDTag                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AActor::BP_GetHUDWorldDrawLocation(const class FName& HUDTag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.BP_GetHUDWorldDrawLocation");
		
		AActor_BP_GetHUDWorldDrawLocation_Params params {};
		params.HUDTag = HUDTag;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.AllowManualMultiUseActivation
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::AllowManualMultiUseActivation(class APlayerController* ForPC)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AllowManualMultiUseActivation");
		
		AActor_AllowManualMultiUseActivation_Params params {};
		params.ForPC = ForPC;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752400
	 * 		Name   -> Function Engine.Actor.AllowIgnoreCharacterEncroachment
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      EncroachingCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::AllowIgnoreCharacterEncroachment(class UPrimitiveComponent* HitComponent, class AActor* EncroachingCharacter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AllowIgnoreCharacterEncroachment");
		
		AActor_AllowIgnoreCharacterEncroachment_Params params {};
		params.HitComponent = HitComponent;
		params.EncroachingCharacter = EncroachingCharacter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752560
	 * 		Name   -> Function Engine.Actor.AllowGrappling
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	bool AActor::AllowGrappling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AllowGrappling");
		
		AActor_AllowGrappling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752590
	 * 		Name   -> Function Engine.Actor.AddTickPrerequisiteComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteComponent");
		
		AActor_AddTickPrerequisiteComponent_Params params {};
		params.PrerequisiteComponent = PrerequisiteComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027526B0
	 * 		Name   -> Function Engine.Actor.AddTickPrerequisiteActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddTickPrerequisiteActor");
		
		AActor_AddTickPrerequisiteActor_Params params {};
		params.PrerequisiteActor = PrerequisiteActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027527D0
	 * 		Name   -> Function Engine.Actor.AddComponent
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        TemplateName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bManualAttachment                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  RelativeTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     ComponentTemplateContext                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UActorComponent* AActor::AddComponent(const class FName& TemplateName, bool bManualAttachment, const struct FTransform& RelativeTransform, class UObject* ComponentTemplateContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddComponent");
		
		AActor_AddComponent_Params params {};
		params.TemplateName = TemplateName;
		params.bManualAttachment = bManualAttachment;
		params.RelativeTransform = RelativeTransform;
		params.ComponentTemplateContext = ComponentTemplateContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752A40
	 * 		Name   -> Function Engine.Actor.AddActorWorldTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorWorldTransform(const struct FTransform& DeltaTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorWorldTransform");
		
		AActor_AddActorWorldTransform_Params params {};
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752B90
	 * 		Name   -> Function Engine.Actor.AddActorWorldRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorWorldRotation(const struct FRotator& DeltaRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorWorldRotation");
		
		AActor_AddActorWorldRotation_Params params {};
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752DA0
	 * 		Name   -> Function Engine.Actor.AddActorWorldOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorWorldOffset(const struct FVector& DeltaLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorWorldOffset");
		
		AActor_AddActorWorldOffset_Params params {};
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02752F50
	 * 		Name   -> Function Engine.Actor.AddActorLocalTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorLocalTransform(const struct FTransform& NewTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorLocalTransform");
		
		AActor_AddActorLocalTransform_Params params {};
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027530A0
	 * 		Name   -> Function Engine.Actor.AddActorLocalRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorLocalRotation(const struct FRotator& DeltaRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorLocalRotation");
		
		AActor_AddActorLocalRotation_Params params {};
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753220
	 * 		Name   -> Function Engine.Actor.AddActorLocalOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::AddActorLocalOffset(const struct FVector& DeltaLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.AddActorLocalOffset");
		
		AActor_AddActorLocalOffset_Params params {};
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorSemaphoreTaken__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        SemaphoreName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorSemaphoreTaken__DelegateSignature(const class FName& SemaphoreName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorSemaphoreTaken__DelegateSignature");
		
		AActor_ActorSemaphoreTaken__DelegateSignature_Params params {};
		params.SemaphoreName = SemaphoreName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027533A0
	 * 		Name   -> Function Engine.Actor.ActorPlaySoundUnreliable
	 * 		Flags  -> (Net, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  SoundAsset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAttach                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LocOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorPlaySoundUnreliable(class USoundBase* SoundAsset, bool bAttach, const class FName& BoneName, const struct FVector& LocOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorPlaySoundUnreliable");
		
		AActor_ActorPlaySoundUnreliable_Params params {};
		params.SoundAsset = SoundAsset;
		params.bAttach = bAttach;
		params.BoneName = BoneName;
		params.LocOffset = LocOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753640
	 * 		Name   -> Function Engine.Actor.ActorPlaySound
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  SoundAsset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAttach                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LocOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorPlaySound(class USoundBase* SoundAsset, bool bAttach, const class FName& BoneName, const struct FVector& LocOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorPlaySound");
		
		AActor_ActorPlaySound_Params params {};
		params.SoundAsset = SoundAsset;
		params.bAttach = bAttach;
		params.BoneName = BoneName;
		params.LocOffset = LocOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorOnReleasedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorOnReleasedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorOnReleasedSignature__DelegateSignature");
		
		AActor_ActorOnReleasedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorOnInputTouchEndSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorOnInputTouchEndSignature__DelegateSignature(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorOnInputTouchEndSignature__DelegateSignature");
		
		AActor_ActorOnInputTouchEndSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorOnInputTouchBeginSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorOnInputTouchBeginSignature__DelegateSignature(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorOnInputTouchBeginSignature__DelegateSignature");
		
		AActor_ActorOnInputTouchBeginSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorOnClickedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorOnClickedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorOnClickedSignature__DelegateSignature");
		
		AActor_ActorOnClickedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorMatineeUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorMatineeUpdated__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorMatineeUpdated__DelegateSignature");
		
		AActor_ActorMatineeUpdated__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorHitSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      SelfActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void AActor::ActorHitSignature__DelegateSignature(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorHitSignature__DelegateSignature");
		
		AActor_ActorHitSignature__DelegateSignature_Params params {};
		params.SelfActor = SelfActor;
		params.OtherActor = OtherActor;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027538E0
	 * 		Name   -> Function Engine.Actor.ActorHasTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AActor::ActorHasTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorHasTag");
		
		AActor_ActorHasTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorEndTouchOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorEndTouchOverSignature__DelegateSignature(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorEndTouchOverSignature__DelegateSignature");
		
		AActor_ActorEndTouchOverSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorEndPlaySignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		EEndPlayReason                                     EndPlayReason                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorEndPlaySignature__DelegateSignature(EEndPlayReason EndPlayReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorEndPlaySignature__DelegateSignature");
		
		AActor_ActorEndPlaySignature__DelegateSignature_Params params {};
		params.EndPlayReason = EndPlayReason;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorEndOverlapSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorEndOverlapSignature__DelegateSignature(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorEndOverlapSignature__DelegateSignature");
		
		AActor_ActorEndOverlapSignature__DelegateSignature_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorEndCursorOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorEndCursorOverSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorEndCursorOverSignature__DelegateSignature");
		
		AActor_ActorEndCursorOverSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorDestroyedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorDestroyedSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorDestroyedSignature__DelegateSignature");
		
		AActor_ActorDestroyedSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorCustomEventSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        EventCustomName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      EventCustomString                                          (Parm, ZeroConstructor)
	 * 		class AActor*                                      InstigatorActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorCustomEventSignature__DelegateSignature(const class FName& EventCustomName, const class FString& EventCustomString, class AActor* InstigatorActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorCustomEventSignature__DelegateSignature");
		
		AActor_ActorCustomEventSignature__DelegateSignature_Params params {};
		params.EventCustomName = EventCustomName;
		params.EventCustomString = EventCustomString;
		params.InstigatorActor = InstigatorActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorBeginTouchOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorBeginTouchOverSignature__DelegateSignature(ETouchIndex FingerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorBeginTouchOverSignature__DelegateSignature");
		
		AActor_ActorBeginTouchOverSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorBeginOverlapSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AActor::ActorBeginOverlapSignature__DelegateSignature(class AActor* OtherActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorBeginOverlapSignature__DelegateSignature");
		
		AActor_ActorBeginOverlapSignature__DelegateSignature_Params params {};
		params.OtherActor = OtherActor;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Actor.ActorBeginCursorOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void AActor::ActorBeginCursorOverSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Actor.ActorBeginCursorOverSignature__DelegateSignature");
		
		AActor_ActorBeginCursorOverSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Actor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F0A230
	 * 		Name   -> Function Engine.Controller.UnPossess
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AController::UnPossess()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.UnPossess");
		
		AController_UnPossess_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027479B0
	 * 		Name   -> Function Engine.Controller.StopMovement
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AController::StopMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.StopMovement");
		
		AController_StopMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027479D0
	 * 		Name   -> Function Engine.Controller.SetInitialLocationAndRotation
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void AController::SetInitialLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetInitialLocationAndRotation");
		
		AController_SetInitialLocationAndRotation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E69770
	 * 		Name   -> Function Engine.Controller.SetControlRotation
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void AController::SetControlRotation(const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.SetControlRotation");
		
		AController_SetControlRotation_Params params {};
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Controller.ReceiveInstigatedAnyDamage
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Protected, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::ReceiveInstigatedAnyDamage(float Damage, class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.ReceiveInstigatedAnyDamage");
		
		AController_ReceiveInstigatedAnyDamage_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.DamagedActor = DamagedActor;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E68B90
	 * 		Name   -> Function Engine.Controller.Possess
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APawn*                                       inPawn                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::Possess(class APawn* inPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.Possess");
		
		AController_Possess_Params params {};
		params.inPawn = inPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747B10
	 * 		Name   -> Function Engine.Controller.OnRep_PlayerState
	 * 		Flags  -> (Native, Public)
	 */
	void AController::OnRep_PlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_PlayerState");
		
		AController_OnRep_PlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747B70
	 * 		Name   -> Function Engine.Controller.OnRep_Pawn
	 * 		Flags  -> (Native, Public)
	 */
	void AController::OnRep_Pawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.OnRep_Pawn");
		
		AController_OnRep_Pawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747B90
	 * 		Name   -> Function Engine.Controller.LineOfSightTo
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ViewPoint                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAlternateChecks                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AController::LineOfSightTo(class AActor* Other, const struct FVector& ViewPoint, bool bAlternateChecks)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.LineOfSightTo");
		
		AController_LineOfSightTo_Params params {};
		params.Other = Other;
		params.ViewPoint = ViewPoint;
		params.bAlternateChecks = bAlternateChecks;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F6FA70
	 * 		Name   -> Function Engine.Controller.K2_GetPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* AController::K2_GetPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.K2_GetPawn");
		
		AController_K2_GetPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747D90
	 * 		Name   -> Function Engine.Controller.IsLocalPlayerController
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AController::IsLocalPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalPlayerController");
		
		AController_IsLocalPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747DC0
	 * 		Name   -> Function Engine.Controller.IsLocalController
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AController::IsLocalController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.IsLocalController");
		
		AController_IsLocalController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Controller.InstigatedAnyDamageSignature__DelegateSignature
	 * 		Flags  -> (BlueprintAuthorityOnly, MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		float                                              Damage                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDamageType*                                 DamageType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::InstigatedAnyDamageSignature__DelegateSignature(float Damage, class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.InstigatedAnyDamageSignature__DelegateSignature");
		
		AController_InstigatedAnyDamageSignature__DelegateSignature_Params params {};
		params.Damage = Damage;
		params.DamageType = DamageType;
		params.DamagedActor = DamagedActor;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747DF0
	 * 		Name   -> Function Engine.Controller.GetViewTarget
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* AController::GetViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetViewTarget");
		
		AController_GetViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747E20
	 * 		Name   -> Function Engine.Controller.GetPlayerViewPoint
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::GetPlayerViewPoint(struct FVector* Location, struct FRotator* Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetPlayerViewPoint");
		
		AController_GetPlayerViewPoint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747F60
	 * 		Name   -> Function Engine.Controller.GetDesiredRotation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AController::GetDesiredRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetDesiredRotation");
		
		AController_GetDesiredRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748000
	 * 		Name   -> Function Engine.Controller.GetControlRotation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator AController::GetControlRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.GetControlRotation");
		
		AController_GetControlRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748070
	 * 		Name   -> Function Engine.Controller.ClientSetRotation
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bResetCamera                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::ClientSetRotation(const struct FRotator& NewRotation, bool bResetCamera)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetRotation");
		
		AController_ClientSetRotation_Params params {};
		params.NewRotation = NewRotation;
		params.bResetCamera = bResetCamera;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748230
	 * 		Name   -> Function Engine.Controller.ClientSetLocation
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AController::ClientSetLocation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.ClientSetLocation");
		
		AController_ClientSetLocation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027483A0
	 * 		Name   -> Function Engine.Controller.CastToPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class APlayerController* AController::CastToPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Controller.CastToPlayerController");
		
		AController_CastToPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Controller");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimationAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimationAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimationAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FAC0
	 * 		Name   -> Function Engine.ActorComponent.ToggleActive
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UActorComponent::ToggleActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ToggleActive");
		
		UActorComponent_ToggleActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757210
	 * 		Name   -> Function Engine.ActorComponent.SetIsReplicated
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               ShouldReplicate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::SetIsReplicated(bool ShouldReplicate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetIsReplicated");
		
		UActorComponent_SetIsReplicated_Params params {};
		params.ShouldReplicate = ShouldReplicate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757320
	 * 		Name   -> Function Engine.ActorComponent.SetComponentTickEnabled
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::SetComponentTickEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetComponentTickEnabled");
		
		UActorComponent_SetComponentTickEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757440
	 * 		Name   -> Function Engine.ActorComponent.SetActive
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewActive                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::SetActive(bool bNewActive, bool bReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.SetActive");
		
		UActorComponent_SetActive_Params params {};
		params.bNewActive = bNewActive;
		params.bReset = bReset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027575D0
	 * 		Name   -> Function Engine.ActorComponent.ReregisterComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UActorComponent::ReregisterComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ReregisterComponent");
		
		UActorComponent_ReregisterComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027575F0
	 * 		Name   -> Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteComponent");
		
		UActorComponent_RemoveTickPrerequisiteComponent_Params params {};
		params.PrerequisiteComponent = PrerequisiteComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757700
	 * 		Name   -> Function Engine.ActorComponent.RemoveTickPrerequisiteActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.RemoveTickPrerequisiteActor");
		
		UActorComponent_RemoveTickPrerequisiteActor_Params params {};
		params.PrerequisiteActor = PrerequisiteActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757810
	 * 		Name   -> Function Engine.ActorComponent.OnRep_IsActive
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UActorComponent::OnRep_IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.OnRep_IsActive");
		
		UActorComponent_OnRep_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757880
	 * 		Name   -> Function Engine.ActorComponent.K2_DestroyComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::K2_DestroyComponent(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.K2_DestroyComponent");
		
		UActorComponent_K2_DestroyComponent_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757950
	 * 		Name   -> Function Engine.ActorComponent.IsActive
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UActorComponent::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.IsActive");
		
		UActorComponent_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027579B0
	 * 		Name   -> Function Engine.ActorComponent.GetWorld
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UWorld* UActorComponent::GetWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetWorld");
		
		UActorComponent_GetWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027579E0
	 * 		Name   -> Function Engine.ActorComponent.GetOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* UActorComponent::GetOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.GetOwner");
		
		UActorComponent_GetOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710B30
	 * 		Name   -> Function Engine.ActorComponent.Deactivate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UActorComponent::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Deactivate");
		
		UActorComponent_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757A10
	 * 		Name   -> Function Engine.ActorComponent.ComponentHasTag
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UActorComponent::ComponentHasTag(const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.ComponentHasTag");
		
		UActorComponent_ComponentHasTag_Params params {};
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757B40
	 * 		Name   -> Function Engine.ActorComponent.BPTickComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::BPTickComponent(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.BPTickComponent");
		
		UActorComponent_BPTickComponent_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ActorComponent.BPOnComponentTick
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::BPOnComponentTick(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.BPOnComponentTick");
		
		UActorComponent_BPOnComponentTick_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ActorComponent.BPOnComponentDestroyed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UActorComponent::BPOnComponentDestroyed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.BPOnComponentDestroyed");
		
		UActorComponent_BPOnComponentDestroyed_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ActorComponent.BPOnComponentCreated
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UActorComponent::BPOnComponentCreated()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.BPOnComponentCreated");
		
		UActorComponent_BPOnComponentCreated_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757C20
	 * 		Name   -> Function Engine.ActorComponent.AddTickPrerequisiteComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UActorComponent*                             PrerequisiteComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteComponent");
		
		UActorComponent_AddTickPrerequisiteComponent_Params params {};
		params.PrerequisiteComponent = PrerequisiteComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757D40
	 * 		Name   -> Function Engine.ActorComponent.AddTickPrerequisiteActor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      PrerequisiteActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::AddTickPrerequisiteActor(class AActor* PrerequisiteActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddTickPrerequisiteActor");
		
		UActorComponent_AddTickPrerequisiteActor_Params params {};
		params.PrerequisiteActor = PrerequisiteActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ActorComponent.AddedAsPrimalItemAttachment
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UActorComponent::AddedAsPrimalItemAttachment()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.AddedAsPrimalItemAttachment");
		
		UActorComponent_AddedAsPrimalItemAttachment_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02757E60
	 * 		Name   -> Function Engine.ActorComponent.Activate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bReset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UActorComponent::Activate(bool bReset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ActorComponent.Activate");
		
		UActorComponent_Activate_Params params {};
		params.bReset = bReset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753A10
	 * 		Name   -> Function Engine.SceneComponent.ToggleVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::ToggleVisibility(bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ToggleVisibility");
		
		USceneComponent_ToggleVisibility_Params params {};
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753B00
	 * 		Name   -> Function Engine.SceneComponent.StopSound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  SoundToStop                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeOutTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::StopSound(class USoundBase* SoundToStop, float FadeOutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.StopSound");
		
		USceneComponent_StopSound_Params params {};
		params.SoundToStop = SoundToStop;
		params.FadeOutTime = FadeOutTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753C60
	 * 		Name   -> Function Engine.SceneComponent.SnapTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SnapTo(class USceneComponent* InParent, const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SnapTo");
		
		USceneComponent_SnapTo_Params params {};
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753DC0
	 * 		Name   -> Function Engine.SceneComponent.SetWorldTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetWorldTransform(const struct FTransform& NewTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldTransform");
		
		USceneComponent_SetWorldTransform_Params params {};
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02753F10
	 * 		Name   -> Function Engine.SceneComponent.SetWorldScale3D
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetWorldScale3D(const struct FVector& NewScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldScale3D");
		
		USceneComponent_SetWorldScale3D_Params params {};
		params.NewScale = NewScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754020
	 * 		Name   -> Function Engine.SceneComponent.SetWorldRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetWorldRotation(const struct FRotator& NewRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldRotation");
		
		USceneComponent_SetWorldRotation_Params params {};
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027541A0
	 * 		Name   -> Function Engine.SceneComponent.SetWorldLocationAndRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetWorldLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldLocationAndRotation");
		
		USceneComponent_SetWorldLocationAndRotation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027543D0
	 * 		Name   -> Function Engine.SceneComponent.SetWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetWorldLocation(const struct FVector& NewLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetWorldLocation");
		
		USceneComponent_SetWorldLocation_Params params {};
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754540
	 * 		Name   -> Function Engine.SceneComponent.SetVisibility
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewVisibility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetVisibility(bool bNewVisibility, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetVisibility");
		
		USceneComponent_SetVisibility_Params params {};
		params.bNewVisibility = bNewVisibility;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027546A0
	 * 		Name   -> Function Engine.SceneComponent.SetRelativeTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  NewTransform                                               (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetRelativeTransform(const struct FTransform& NewTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeTransform");
		
		USceneComponent_SetRelativeTransform_Params params {};
		params.NewTransform = NewTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027547F0
	 * 		Name   -> Function Engine.SceneComponent.SetRelativeScale3D
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewScale3D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetRelativeScale3D(const struct FVector& NewScale3D)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeScale3D");
		
		USceneComponent_SetRelativeScale3D_Params params {};
		params.NewScale3D = NewScale3D;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027548D0
	 * 		Name   -> Function Engine.SceneComponent.SetRelativeRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetRelativeRotation(const struct FRotator& NewRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeRotation");
		
		USceneComponent_SetRelativeRotation_Params params {};
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754A70
	 * 		Name   -> Function Engine.SceneComponent.SetRelativeLocationAndRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetRelativeLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeLocationAndRotation");
		
		USceneComponent_SetRelativeLocationAndRotation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754C90
	 * 		Name   -> Function Engine.SceneComponent.SetRelativeLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetRelativeLocation(const struct FVector& NewLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetRelativeLocation");
		
		USceneComponent_SetRelativeLocation_Params params {};
		params.NewLocation = NewLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754E30
	 * 		Name   -> Function Engine.SceneComponent.SetMobility
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EComponentMobility                                 NewMobility                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetMobility(EComponentMobility NewMobility)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetMobility");
		
		USceneComponent_SetMobility_Params params {};
		params.NewMobility = NewMobility;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02754F00
	 * 		Name   -> Function Engine.SceneComponent.SetHiddenInGame
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               NewHidden                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPropagateToChildren                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetHiddenInGame(bool NewHidden, bool bPropagateToChildren)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetHiddenInGame");
		
		USceneComponent_SetHiddenInGame_Params params {};
		params.NewHidden = NewHidden;
		params.bPropagateToChildren = bPropagateToChildren;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755060
	 * 		Name   -> Function Engine.SceneComponent.SetAbsolute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewAbsoluteLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewAbsoluteRotation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewAbsoluteScale                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.SetAbsolute");
		
		USceneComponent_SetAbsolute_Params params {};
		params.bNewAbsoluteLocation = bNewAbsoluteLocation;
		params.bNewAbsoluteRotation = bNewAbsoluteRotation;
		params.bNewAbsoluteScale = bNewAbsoluteScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755280
	 * 		Name   -> Function Engine.SceneComponent.ResetRelativeTransform
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USceneComponent::ResetRelativeTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.ResetRelativeTransform");
		
		USceneComponent_ResetRelativeTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.SceneComponent.PhysicsVolumeChanged__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APhysicsVolume*                              NewVolume                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::PhysicsVolumeChanged__DelegateSignature(class APhysicsVolume* NewVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.PhysicsVolumeChanged__DelegateSignature");
		
		USceneComponent_PhysicsVolumeChanged__DelegateSignature_Params params {};
		params.NewVolume = NewVolume;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027552A0
	 * 		Name   -> Function Engine.SceneComponent.OnRep_Visibility
	 * 		Flags  -> (Final, Native, Private)
	 * Parameters:
	 * 		bool                                               OldValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::OnRep_Visibility(bool OldValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Visibility");
		
		USceneComponent_OnRep_Visibility_Params params {};
		params.OldValue = OldValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027553A0
	 * 		Name   -> Function Engine.SceneComponent.OnRep_Transform
	 * 		Flags  -> (Final, Native, Private)
	 */
	void USceneComponent::OnRep_Transform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.OnRep_Transform");
		
		USceneComponent_OnRep_Transform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027553C0
	 * 		Name   -> Function Engine.SceneComponent.K2_GetComponentToWorld
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FTransform USceneComponent::K2_GetComponentToWorld()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentToWorld");
		
		USceneComponent_K2_GetComponentToWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755400
	 * 		Name   -> Function Engine.SceneComponent.K2_GetComponentScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::K2_GetComponentScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentScale");
		
		USceneComponent_K2_GetComponentScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755450
	 * 		Name   -> Function Engine.SceneComponent.K2_GetComponentRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator USceneComponent::K2_GetComponentRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentRotation");
		
		USceneComponent_K2_GetComponentRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027554A0
	 * 		Name   -> Function Engine.SceneComponent.K2_GetComponentLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::K2_GetComponentLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_GetComponentLocation");
		
		USceneComponent_K2_GetComponentLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755520
	 * 		Name   -> Function Engine.SceneComponent.K2_AttachTo
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             InParent                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EAttachLocation                                    AttachType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bWeldSimulatedBodies                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::K2_AttachTo(class USceneComponent* InParent, const class FName& InSocketName, EAttachLocation AttachType, bool bWeldSimulatedBodies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.K2_AttachTo");
		
		USceneComponent_K2_AttachTo_Params params {};
		params.InParent = InParent;
		params.InSocketName = InSocketName;
		params.AttachType = AttachType;
		params.bWeldSimulatedBodies = bWeldSimulatedBodies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755780
	 * 		Name   -> Function Engine.SceneComponent.IsVisible
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USceneComponent::IsVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsVisible");
		
		USceneComponent_IsVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027557F0
	 * 		Name   -> Function Engine.SceneComponent.IsSimulatingPhysics
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USceneComponent::IsSimulatingPhysics(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsSimulatingPhysics");
		
		USceneComponent_IsSimulatingPhysics_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F2F5A0
	 * 		Name   -> Function Engine.SceneComponent.IsAnySimulatingPhysics
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USceneComponent::IsAnySimulatingPhysics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.IsAnySimulatingPhysics");
		
		USceneComponent_IsAnySimulatingPhysics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027554A0
	 * 		Name   -> Function Engine.SceneComponent.GetWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector USceneComponent::GetWorldLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetWorldLocation");
		
		USceneComponent_GetWorldLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027558D0
	 * 		Name   -> Function Engine.SceneComponent.GetUpVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::GetUpVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetUpVector");
		
		USceneComponent_GetUpVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755910
	 * 		Name   -> Function Engine.SceneComponent.GetSocketTransform
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERelativeTransformSpace                            TransformSpace                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform USceneComponent::GetSocketTransform(const class FName& InSocketName, ERelativeTransformSpace TransformSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketTransform");
		
		USceneComponent_GetSocketTransform_Params params {};
		params.InSocketName = InSocketName;
		params.TransformSpace = TransformSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755AA0
	 * 		Name   -> Function Engine.SceneComponent.GetSocketRotation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator USceneComponent::GetSocketRotation(const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketRotation");
		
		USceneComponent_GetSocketRotation_Params params {};
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755BF0
	 * 		Name   -> Function Engine.SceneComponent.GetSocketQuaternion
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FQuat USceneComponent::GetSocketQuaternion(const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketQuaternion");
		
		USceneComponent_GetSocketQuaternion_Params params {};
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755D20
	 * 		Name   -> Function Engine.SceneComponent.GetSocketLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USceneComponent::GetSocketLocation(const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetSocketLocation");
		
		USceneComponent_GetSocketLocation_Params params {};
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755E10
	 * 		Name   -> Function Engine.SceneComponent.GetRightVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::GetRightVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRightVector");
		
		USceneComponent_GetRightVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755E50
	 * 		Name   -> Function Engine.SceneComponent.GetRelativeTransform
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FTransform USceneComponent::GetRelativeTransform()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetRelativeTransform");
		
		USceneComponent_GetRelativeTransform_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755F00
	 * 		Name   -> Function Engine.SceneComponent.GetPhysicsVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APhysicsVolume* USceneComponent::GetPhysicsVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetPhysicsVolume");
		
		USceneComponent_GetPhysicsVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755F30
	 * 		Name   -> Function Engine.SceneComponent.GetParentComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class USceneComponent*>                     Parents                                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void USceneComponent::GetParentComponents(TArray<class USceneComponent*>* Parents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetParentComponents");
		
		USceneComponent_GetParentComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Parents != nullptr)
			*Parents = params.Parents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02755FF0
	 * 		Name   -> Function Engine.SceneComponent.GetNumChildrenComponents
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t USceneComponent::GetNumChildrenComponents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetNumChildrenComponents");
		
		USceneComponent_GetNumChildrenComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756010
	 * 		Name   -> Function Engine.SceneComponent.GetForwardVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::GetForwardVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetForwardVector");
		
		USceneComponent_GetForwardVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756050
	 * 		Name   -> Function Engine.SceneComponent.GetComponentVelocity
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USceneComponent::GetComponentVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetComponentVelocity");
		
		USceneComponent_GetComponentVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756090
	 * 		Name   -> Function Engine.SceneComponent.GetChildrenComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bIncludeAllDescendants                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class USceneComponent*>                     Children                                                   (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void USceneComponent::GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>* Children)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildrenComponents");
		
		USceneComponent_GetChildrenComponents_Params params {};
		params.bIncludeAllDescendants = bIncludeAllDescendants;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Children != nullptr)
			*Children = params.Children;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027561E0
	 * 		Name   -> Function Engine.SceneComponent.GetChildComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ChildIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class USceneComponent* USceneComponent::GetChildComponent(int32_t ChildIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetChildComponent");
		
		USceneComponent_GetChildComponent_Params params {};
		params.ChildIndex = ChildIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027562E0
	 * 		Name   -> Function Engine.SceneComponent.GetAttachParent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USceneComponent* USceneComponent::GetAttachParent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAttachParent");
		
		USceneComponent_GetAttachParent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756300
	 * 		Name   -> Function Engine.SceneComponent.GetAllSocketNames
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<class FName> USceneComponent::GetAllSocketNames()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.GetAllSocketNames");
		
		USceneComponent_GetAllSocketNames_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756380
	 * 		Name   -> Function Engine.SceneComponent.DoesSocketExist
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USceneComponent::DoesSocketExist(const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DoesSocketExist");
		
		USceneComponent_DoesSocketExist_Params params {};
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756460
	 * 		Name   -> Function Engine.SceneComponent.DetachFromParent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bMaintainWorldPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::DetachFromParent(bool bMaintainWorldPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.DetachFromParent");
		
		USceneComponent_DetachFromParent_Params params {};
		params.bMaintainWorldPosition = bMaintainWorldPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756540
	 * 		Name   -> Function Engine.SceneComponent.BP_GetCollisionEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	ECollisionEnabled USceneComponent::BP_GetCollisionEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.BP_GetCollisionEnabled");
		
		USceneComponent_BP_GetCollisionEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756570
	 * 		Name   -> Function Engine.SceneComponent.AddWorldTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddWorldTransform(const struct FTransform& DeltaTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddWorldTransform");
		
		USceneComponent_AddWorldTransform_Params params {};
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027566B0
	 * 		Name   -> Function Engine.SceneComponent.AddWorldRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddWorldRotation(const struct FRotator& DeltaRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddWorldRotation");
		
		USceneComponent_AddWorldRotation_Params params {};
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027568A0
	 * 		Name   -> Function Engine.SceneComponent.AddWorldOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddWorldOffset(const struct FVector& DeltaLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddWorldOffset");
		
		USceneComponent_AddWorldOffset_Params params {};
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756A40
	 * 		Name   -> Function Engine.SceneComponent.AddRelativeRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddRelativeRotation(const struct FRotator& DeltaRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddRelativeRotation");
		
		USceneComponent_AddRelativeRotation_Params params {};
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756C10
	 * 		Name   -> Function Engine.SceneComponent.AddRelativeLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddRelativeLocation(const struct FVector& DeltaLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddRelativeLocation");
		
		USceneComponent_AddRelativeLocation_Params params {};
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756DE0
	 * 		Name   -> Function Engine.SceneComponent.AddLocalTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  DeltaTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddLocalTransform(const struct FTransform& DeltaTransform, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddLocalTransform");
		
		USceneComponent_AddLocalTransform_Params params {};
		params.DeltaTransform = DeltaTransform;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02756F30
	 * 		Name   -> Function Engine.SceneComponent.AddLocalRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    DeltaRotation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddLocalRotation(const struct FRotator& DeltaRotation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddLocalRotation");
		
		USceneComponent_AddLocalRotation_Params params {};
		params.DeltaRotation = DeltaRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027570A0
	 * 		Name   -> Function Engine.SceneComponent.AddLocalOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     DeltaLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneComponent::AddLocalOffset(const struct FVector& DeltaLocation, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneComponent.AddLocalOffset");
		
		USceneComponent_AddLocalOffset_Params params {};
		params.DeltaLocation = DeltaLocation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023217E0
	 * 		Name   -> Function Engine.PrimitiveComponent.WasRecentlyVisible
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UPrimitiveComponent::WasRecentlyVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WasRecentlyVisible");
		
		UPrimitiveComponent_WasRecentlyVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732F30
	 * 		Name   -> Function Engine.PrimitiveComponent.WakeRigidBody
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::WakeRigidBody(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeRigidBody");
		
		UPrimitiveComponent_WakeRigidBody_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733010
	 * 		Name   -> Function Engine.PrimitiveComponent.WakeAllRigidBodies
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UPrimitiveComponent::WakeAllRigidBodies()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.WakeAllRigidBodies");
		
		UPrimitiveComponent_WakeAllRigidBodies_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733030
	 * 		Name   -> Function Engine.PrimitiveComponent.SetTranslucentSortPriority
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewTranslucentSortPriority                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetTranslucentSortPriority(int32_t NewTranslucentSortPriority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetTranslucentSortPriority");
		
		UPrimitiveComponent_SetTranslucentSortPriority_Params params {};
		params.NewTranslucentSortPriority = NewTranslucentSortPriority;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733140
	 * 		Name   -> Function Engine.PrimitiveComponent.SetSimulatePhysics
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSimulate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetSimulatePhysics(bool bSimulate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetSimulatePhysics");
		
		UPrimitiveComponent_SetSimulatePhysics_Params params {};
		params.bSimulate = bSimulate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733220
	 * 		Name   -> Function Engine.PrimitiveComponent.SetRenderCustomDepth
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bValue                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetRenderCustomDepth(bool bValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetRenderCustomDepth");
		
		UPrimitiveComponent_SetRenderCustomDepth_Params params {};
		params.bValue = bValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027332F0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetPhysMaterialOverride
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPhysicalMaterial*                           NewPhysMaterial                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysMaterialOverride");
		
		UPrimitiveComponent_SetPhysMaterialOverride_Params params {};
		params.NewPhysMaterial = NewPhysMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027333C0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewMaxAngVel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetPhysicsMaxAngularVelocity(float NewMaxAngVel, bool bAddToCurrent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity");
		
		UPrimitiveComponent_SetPhysicsMaxAngularVelocity_Params params {};
		params.NewMaxAngVel = NewMaxAngVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027335C0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity");
		
		UPrimitiveComponent_SetPhysicsLinearVelocity_Params params {};
		params.NewVel = NewVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027337D0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewAngVel                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetPhysicsAngularVelocity(const struct FVector& NewAngVel, bool bAddToCurrent, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity");
		
		UPrimitiveComponent_SetPhysicsAngularVelocity_Params params {};
		params.NewAngVel = NewAngVel;
		params.bAddToCurrent = bAddToCurrent;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027339E0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetOwnerNoSee
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewOwnerNoSee                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetOwnerNoSee(bool bNewOwnerNoSee)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOwnerNoSee");
		
		UPrimitiveComponent_SetOwnerNoSee_Params params {};
		params.bNewOwnerNoSee = bNewOwnerNoSee;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733AB0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetOnlyOwnerSee
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewOnlyOwnerSee                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetOnlyOwnerSee(bool bNewOnlyOwnerSee)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetOnlyOwnerSee");
		
		UPrimitiveComponent_SetOnlyOwnerSee_Params params {};
		params.bNewOnlyOwnerSee = bNewOnlyOwnerSee;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733B80
	 * 		Name   -> Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewNotifyRigidBodyCollision                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision");
		
		UPrimitiveComponent_SetNotifyRigidBodyCollision_Params params {};
		params.bNewNotifyRigidBodyCollision = bNewNotifyRigidBodyCollision;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733CB0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetMaterial
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetMaterial(int32_t ElementIndex, class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetMaterial");
		
		UPrimitiveComponent_SetMaterial_Params params {};
		params.ElementIndex = ElementIndex;
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733E10
	 * 		Name   -> Function Engine.PrimitiveComponent.SetLinearDamping
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetLinearDamping(float InDamping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetLinearDamping");
		
		UPrimitiveComponent_SetLinearDamping_Params params {};
		params.InDamping = InDamping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02733F30
	 * 		Name   -> Function Engine.PrimitiveComponent.SetEnableGravity
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bGravityEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetEnableGravity(bool bGravityEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetEnableGravity");
		
		UPrimitiveComponent_SetEnableGravity_Params params {};
		params.bGravityEnabled = bGravityEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734050
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCustomDepthStencilValue(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCustomDepthStencilValue");
		
		UPrimitiveComponent_SetCustomDepthStencilValue_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734120
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECollisionChannel                                  Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionResponse                                 NewResponse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCollisionResponseToChannel(ECollisionChannel Channel, ECollisionResponse NewResponse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToChannel");
		
		UPrimitiveComponent_SetCollisionResponseToChannel_Params params {};
		params.Channel = Channel;
		params.NewResponse = NewResponse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734290
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECollisionResponse                                 NewResponse                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCollisionResponseToAllChannels(ECollisionResponse NewResponse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels");
		
		UPrimitiveComponent_SetCollisionResponseToAllChannels_Params params {};
		params.NewResponse = NewResponse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734360
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionResponseSet
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCollisionResponseSet                       Responses                                                  (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UPrimitiveComponent::SetCollisionResponseSet(const struct FCollisionResponseSet& Responses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionResponseSet");
		
		UPrimitiveComponent_SetCollisionResponseSet_Params params {};
		params.Responses = Responses;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734420
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionProfileName
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InCollisionProfileName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCollisionProfileName(const class FName& InCollisionProfileName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionProfileName");
		
		UPrimitiveComponent_SetCollisionProfileName_Params params {};
		params.InCollisionProfileName = InCollisionProfileName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027344F0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionObjectType
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECollisionChannel                                  Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCollisionObjectType(ECollisionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionObjectType");
		
		UPrimitiveComponent_SetCollisionObjectType_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027345C0
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCollisionEnabled
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ECollisionEnabled                                  NewType                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCollisionEnabled(ECollisionEnabled NewType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCollisionEnabled");
		
		UPrimitiveComponent_SetCollisionEnabled_Params params {};
		params.NewType = NewType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734690
	 * 		Name   -> Function Engine.PrimitiveComponent.SetCastShadow
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               NewCastShadow                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetCastShadow(bool NewCastShadow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetCastShadow");
		
		UPrimitiveComponent_SetCastShadow_Params params {};
		params.NewCastShadow = NewCastShadow;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734760
	 * 		Name   -> Function Engine.PrimitiveComponent.SetAngularDamping
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetAngularDamping(float InDamping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAngularDamping");
		
		UPrimitiveComponent_SetAngularDamping_Params params {};
		params.InDamping = InDamping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734880
	 * 		Name   -> Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAddToCurrent                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::SetAllPhysicsLinearVelocity(const struct FVector& NewVel, bool bAddToCurrent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity");
		
		UPrimitiveComponent_SetAllPhysicsLinearVelocity_Params params {};
		params.NewVel = NewVel;
		params.bAddToCurrent = bAddToCurrent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734A00
	 * 		Name   -> Function Engine.PrimitiveComponent.PutRigidBodyToSleep
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::PutRigidBodyToSleep(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.PutRigidBodyToSleep");
		
		UPrimitiveComponent_PutRigidBodyToSleep_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734AE0
	 * 		Name   -> Function Engine.PrimitiveComponent.K2_LineTraceComponent
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     TraceStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TraceEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bShowTrace                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitNormal                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UPrimitiveComponent::K2_LineTraceComponent(const struct FVector& TraceStart, const struct FVector& TraceEnd, bool bTraceComplex, bool bShowTrace, struct FVector* HitLocation, struct FVector* HitNormal, class FName* BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.K2_LineTraceComponent");
		
		UPrimitiveComponent_K2_LineTraceComponent_Params params {};
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.bTraceComplex = bTraceComplex;
		params.bShowTrace = bShowTrace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitLocation != nullptr)
			*HitLocation = params.HitLocation;
		if (HitNormal != nullptr)
			*HitNormal = params.HitNormal;
		if (BoneName != nullptr)
			*BoneName = params.BoneName;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734EC0
	 * 		Name   -> Function Engine.PrimitiveComponent.IsGravityEnabled
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPrimitiveComponent::IsGravityEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IsGravityEnabled");
		
		UPrimitiveComponent_IsGravityEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02734F40
	 * 		Name   -> Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bShouldIgnore                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.IgnoreActorWhenMoving");
		
		UPrimitiveComponent_IgnoreActorWhenMoving_Params params {};
		params.Actor = Actor;
		params.bShouldIgnore = bShouldIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027350A0
	 * 		Name   -> Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FWalkableSlopeOverride UPrimitiveComponent::GetWalkableSlopeOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetWalkableSlopeOverride");
		
		UPrimitiveComponent_GetWalkableSlopeOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027350E0
	 * 		Name   -> Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UPrimitiveComponent::GetPhysicsLinearVelocity(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity");
		
		UPrimitiveComponent_GetPhysicsLinearVelocity_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735200
	 * 		Name   -> Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UPrimitiveComponent::GetPhysicsAngularVelocity(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity");
		
		UPrimitiveComponent_GetPhysicsAngularVelocity_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735320
	 * 		Name   -> Function Engine.PrimitiveComponent.GetOverlappingComponents
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class UPrimitiveComponent*>                 InOverlappingComponents                                    (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	void UPrimitiveComponent::GetOverlappingComponents(TArray<class UPrimitiveComponent*>* InOverlappingComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingComponents");
		
		UPrimitiveComponent_GetOverlappingComponents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InOverlappingComponents != nullptr)
			*InOverlappingComponents = params.InOverlappingComponents;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027353E0
	 * 		Name   -> Function Engine.PrimitiveComponent.GetOverlappingActors
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<class AActor*>                              OverlappingActors                                          (Parm, OutParm, ZeroConstructor)
	 * 		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::GetOverlappingActors(TArray<class AActor*>* OverlappingActors, class UClass* ClassFilter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlappingActors");
		
		UPrimitiveComponent_GetOverlappingActors_Params params {};
		params.ClassFilter = ClassFilter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OverlappingActors != nullptr)
			*OverlappingActors = params.OverlappingActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735530
	 * 		Name   -> Function Engine.PrimitiveComponent.GetOverlapInfos
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	TArray<struct FOverlapInfo> UPrimitiveComponent::GetOverlapInfos()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetOverlapInfos");
		
		UPrimitiveComponent_GetOverlapInfos_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735560
	 * 		Name   -> Function Engine.PrimitiveComponent.GetNumMaterials
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UPrimitiveComponent::GetNumMaterials()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetNumMaterials");
		
		UPrimitiveComponent_GetNumMaterials_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735590
	 * 		Name   -> Function Engine.PrimitiveComponent.GetMoveIgnoreActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<TWeakObjectPtr<class AActor>> UPrimitiveComponent::GetMoveIgnoreActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMoveIgnoreActors");
		
		UPrimitiveComponent_GetMoveIgnoreActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027355F0
	 * 		Name   -> Function Engine.PrimitiveComponent.GetMaterial
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInterface* UPrimitiveComponent::GetMaterial(int32_t ElementIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMaterial");
		
		UPrimitiveComponent_GetMaterial_Params params {};
		params.ElementIndex = ElementIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325120
	 * 		Name   -> Function Engine.PrimitiveComponent.GetMass
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UPrimitiveComponent::GetMass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetMass");
		
		UPrimitiveComponent_GetMass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027356D0
	 * 		Name   -> Function Engine.PrimitiveComponent.GetLinearDamping
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UPrimitiveComponent::GetLinearDamping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetLinearDamping");
		
		UPrimitiveComponent_GetLinearDamping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735750
	 * 		Name   -> Function Engine.PrimitiveComponent.GetCollisionResponseSet
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FCollisionResponseSet                       OutResponses                                               (Parm, OutParm)
	 */
	void UPrimitiveComponent::GetCollisionResponseSet(struct FCollisionResponseSet* OutResponses)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionResponseSet");
		
		UPrimitiveComponent_GetCollisionResponseSet_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResponses != nullptr)
			*OutResponses = params.OutResponses;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735860
	 * 		Name   -> Function Engine.PrimitiveComponent.GetCollisionProfileName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName UPrimitiveComponent::GetCollisionProfileName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetCollisionProfileName");
		
		UPrimitiveComponent_GetCollisionProfileName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735880
	 * 		Name   -> Function Engine.PrimitiveComponent.GetAngularDamping
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UPrimitiveComponent::GetAngularDamping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.GetAngularDamping");
		
		UPrimitiveComponent_GetAngularDamping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735900
	 * 		Name   -> Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          SourceMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateDynamicMaterialInstance(int32_t ElementIndex, class UMaterialInterface* SourceMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance");
		
		UPrimitiveComponent_CreateDynamicMaterialInstance_Params params {};
		params.ElementIndex = ElementIndex;
		params.SourceMaterial = SourceMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735A60
	 * 		Name   -> Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamicFromMaterial(int32_t ElementIndex, class UMaterialInterface* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial");
		
		UPrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial_Params params {};
		params.ElementIndex = ElementIndex;
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735C20
	 * 		Name   -> Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            ElementIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* UPrimitiveComponent::CreateAndSetMaterialInstanceDynamic(int32_t ElementIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic");
		
		UPrimitiveComponent_CreateAndSetMaterialInstanceDynamic_Params params {};
		params.ElementIndex = ElementIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentOnReleasedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentOnReleasedSignature__DelegateSignature(class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentOnReleasedSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentOnReleasedSignature__DelegateSignature_Params params {};
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentOnInputTouchEndSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentOnInputTouchEndSignature__DelegateSignature(ETouchIndex FingerIndex, class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentOnInputTouchEndSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentOnInputTouchEndSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentOnInputTouchBeginSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentOnInputTouchBeginSignature__DelegateSignature(ETouchIndex FingerIndex, class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentOnInputTouchBeginSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentOnInputTouchBeginSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentOnClickedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentOnClickedSignature__DelegateSignature(class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentOnClickedSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentOnClickedSignature__DelegateSignature_Params params {};
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentHitSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NormalImpulse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UPrimitiveComponent::ComponentHitSignature__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentHitSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentHitSignature__DelegateSignature_Params params {};
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.NormalImpulse = NormalImpulse;
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentEndTouchOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentEndTouchOverSignature__DelegateSignature(ETouchIndex FingerIndex, class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentEndTouchOverSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentEndTouchOverSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentEndOverlapSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentEndOverlapSignature__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentEndOverlapSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentEndOverlapSignature__DelegateSignature_Params params {};
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentEndCursorOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentEndCursorOverSignature__DelegateSignature(class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentEndCursorOverSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentEndCursorOverSignature__DelegateSignature_Params params {};
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentBeginTouchOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentBeginTouchOverSignature__DelegateSignature(ETouchIndex FingerIndex, class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentBeginTouchOverSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentBeginTouchOverSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentBeginOverlapSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		class AActor*                                      OtherActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UPrimitiveComponent::ComponentBeginOverlapSignature__DelegateSignature(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentBeginOverlapSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentBeginOverlapSignature__DelegateSignature_Params params {};
		params.OtherActor = OtherActor;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PrimitiveComponent.ComponentBeginCursorOverSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         TouchedComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::ComponentBeginCursorOverSignature__DelegateSignature(class UPrimitiveComponent* TouchedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ComponentBeginCursorOverSignature__DelegateSignature");
		
		UPrimitiveComponent_ComponentBeginCursorOverSignature__DelegateSignature_Params params {};
		params.TouchedComponent = TouchedComponent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735D00
	 * 		Name   -> Function Engine.PrimitiveComponent.ClearMoveIgnoreActors
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UPrimitiveComponent::ClearMoveIgnoreActors()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.ClearMoveIgnoreActors");
		
		UPrimitiveComponent_ClearMoveIgnoreActors_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735D80
	 * 		Name   -> Function Engine.PrimitiveComponent.AddTorque
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Torque                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddTorque(const struct FVector& Torque, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddTorque");
		
		UPrimitiveComponent_AddTorque_Params params {};
		params.Torque = Torque;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02735F60
	 * 		Name   -> Function Engine.PrimitiveComponent.AddRadialImpulse
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bVelChange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff, bool bVelChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialImpulse");
		
		UPrimitiveComponent_AddRadialImpulse_Params params {};
		params.Origin = Origin;
		params.Radius = Radius;
		params.Strength = Strength;
		params.Falloff = Falloff;
		params.bVelChange = bVelChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736250
	 * 		Name   -> Function Engine.PrimitiveComponent.AddRadialForce
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Strength                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERadialImpulseFalloff                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddRadialForce(const struct FVector& Origin, float Radius, float Strength, ERadialImpulseFalloff Falloff)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddRadialForce");
		
		UPrimitiveComponent_AddRadialForce_Params params {};
		params.Origin = Origin;
		params.Radius = Radius;
		params.Strength = Strength;
		params.Falloff = Falloff;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027364D0
	 * 		Name   -> Function Engine.PrimitiveComponent.AddImpulseAtLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddImpulseAtLocation(const struct FVector& Impulse, const struct FVector& Location, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulseAtLocation");
		
		UPrimitiveComponent_AddImpulseAtLocation_Params params {};
		params.Impulse = Impulse;
		params.Location = Location;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027366E0
	 * 		Name   -> Function Engine.PrimitiveComponent.AddImpulse
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bVelChange                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddImpulse(const struct FVector& Impulse, const class FName& BoneName, bool bVelChange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddImpulse");
		
		UPrimitiveComponent_AddImpulse_Params params {};
		params.Impulse = Impulse;
		params.BoneName = BoneName;
		params.bVelChange = bVelChange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027368C0
	 * 		Name   -> Function Engine.PrimitiveComponent.AddForceAtLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddForceAtLocation(const struct FVector& Force, const struct FVector& Location, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForceAtLocation");
		
		UPrimitiveComponent_AddForceAtLocation_Params params {};
		params.Force = Force;
		params.Location = Location;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736AD0
	 * 		Name   -> Function Engine.PrimitiveComponent.AddForce
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPrimitiveComponent::AddForce(const struct FVector& Force, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PrimitiveComponent.AddForce");
		
		UPrimitiveComponent_AddForce_Params params {};
		params.Force = Force;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPrimitiveComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPrimitiveComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PrimitiveComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731E90
	 * 		Name   -> Function Engine.SkinnedMeshComponent.UnHideBoneByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::UnHideBoneByName(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.UnHideBoneByName");
		
		USkinnedMeshComponent_UnHideBoneByName_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731F70
	 * 		Name   -> Function Engine.SkinnedMeshComponent.TransformToBoneSpace
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OutPosition                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::TransformToBoneSpace(const class FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformToBoneSpace");
		
		USkinnedMeshComponent_TransformToBoneSpace_Params params {};
		params.BoneName = BoneName;
		params.InPosition = InPosition;
		params.InRotation = InRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPosition != nullptr)
			*OutPosition = params.OutPosition;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732270
	 * 		Name   -> Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OutPosition                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    OutRotation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::TransformFromBoneSpace(const class FName& BoneName, const struct FVector& InPosition, const struct FRotator& InRotation, struct FVector* OutPosition, struct FRotator* OutRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.TransformFromBoneSpace");
		
		USkinnedMeshComponent_TransformFromBoneSpace_Params params {};
		params.BoneName = BoneName;
		params.InPosition = InPosition;
		params.InRotation = InRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutPosition != nullptr)
			*OutPosition = params.OutPosition;
		if (OutRotation != nullptr)
			*OutRotation = params.OutRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732570
	 * 		Name   -> Function Engine.SkinnedMeshComponent.SetSkeletalMesh
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMesh*                               NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::SetSkeletalMesh(class USkeletalMesh* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetSkeletalMesh");
		
		USkinnedMeshComponent_SetSkeletalMesh_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732640
	 * 		Name   -> Function Engine.SkinnedMeshComponent.SetPhysicsAsset
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPhysicsAsset*                               NewPhysicsAsset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceReinit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReinit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetPhysicsAsset");
		
		USkinnedMeshComponent_SetPhysicsAsset_Params params {};
		params.NewPhysicsAsset = NewPhysicsAsset;
		params.bForceReinit = bForceReinit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027327A0
	 * 		Name   -> Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USkinnedMeshComponent*                       NewMasterBoneComponent                                     (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::SetMasterPoseComponent(class USkinnedMeshComponent* NewMasterBoneComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.SetMasterPoseComponent");
		
		USkinnedMeshComponent_SetMasterPoseComponent_Params params {};
		params.NewMasterBoneComponent = NewMasterBoneComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732870
	 * 		Name   -> Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USkinnedMeshComponent::IsBoneHiddenByName(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.IsBoneHiddenByName");
		
		USkinnedMeshComponent_IsBoneHiddenByName_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732960
	 * 		Name   -> Function Engine.SkinnedMeshComponent.HideBoneByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EPhysBodyOp                                        PhysBodyOption                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkinnedMeshComponent::HideBoneByName(const class FName& BoneName, EPhysBodyOp PhysBodyOption)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.HideBoneByName");
		
		USkinnedMeshComponent_HideBoneByName_Params params {};
		params.BoneName = BoneName;
		params.PhysBodyOption = PhysBodyOption;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732AD0
	 * 		Name   -> Function Engine.SkinnedMeshComponent.GetSocketBoneName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InSocketName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName USkinnedMeshComponent::GetSocketBoneName(const class FName& InSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetSocketBoneName");
		
		USkinnedMeshComponent_GetSocketBoneName_Params params {};
		params.InSocketName = InSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732BE0
	 * 		Name   -> Function Engine.SkinnedMeshComponent.GetParentBone
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName USkinnedMeshComponent::GetParentBone(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetParentBone");
		
		USkinnedMeshComponent_GetParentBone_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732CF0
	 * 		Name   -> Function Engine.SkinnedMeshComponent.GetNumBones
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t USkinnedMeshComponent::GetNumBones()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetNumBones");
		
		USkinnedMeshComponent_GetNumBones_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732D30
	 * 		Name   -> Function Engine.SkinnedMeshComponent.GetBoneName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            BoneIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName USkinnedMeshComponent::GetBoneName(int32_t BoneIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneName");
		
		USkinnedMeshComponent_GetBoneName_Params params {};
		params.BoneIndex = BoneIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02732E50
	 * 		Name   -> Function Engine.SkinnedMeshComponent.GetBoneIndex
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t USkinnedMeshComponent::GetBoneIndex(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkinnedMeshComponent.GetBoneIndex");
		
		USkinnedMeshComponent_GetBoneIndex_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkinnedMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkinnedMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkinnedMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D430
	 * 		Name   -> Function Engine.AnimInstance.UnlockAIResources
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bUnlockMovement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               UnlockAILogic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.UnlockAIResources");
		
		UAnimInstance_UnlockAIResources_Params params {};
		params.bUnlockMovement = bUnlockMovement;
		params.UnlockAILogic = UnlockAILogic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D570
	 * 		Name   -> Function Engine.AnimInstance.TryGetPawnOwner
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* UAnimInstance::TryGetPawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.TryGetPawnOwner");
		
		UAnimInstance_TryGetPawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D5E0
	 * 		Name   -> Function Engine.AnimInstance.StopSlotAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InBlendOutTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::StopSlotAnimation(float InBlendOutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.StopSlotAnimation");
		
		UAnimInstance_StopSlotAnimation_Params params {};
		params.InBlendOutTime = InBlendOutTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D6B0
	 * 		Name   -> Function Engine.AnimInstance.SetMorphTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::SetMorphTarget(const class FName& MorphTargetName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.SetMorphTarget");
		
		UAnimInstance_SetMorphTarget_Params params {};
		params.MorphTargetName = MorphTargetName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D810
	 * 		Name   -> Function Engine.AnimInstance.PlaySlotAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Asset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::PlaySlotAnimation(class UAnimSequenceBase* Asset, const class FName& SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.PlaySlotAnimation");
		
		UAnimInstance_PlaySlotAnimation_Params params {};
		params.Asset = Asset;
		params.SlotNodeName = SlotNodeName;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.InPlayRate = InPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.OnMontageEndedMCDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::OnMontageEndedMCDelegate__DelegateSignature(class UAnimMontage* Montage, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.OnMontageEndedMCDelegate__DelegateSignature");
		
		UAnimInstance_OnMontageEndedMCDelegate__DelegateSignature_Params params {};
		params.Montage = Montage;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.OnMontageBlendingOutStartedMCDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bInterrupted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::OnMontageBlendingOutStartedMCDelegate__DelegateSignature(class UAnimMontage* Montage, bool bInterrupted)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.OnMontageBlendingOutStartedMCDelegate__DelegateSignature");
		
		UAnimInstance_OnMontageBlendingOutStartedMCDelegate__DelegateSignature_Params params {};
		params.Montage = Montage;
		params.bInterrupted = bInterrupted;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232DB20
	 * 		Name   -> Function Engine.AnimInstance.Montage_Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InBlendOutTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_Stop(float InBlendOutTime, class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Stop");
		
		UAnimInstance_Montage_Stop_Params params {};
		params.InBlendOutTime = InBlendOutTime;
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232DC70
	 * 		Name   -> Function Engine.AnimInstance.Montage_SetPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_SetPosition(class UAnimMontage* Montage, float NewPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPosition");
		
		UAnimInstance_Montage_SetPosition_Params params {};
		params.Montage = Montage;
		params.NewPosition = NewPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232DDD0
	 * 		Name   -> Function Engine.AnimInstance.Montage_SetPlayRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NewPlayRate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_SetPlayRate(class UAnimMontage* Montage, float NewPlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetPlayRate");
		
		UAnimInstance_Montage_SetPlayRate_Params params {};
		params.Montage = Montage;
		params.NewPlayRate = NewPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232DF30
	 * 		Name   -> Function Engine.AnimInstance.Montage_SetNextSection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SectionNameToChange                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        NextSection                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_SetNextSection(const class FName& SectionNameToChange, const class FName& NextSection, class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_SetNextSection");
		
		UAnimInstance_Montage_SetNextSection_Params params {};
		params.SectionNameToChange = SectionNameToChange;
		params.NextSection = NextSection;
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232E110
	 * 		Name   -> Function Engine.AnimInstance.Montage_Play_WithBlending
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                MontageToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPauseOnFinish                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::Montage_Play_WithBlending(class UAnimMontage* MontageToPlay, float BlendInTime, float BlendOutTime, float InPlayRate, bool bPauseOnFinish)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play_WithBlending");
		
		UAnimInstance_Montage_Play_WithBlending_Params params {};
		params.MontageToPlay = MontageToPlay;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.InPlayRate = InPlayRate;
		params.bPauseOnFinish = bPauseOnFinish;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232E420
	 * 		Name   -> Function Engine.AnimInstance.Montage_Play
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                MontageToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPauseOnFinish                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, bool bPauseOnFinish)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_Play");
		
		UAnimInstance_Montage_Play_Params params {};
		params.MontageToPlay = MontageToPlay;
		params.InPlayRate = InPlayRate;
		params.bPauseOnFinish = bPauseOnFinish;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232E640
	 * 		Name   -> Function Engine.AnimInstance.Montage_JumpToSectionsEnd
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SectionName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_JumpToSectionsEnd(const class FName& SectionName, class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSectionsEnd");
		
		UAnimInstance_Montage_JumpToSectionsEnd_Params params {};
		params.SectionName = SectionName;
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232E790
	 * 		Name   -> Function Engine.AnimInstance.Montage_JumpToSection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SectionName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::Montage_JumpToSection(const class FName& SectionName, class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_JumpToSection");
		
		UAnimInstance_Montage_JumpToSection_Params params {};
		params.SectionName = SectionName;
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232E8E0
	 * 		Name   -> Function Engine.AnimInstance.Montage_IsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeFromEndToConsiderFinished                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimInstance::Montage_IsPlaying(class UAnimMontage* Montage, float TimeFromEndToConsiderFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsPlaying");
		
		UAnimInstance_Montage_IsPlaying_Params params {};
		params.Montage = Montage;
		params.TimeFromEndToConsiderFinished = TimeFromEndToConsiderFinished;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232EA40
	 * 		Name   -> Function Engine.AnimInstance.Montage_IsActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimInstance::Montage_IsActive(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_IsActive");
		
		UAnimInstance_Montage_IsActive_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232EB20
	 * 		Name   -> Function Engine.AnimInstance.Montage_GetPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::Montage_GetPosition(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPosition");
		
		UAnimInstance_Montage_GetPosition_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232EC00
	 * 		Name   -> Function Engine.AnimInstance.Montage_GetPlayRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::Montage_GetPlayRate(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetPlayRate");
		
		UAnimInstance_Montage_GetPlayRate_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232ECE0
	 * 		Name   -> Function Engine.AnimInstance.Montage_GetIsStopped
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimInstance::Montage_GetIsStopped(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetIsStopped");
		
		UAnimInstance_Montage_GetIsStopped_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232EDC0
	 * 		Name   -> Function Engine.AnimInstance.Montage_GetCurrentTime
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MontageTimeRemaining                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TotalMontageDuration                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimInstance::Montage_GetCurrentTime(class UAnimMontage* Montage, float* MontageTimeRemaining, float* TotalMontageDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentTime");
		
		UAnimInstance_Montage_GetCurrentTime_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MontageTimeRemaining != nullptr)
			*MontageTimeRemaining = params.MontageTimeRemaining;
		if (TotalMontageDuration != nullptr)
			*TotalMontageDuration = params.TotalMontageDuration;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232EF80
	 * 		Name   -> Function Engine.AnimInstance.Montage_GetCurrentSection
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName UAnimInstance::Montage_GetCurrentSection(class UAnimMontage* Montage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.Montage_GetCurrentSection");
		
		UAnimInstance_Montage_GetCurrentSection_Params params {};
		params.Montage = Montage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D430
	 * 		Name   -> Function Engine.AnimInstance.LockAIResources
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bLockMovement                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               LockAILogic                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::LockAIResources(bool bLockMovement, bool LockAILogic)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.LockAIResources");
		
		UAnimInstance_LockAIResources_Params params {};
		params.bLockMovement = bLockMovement;
		params.LockAILogic = LockAILogic;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F060
	 * 		Name   -> Function Engine.AnimInstance.IsPlayingSlotAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimSequenceBase*                           Asset                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        SlotNodeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimInstance::IsPlayingSlotAnimation(class UAnimSequenceBase* Asset, const class FName& SlotNodeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.IsPlayingSlotAnimation");
		
		UAnimInstance_IsPlayingSlotAnimation_Params params {};
		params.Asset = Asset;
		params.SlotNodeName = SlotNodeName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F1C0
	 * 		Name   -> Function Engine.AnimInstance.GetStateWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            StateIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::GetStateWeight(int32_t MachineIndex, int32_t StateIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetStateWeight");
		
		UAnimInstance_GetStateWeight_Params params {};
		params.MachineIndex = MachineIndex;
		params.StateIndex = StateIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F320
	 * 		Name   -> Function Engine.AnimInstance.GetOwningComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class USkeletalMeshComponent* UAnimInstance::GetOwningComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningComponent");
		
		UAnimInstance_GetOwningComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F340
	 * 		Name   -> Function Engine.AnimInstance.GetOwningActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* UAnimInstance::GetOwningActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetOwningActor");
		
		UAnimInstance_GetOwningActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F370
	 * 		Name   -> Function Engine.AnimInstance.GetCurveValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        CurveName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::GetCurveValue(const class FName& CurveName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurveValue");
		
		UAnimInstance_GetCurveValue_Params params {};
		params.CurveName = CurveName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F450
	 * 		Name   -> Function Engine.AnimInstance.GetCurrentStateElapsedTime
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            MachineIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::GetCurrentStateElapsedTime(int32_t MachineIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentStateElapsedTime");
		
		UAnimInstance_GetCurrentStateElapsedTime_Params params {};
		params.MachineIndex = MachineIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F530
	 * 		Name   -> Function Engine.AnimInstance.GetCurrentActiveMontage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UAnimMontage* UAnimInstance::GetCurrentActiveMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetCurrentActiveMontage");
		
		UAnimInstance_GetCurrentActiveMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F590
	 * 		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEndFraction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFromEndFraction(class UAnimationAsset* AnimAsset, float CurrentTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEndFraction");
		
		UAnimInstance_GetAnimAssetPlayerTimeFromEndFraction_Params params {};
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F710
	 * 		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEnd
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFromEnd(class UAnimationAsset* AnimAsset, float CurrentTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFromEnd");
		
		UAnimInstance_GetAnimAssetPlayerTimeFromEnd_Params params {};
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232F880
	 * 		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerTimeFraction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              CurrentTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::STATIC_GetAnimAssetPlayerTimeFraction(class UAnimationAsset* AnimAsset, float CurrentTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerTimeFraction");
		
		UAnimInstance_GetAnimAssetPlayerTimeFraction_Params params {};
		params.AnimAsset = AnimAsset;
		params.CurrentTime = CurrentTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FA00
	 * 		Name   -> Function Engine.AnimInstance.GetAnimAssetPlayerLength
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimationAsset*                             AnimAsset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::STATIC_GetAnimAssetPlayerLength(class UAnimationAsset* AnimAsset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.GetAnimAssetPlayerLength");
		
		UAnimInstance_GetAnimAssetPlayerLength_Params params {};
		params.AnimAsset = AnimAsset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FAE0
	 * 		Name   -> Function Engine.AnimInstance.ClearMorphTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAnimInstance::ClearMorphTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.ClearMorphTargets");
		
		UAnimInstance_ClearMorphTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FB10
	 * 		Name   -> Function Engine.AnimInstance.CalculateDirection
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Velocity                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    BaseRotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	float UAnimInstance::CalculateDirection(const struct FVector& Velocity, const struct FRotator& BaseRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.CalculateDirection");
		
		UAnimInstance_CalculateDirection_Params params {};
		params.Velocity = Velocity;
		params.BaseRotation = BaseRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.BlueprintUpdateAnimation
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTimeX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::BlueprintUpdateAnimation(float DeltaTimeX)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintUpdateAnimation");
		
		UAnimInstance_BlueprintUpdateAnimation_Params params {};
		params.DeltaTimeX = DeltaTimeX;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.BlueprintTriggerAnimationEvent
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        AnimationEventName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              playedAnimLength                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::BlueprintTriggerAnimationEvent(const class FName& AnimationEventName, float* playedAnimLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintTriggerAnimationEvent");
		
		UAnimInstance_BlueprintTriggerAnimationEvent_Params params {};
		params.AnimationEventName = AnimationEventName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (playedAnimLength != nullptr)
			*playedAnimLength = params.playedAnimLength;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.BlueprintPlayAnimationEvent
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UAnimMontage*                                AnimationMontage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PlayRate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              playedAnimLength                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::BlueprintPlayAnimationEvent(class UAnimMontage* AnimationMontage, float PlayRate, float* playedAnimLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintPlayAnimationEvent");
		
		UAnimInstance_BlueprintPlayAnimationEvent_Params params {};
		params.AnimationMontage = AnimationMontage;
		params.PlayRate = PlayRate;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (playedAnimLength != nullptr)
			*playedAnimLength = params.playedAnimLength;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimInstance.BlueprintInitializeAnimation
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void UAnimInstance::BlueprintInitializeAnimation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.BlueprintInitializeAnimation");
		
		UAnimInstance_BlueprintInitializeAnimation_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FC50
	 * 		Name   -> Function Engine.AnimInstance.AnimNotify_Sound
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UAnimNotify*                                 Notify                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimInstance::AnimNotify_Sound(class UAnimNotify* Notify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimInstance.AnimNotify_Sound");
		
		UAnimInstance_AnimNotify_Sound_Params params {};
		params.Notify = Notify;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimNotify.Received_Notify
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimNotify::Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.Received_Notify");
		
		UAnimNotify_Received_Notify_Params params {};
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330B00
	 * 		Name   -> Function Engine.AnimNotify.GetNotifyName
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	class FString UAnimNotify::GetNotifyName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotify.GetNotifyName");
		
		UAnimNotify_GetNotifyName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotify.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotify::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimNotify");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimNotifyState.Received_NotifyTick
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FrameDeltaTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimNotifyState::Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyTick");
		
		UAnimNotifyState_Received_NotifyTick_Params params {};
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		params.FrameDeltaTime = FrameDeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimNotifyState.Received_NotifyEnd
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimNotifyState::Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyEnd");
		
		UAnimNotifyState_Received_NotifyEnd_Params params {};
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimNotifyState.Received_NotifyBegin
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      MeshComp                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class UAnimSequenceBase*                           Animation                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TotalDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAnimNotifyState::Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.Received_NotifyBegin");
		
		UAnimNotifyState_Received_NotifyBegin_Params params {};
		params.MeshComp = MeshComp;
		params.Animation = Animation;
		params.TotalDuration = TotalDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330B00
	 * 		Name   -> Function Engine.AnimNotifyState.GetNotifyName
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	class FString UAnimNotifyState::GetNotifyName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimNotifyState.GetNotifyName");
		
		UAnimNotifyState_GetNotifyName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimNotifyState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746150
	 * 		Name   -> Function Engine.CurveBase.GetValueRange
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCurveBase::GetValueRange(float* MinValue, float* MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetValueRange");
		
		UCurveBase_GetValueRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746290
	 * 		Name   -> Function Engine.CurveBase.GetTimeRange
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              MinTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxTime                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCurveBase::GetTimeRange(float* MinTime, float* MaxTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CurveBase.GetTimeRange");
		
		UCurveBase_GetTimeRange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (MinTime != nullptr)
			*MinTime = params.MinTime;
		if (MaxTime != nullptr)
			*MaxTime = params.MaxTime;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746070
	 * 		Name   -> Function Engine.CurveFloat.GetFloatValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UCurveFloat::GetFloatValue(float InTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CurveFloat.GetFloatValue");
		
		UCurveFloat_GetFloatValue_Params params {};
		params.InTime = InTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveFloat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveFloat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveFloat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UForceFeedbackEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UForceFeedbackEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ForceFeedbackEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScene.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScene::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Scene");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746C40
	 * 		Name   -> Function Engine.PlayerCameraManager.StopCameraAnimInst
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCameraAnimInst*                             AnimInst                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerCameraManager::StopCameraAnimInst(class UCameraAnimInst* AnimInst, bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopCameraAnimInst");
		
		APlayerCameraManager_StopCameraAnimInst_Params params {};
		params.AnimInst = AnimInst;
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746E00
	 * 		Name   -> Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCameraAnim*                                 Anim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerCameraManager::StopAllInstancesOfCameraAnim(class UCameraAnim* Anim, bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim");
		
		APlayerCameraManager_StopAllInstancesOfCameraAnim_Params params {};
		params.Anim = Anim;
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746F60
	 * 		Name   -> Function Engine.PlayerCameraManager.StopAllCameraAnims
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerCameraManager::StopAllCameraAnims(bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.StopAllCameraAnims");
		
		APlayerCameraManager_StopAllCameraAnims_Params params {};
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747040
	 * 		Name   -> Function Engine.PlayerCameraManager.RemoveCameraLensEffect
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AEmitterCameraLensEffectBase*                Emitter                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerCameraManager::RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.RemoveCameraLensEffect");
		
		APlayerCameraManager_RemoveCameraLensEffect_Params params {};
		params.Emitter = Emitter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747150
	 * 		Name   -> Function Engine.PlayerCameraManager.PlayCameraAnim
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UCameraAnim*                                 Anim                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bRandomStartTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECameraAnimPlaySpace                               PlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    UserPlaySpaceRot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UCameraAnimInst* APlayerCameraManager::PlayCameraAnim(class UCameraAnim* Anim, float Rate, float Scale, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, float Duration, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.PlayCameraAnim");
		
		APlayerCameraManager_PlayCameraAnim_Params params {};
		params.Anim = Anim;
		params.Rate = Rate;
		params.Scale = Scale;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.bLoop = bLoop;
		params.bRandomStartTime = bRandomStartTime;
		params.Duration = Duration;
		params.PlaySpace = PlaySpace;
		params.UserPlaySpaceRot = UserPlaySpaceRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747720
	 * 		Name   -> Function Engine.PlayerCameraManager.GetWorldCameraShakeScale
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bForceReturnUserSettingScale                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float APlayerCameraManager::GetWorldCameraShakeScale(bool bForceReturnUserSettingScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetWorldCameraShakeScale");
		
		APlayerCameraManager_GetWorldCameraShakeScale_Params params {};
		params.bForceReturnUserSettingScale = bForceReturnUserSettingScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747810
	 * 		Name   -> Function Engine.PlayerCameraManager.GetOwningPlayerController
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APlayerController* APlayerCameraManager::GetOwningPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetOwningPlayerController");
		
		APlayerCameraManager_GetOwningPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738280
	 * 		Name   -> Function Engine.PlayerCameraManager.GetCameraRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator APlayerCameraManager::GetCameraRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraRotation");
		
		APlayerCameraManager_GetCameraRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02747870
	 * 		Name   -> Function Engine.PlayerCameraManager.GetCameraLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector APlayerCameraManager::GetCameraLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.GetCameraLocation");
		
		APlayerCameraManager_GetCameraLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027478B0
	 * 		Name   -> Function Engine.PlayerCameraManager.ClearCameraLensEffects
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void APlayerCameraManager::ClearCameraLensEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.ClearCameraLensEffects");
		
		APlayerCameraManager_ClearCameraLensEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PlayerCameraManager.BlueprintUpdateCamera
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      CameraTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewCameraLocation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewCameraRotation                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NewCameraFOV                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerCameraManager::BlueprintUpdateCamera(class AActor* CameraTarget, struct FVector* NewCameraLocation, struct FRotator* NewCameraRotation, float* NewCameraFOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.BlueprintUpdateCamera");
		
		APlayerCameraManager_BlueprintUpdateCamera_Params params {};
		params.CameraTarget = CameraTarget;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (NewCameraLocation != nullptr)
			*NewCameraLocation = params.NewCameraLocation;
		if (NewCameraRotation != nullptr)
			*NewCameraRotation = params.NewCameraRotation;
		if (NewCameraFOV != nullptr)
			*NewCameraFOV = params.NewCameraFOV;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027478D0
	 * 		Name   -> Function Engine.PlayerCameraManager.AddCameraLensEffect
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      LensEffectEmitterClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AEmitterCameraLensEffectBase* APlayerCameraManager::AddCameraLensEffect(class UClass* LensEffectEmitterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerCameraManager.AddCameraLensEffect");
		
		APlayerCameraManager_AddCameraLensEffect_Params params {};
		params.LensEffectEmitterClass = LensEffectEmitterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerCameraManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerCameraManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerCameraManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A610
	 * 		Name   -> Function Engine.PlayerController.WasInputKeyJustReleased
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool APlayerController::WasInputKeyJustReleased(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustReleased");
		
		APlayerController_WasInputKeyJustReleased_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A750
	 * 		Name   -> Function Engine.PlayerController.WasInputKeyJustPressed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool APlayerController::WasInputKeyJustPressed(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.WasInputKeyJustPressed");
		
		APlayerController_WasInputKeyJustPressed_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A890
	 * 		Name   -> Function Engine.PlayerController.ToggleSpeaking
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               bSpeaking                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ToggleSpeaking(bool bSpeaking)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ToggleSpeaking");
		
		APlayerController_ToggleSpeaking_Params params {};
		params.bSpeaking = bSpeaking;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A970
	 * 		Name   -> Function Engine.PlayerController.SwitchLevel
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 */
	void APlayerController::SwitchLevel(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SwitchLevel");
		
		APlayerController_SwitchLevel_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273AA70
	 * 		Name   -> Function Engine.PlayerController.StartFire
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		unsigned char                                      FireModeNum                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::StartFire(unsigned char FireModeNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.StartFire");
		
		APlayerController_StartFire_Params params {};
		params.FireModeNum = FireModeNum;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273AB40
	 * 		Name   -> Function Engine.PlayerController.SetVirtualJoystickVisibility
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::SetVirtualJoystickVisibility(bool bVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetVirtualJoystickVisibility");
		
		APlayerController_SetVirtualJoystickVisibility_Params params {};
		params.bVisible = bVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273AC20
	 * 		Name   -> Function Engine.PlayerController.SetViewTargetWithBlend
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      NewViewTarget                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EViewTargetBlendFunction                           BlendFunc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLockOutgoing                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetViewTargetWithBlend");
		
		APlayerController_SetViewTargetWithBlend_Params params {};
		params.NewViewTarget = NewViewTarget;
		params.BlendTime = BlendTime;
		params.BlendFunc = BlendFunc;
		params.BlendExp = BlendExp;
		params.bLockOutgoing = bLockOutgoing;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273AF70
	 * 		Name   -> Function Engine.PlayerController.SetName
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 */
	void APlayerController::SetName(const class FString& S)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetName");
		
		APlayerController_SetName_Params params {};
		params.S = S;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B0A0
	 * 		Name   -> Function Engine.PlayerController.SetIgnoreMoveInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewMoveInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::SetIgnoreMoveInput(bool bNewMoveInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetIgnoreMoveInput");
		
		APlayerController_SetIgnoreMoveInput_Params params {};
		params.bNewMoveInput = bNewMoveInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B1C0
	 * 		Name   -> Function Engine.PlayerController.SetIgnoreLookInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewLookInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::SetIgnoreLookInput(bool bNewLookInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetIgnoreLookInput");
		
		APlayerController_SetIgnoreLookInput_Params params {};
		params.bNewLookInput = bNewLookInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B2E0
	 * 		Name   -> Function Engine.PlayerController.SetAudioListenerOverride
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::SetAudioListenerOverride(class USceneComponent* attachToComponent, const struct FVector& Location, const struct FRotator& Rotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SetAudioListenerOverride");
		
		APlayerController_SetAudioListenerOverride_Params params {};
		params.attachToComponent = attachToComponent;
		params.Location = Location;
		params.Rotation = Rotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B530
	 * 		Name   -> Function Engine.PlayerController.ServerViewSelf
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FViewTargetTransitionParams                 TransitionParams                                           (Parm)
	 */
	void APlayerController::ServerViewSelf(const struct FViewTargetTransitionParams& TransitionParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewSelf");
		
		APlayerController_ServerViewSelf_Params params {};
		params.TransitionParams = TransitionParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B6B0
	 * 		Name   -> Function Engine.PlayerController.ServerViewPrevPlayer
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerViewPrevPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewPrevPlayer");
		
		APlayerController_ServerViewPrevPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B760
	 * 		Name   -> Function Engine.PlayerController.ServerViewNextPlayer
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerViewNextPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerViewNextPlayer");
		
		APlayerController_ServerViewNextPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B810
	 * 		Name   -> Function Engine.PlayerController.ServerVerifyViewTarget
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerVerifyViewTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerVerifyViewTarget");
		
		APlayerController_ServerVerifyViewTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B870
	 * 		Name   -> Function Engine.PlayerController.ServerUpdateLevelVisibility
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsVisible                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerUpdateLevelVisibility(const class FName& PackageName, bool bIsVisible)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateLevelVisibility");
		
		APlayerController_ServerUpdateLevelVisibility_Params params {};
		params.PackageName = PackageName;
		params.bIsVisible = bIsVisible;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273B9F0
	 * 		Name   -> Function Engine.PlayerController.ServerUpdateCamera
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FVector_NetQuantize                         CamLoc                                                     (Parm)
	 * 		int32_t                                            CamPitchAndYaw                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerUpdateCamera(const struct FVector_NetQuantize& CamLoc, int32_t CamPitchAndYaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUpdateCamera");
		
		APlayerController_ServerUpdateCamera_Params params {};
		params.CamLoc = CamLoc;
		params.CamPitchAndYaw = CamPitchAndYaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BBB0
	 * 		Name   -> Function Engine.PlayerController.ServerUnmutePlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
	 */
	void APlayerController::ServerUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerUnmutePlayer");
		
		APlayerController_ServerUnmutePlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BD10
	 * 		Name   -> Function Engine.PlayerController.ServerToggleAILogging
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerToggleAILogging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerToggleAILogging");
		
		APlayerController_ServerToggleAILogging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BD70
	 * 		Name   -> Function Engine.PlayerController.ServerShortTimeout
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerShortTimeout()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerShortTimeout");
		
		APlayerController_ServerShortTimeout_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BDF0
	 * 		Name   -> Function Engine.PlayerController.ServerSetSpectatorLocation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerSetSpectatorLocation(const struct FVector& NewLoc)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerSetSpectatorLocation");
		
		APlayerController_ServerSetSpectatorLocation_Params params {};
		params.NewLoc = NewLoc;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BF20
	 * 		Name   -> Function Engine.PlayerController.ServerRestartPlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)
	 */
	void APlayerController::ServerRestartPlayer()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerRestartPlayer");
		
		APlayerController_ServerRestartPlayer_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BF80
	 * 		Name   -> Function Engine.PlayerController.ServerReceivedPlayerControllerAck
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 */
	void APlayerController::ServerReceivedPlayerControllerAck()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerReceivedPlayerControllerAck");
		
		APlayerController_ServerReceivedPlayerControllerAck_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273BFD0
	 * 		Name   -> Function Engine.PlayerController.ServerProcessNetExecCommandUnreliable
	 * 		Flags  -> (Net, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (Parm)
	 */
	void APlayerController::ServerProcessNetExecCommandUnreliable(class AActor* forActor, const class FName& CommandName, const struct FBPNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerProcessNetExecCommandUnreliable");
		
		APlayerController_ServerProcessNetExecCommandUnreliable_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C250
	 * 		Name   -> Function Engine.PlayerController.ServerProcessNetExecCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (Parm)
	 */
	void APlayerController::ServerProcessNetExecCommand(class AActor* forActor, const class FName& CommandName, const struct FBPNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerProcessNetExecCommand");
		
		APlayerController_ServerProcessNetExecCommand_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C4D0
	 * 		Name   -> Function Engine.PlayerController.ServerPause
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerPause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerPause");
		
		APlayerController_ServerPause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C540
	 * 		Name   -> Function Engine.PlayerController.ServerNotifyLoadedWorld
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        WorldPackageName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerNotifyLoadedWorld(const class FName& WorldPackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerNotifyLoadedWorld");
		
		APlayerController_ServerNotifyLoadedWorld_Params params {};
		params.WorldPackageName = WorldPackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C670
	 * 		Name   -> Function Engine.PlayerController.ServerMutePlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
	 */
	void APlayerController::ServerMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerMutePlayer");
		
		APlayerController_ServerMutePlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C7D0
	 * 		Name   -> Function Engine.PlayerController.ServerCheckClientPossession
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 */
	void APlayerController::ServerCheckClientPossession()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCheckClientPossession");
		
		APlayerController_ServerCheckClientPossession_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C870
	 * 		Name   -> Function Engine.PlayerController.ServerChangeName
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 */
	void APlayerController::ServerChangeName(const class FString& S)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerChangeName");
		
		APlayerController_ServerChangeName_Params params {};
		params.S = S;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273C9C0
	 * 		Name   -> Function Engine.PlayerController.ServerCamera
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class FName                                        NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerCamera(const class FName& NewMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerCamera");
		
		APlayerController_ServerCamera_Params params {};
		params.NewMode = NewMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CB70
	 * 		Name   -> Function Engine.PlayerController.ServerAcknowledgePossession
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		class APawn*                                       P                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ServerAcknowledgePossession(class APawn* P)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ServerAcknowledgePossession");
		
		APlayerController_ServerAcknowledgePossession_Params params {};
		params.P = P;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CCB0
	 * 		Name   -> Function Engine.PlayerController.SendToConsole
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor)
	 */
	void APlayerController::SendToConsole(const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.SendToConsole");
		
		APlayerController_SendToConsole_Params params {};
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CDC0
	 * 		Name   -> Function Engine.PlayerController.RestartLevel
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void APlayerController::RestartLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.RestartLevel");
		
		APlayerController_RestartLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CDE0
	 * 		Name   -> Function Engine.PlayerController.ResetIgnoreInputFlags
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void APlayerController::ResetIgnoreInputFlags()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ResetIgnoreInputFlags");
		
		APlayerController_ResetIgnoreInputFlags_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CE00
	 * 		Name   -> Function Engine.PlayerController.ProjectWorldLocationToScreen
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenLocation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerController::ProjectWorldLocationToScreen(const struct FVector& WorldLocation, struct FVector2D* ScreenLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ProjectWorldLocationToScreen");
		
		APlayerController_ProjectWorldLocationToScreen_Params params {};
		params.WorldLocation = WorldLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ScreenLocation != nullptr)
			*ScreenLocation = params.ScreenLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273CF60
	 * 		Name   -> Function Engine.PlayerController.PlayDynamicForceFeedback
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Intensity                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsLeftLarge                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bAffectsLeftSmall                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bAffectsRightLarge                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bAffectsRightSmall                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		EDynamicForceFeedbackAction                        Action                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 */
	void APlayerController::PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, EDynamicForceFeedbackAction Action, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.PlayDynamicForceFeedback");
		
		APlayerController_PlayDynamicForceFeedback_Params params {};
		params.Intensity = Intensity;
		params.Duration = Duration;
		params.bAffectsLeftLarge = bAffectsLeftLarge;
		params.bAffectsLeftSmall = bAffectsLeftSmall;
		params.bAffectsRightLarge = bAffectsRightLarge;
		params.bAffectsRightSmall = bAffectsRightSmall;
		params.Action = Action;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273D430
	 * 		Name   -> Function Engine.PlayerController.Pause
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void APlayerController::Pause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Pause");
		
		APlayerController_Pause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273D4B0
	 * 		Name   -> Function Engine.PlayerController.NetSpawnActorAtLocation
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UClass*                                      anActorClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize                         AtLocation                                                 (Parm)
	 * 		struct FRotator_NetQuantize                        AtRotation                                                 (Parm)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            dataIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        attachSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::NetSpawnActorAtLocation(class UClass* anActorClass, const struct FVector_NetQuantize& AtLocation, const struct FRotator_NetQuantize& AtRotation, class USceneComponent* attachToComponent, int32_t dataIndex, const class FName& attachSocketName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.NetSpawnActorAtLocation");
		
		APlayerController_NetSpawnActorAtLocation_Params params {};
		params.anActorClass = anActorClass;
		params.AtLocation = AtLocation;
		params.AtRotation = AtRotation;
		params.attachToComponent = attachToComponent;
		params.dataIndex = dataIndex;
		params.attachSocketName = attachSocketName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273D830
	 * 		Name   -> Function Engine.PlayerController.NetConnectionHasActiveActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      anActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerController::NetConnectionHasActiveActor(class AActor* anActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.NetConnectionHasActiveActor");
		
		APlayerController_NetConnectionHasActiveActor_Params params {};
		params.anActor = anActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273D910
	 * 		Name   -> Function Engine.PlayerController.LocalTravel
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 */
	void APlayerController::LocalTravel(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.LocalTravel");
		
		APlayerController_LocalTravel_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DA10
	 * 		Name   -> Function Engine.PlayerController.IsMoveInputIgnored
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APlayerController::IsMoveInputIgnored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsMoveInputIgnored");
		
		APlayerController_IsMoveInputIgnored_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231ED00
	 * 		Name   -> Function Engine.PlayerController.IsLookInputIgnored
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APlayerController::IsLookInputIgnored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsLookInputIgnored");
		
		APlayerController_IsLookInputIgnored_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DA40
	 * 		Name   -> Function Engine.PlayerController.IsInputKeyDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool APlayerController::IsInputKeyDown(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.IsInputKeyDown");
		
		APlayerController_IsInputKeyDown_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DB80
	 * 		Name   -> Function Engine.PlayerController.HandleRespawned
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               IsFirstSpawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::HandleRespawned(class APawn* NewPawn, bool IsFirstSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.HandleRespawned");
		
		APlayerController_HandleRespawned_Params params {};
		params.NewPawn = NewPawn;
		params.IsFirstSpawn = IsFirstSpawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DCE0
	 * 		Name   -> Function Engine.PlayerController.GetViewportSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            SizeX                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            SizeY                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::GetViewportSize(int32_t* SizeX, int32_t* SizeY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetViewportSize");
		
		APlayerController_GetViewportSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SizeX != nullptr)
			*SizeX = params.SizeX;
		if (SizeY != nullptr)
			*SizeY = params.SizeY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DE20
	 * 		Name   -> Function Engine.PlayerController.GetMousePosition
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEvenWhenMouseNotAttached                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerController::GetMousePosition(float* LocationX, float* LocationY, bool bEvenWhenMouseNotAttached)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetMousePosition");
		
		APlayerController_GetMousePosition_Params params {};
		params.bEvenWhenMouseNotAttached = bEvenWhenMouseNotAttached;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273DFE0
	 * 		Name   -> Function Engine.PlayerController.GetInputVectorKeyState
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	struct FVector APlayerController::GetInputVectorKeyState(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputVectorKeyState");
		
		APlayerController_GetInputVectorKeyState_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273E130
	 * 		Name   -> Function Engine.PlayerController.GetInputTouchState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsCurrentlyPressed                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::GetInputTouchState(ETouchIndex FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputTouchState");
		
		APlayerController_GetInputTouchState_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		if (bIsCurrentlyPressed != nullptr)
			*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273E3B0
	 * 		Name   -> Function Engine.PlayerController.GetInputMouseDelta
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              DeltaX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::GetInputMouseDelta(float* DeltaX, float* DeltaY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMouseDelta");
		
		APlayerController_GetInputMouseDelta_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DeltaX != nullptr)
			*DeltaX = params.DeltaX;
		if (DeltaY != nullptr)
			*DeltaY = params.DeltaY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273E4F0
	 * 		Name   -> Function Engine.PlayerController.GetInputMotionState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Tilt                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     RotationRate                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Gravity                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Acceleration                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::GetInputMotionState(struct FVector* Tilt, struct FVector* RotationRate, struct FVector* Gravity, struct FVector* Acceleration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputMotionState");
		
		APlayerController_GetInputMotionState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Tilt != nullptr)
			*Tilt = params.Tilt;
		if (RotationRate != nullptr)
			*RotationRate = params.RotationRate;
		if (Gravity != nullptr)
			*Gravity = params.Gravity;
		if (Acceleration != nullptr)
			*Acceleration = params.Acceleration;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273E730
	 * 		Name   -> Function Engine.PlayerController.GetInputKeyTimeDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	float APlayerController::GetInputKeyTimeDown(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputKeyTimeDown");
		
		APlayerController_GetInputKeyTimeDown_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273E870
	 * 		Name   -> Function Engine.PlayerController.GetInputAnalogStickState
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EControllerAnalogStick                             WhichStick                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StickX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StickY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::GetInputAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogStickState");
		
		APlayerController_GetInputAnalogStickState_Params params {};
		params.WhichStick = WhichStick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (StickX != nullptr)
			*StickX = params.StickX;
		if (StickY != nullptr)
			*StickY = params.StickY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273EA30
	 * 		Name   -> Function Engine.PlayerController.GetInputAnalogKeyState
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	float APlayerController::GetInputAnalogKeyState(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetInputAnalogKeyState");
		
		APlayerController_GetInputAnalogKeyState_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F3FE00
	 * 		Name   -> Function Engine.PlayerController.GetHUD
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AHUD* APlayerController::GetHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHUD");
		
		APlayerController_GetHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273EB70
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderFingerForObjects
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderFingerForObjects(ETouchIndex FingerIndex, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerForObjects");
		
		APlayerController_GetHitResultUnderFingerForObjects_Params params {};
		params.FingerIndex = FingerIndex;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273EDB0
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderFingerByChannel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderFingerByChannel(ETouchIndex FingerIndex, ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFingerByChannel");
		
		APlayerController_GetHitResultUnderFingerByChannel_Params params {};
		params.FingerIndex = FingerIndex;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F000
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderFinger
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderFinger(ETouchIndex FingerIndex, ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderFinger");
		
		APlayerController_GetHitResultUnderFinger_Params params {};
		params.FingerIndex = FingerIndex;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F250
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderCursorForObjects
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderCursorForObjects(TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorForObjects");
		
		APlayerController_GetHitResultUnderCursorForObjects_Params params {};
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F410
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderCursorByChannel
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderCursorByChannel(ETraceTypeQuery TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursorByChannel");
		
		APlayerController_GetHitResultUnderCursorByChannel_Params params {};
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F5E0
	 * 		Name   -> Function Engine.PlayerController.GetHitResultUnderCursor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitResult                                                  (Parm, OutParm)
	 */
	bool APlayerController::GetHitResultUnderCursor(ECollisionChannel TraceChannel, bool bTraceComplex, struct FHitResult* HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.GetHitResultUnderCursor");
		
		APlayerController_GetHitResultUnderCursor_Params params {};
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitResult != nullptr)
			*HitResult = params.HitResult;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F7B0
	 * 		Name   -> Function Engine.PlayerController.FOV
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              NewFOV                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::FOV(float NewFOV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.FOV");
		
		APlayerController_FOV_Params params {};
		params.NewFOV = NewFOV;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F880
	 * 		Name   -> Function Engine.PlayerController.EnableCheats
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      pass                                                       (ConstParm, Parm, ZeroConstructor)
	 */
	void APlayerController::EnableCheats(const class FString& pass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.EnableCheats");
		
		APlayerController_EnableCheats_Params params {};
		params.pass = pass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273F9B0
	 * 		Name   -> Function Engine.PlayerController.DeprojectScreenPositionToWorld
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerController::DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, struct FVector* WorldLocation, struct FVector* WorldDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectScreenPositionToWorld");
		
		APlayerController_DeprojectScreenPositionToWorld_Params params {};
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WorldLocation != nullptr)
			*WorldLocation = params.WorldLocation;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273FC00
	 * 		Name   -> Function Engine.PlayerController.DeprojectMousePositionToWorld
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APlayerController::DeprojectMousePositionToWorld(struct FVector* WorldLocation, struct FVector* WorldDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.DeprojectMousePositionToWorld");
		
		APlayerController_DeprojectMousePositionToWorld_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WorldLocation != nullptr)
			*WorldLocation = params.WorldLocation;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273FD40
	 * 		Name   -> Function Engine.PlayerController.CopyStringToClipboard
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 */
	void APlayerController::CopyStringToClipboard(const class FString& S)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.CopyStringToClipboard");
		
		APlayerController_CopyStringToClipboard_Params params {};
		params.S = S;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273FE70
	 * 		Name   -> Function Engine.PlayerController.ConsoleKey
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	void APlayerController::ConsoleKey(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ConsoleKey");
		
		APlayerController_ConsoleKey_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273FFB0
	 * 		Name   -> Function Engine.PlayerController.ClientWasKicked
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FText                                        KickReason                                                 (ConstParm, Parm)
	 */
	void APlayerController::ClientWasKicked(const class FText& KickReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientWasKicked");
		
		APlayerController_ClientWasKicked_Params params {};
		params.KickReason = KickReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740100
	 * 		Name   -> Function Engine.PlayerController.ClientVoiceHandshakeComplete
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientVoiceHandshakeComplete()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientVoiceHandshakeComplete");
		
		APlayerController_ClientVoiceHandshakeComplete_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740150
	 * 		Name   -> Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewShouldBeLoaded                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewShouldBeVisible                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewShouldBlockOnLoad                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            LODIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientUpdateLevelStreamingStatus(const class FName& PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32_t LODIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUpdateLevelStreamingStatus");
		
		APlayerController_ClientUpdateLevelStreamingStatus_Params params {};
		params.PackageName = PackageName;
		params.bNewShouldBeLoaded = bNewShouldBeLoaded;
		params.bNewShouldBeVisible = bNewShouldBeVisible;
		params.bNewShouldBlockOnLoad = bNewShouldBlockOnLoad;
		params.LODIndex = LODIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740490
	 * 		Name   -> Function Engine.PlayerController.ClientUnmutePlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
	 */
	void APlayerController::ClientUnmutePlayer(const struct FUniqueNetIdRepl& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientUnmutePlayer");
		
		APlayerController_ClientUnmutePlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027405B0
	 * 		Name   -> Function Engine.PlayerController.ClientTravelInternal
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 * 		ETravelType                                        TravelType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FGuid                                       MapPackageGuid                                             (Parm, ZeroConstructor)
	 */
	void APlayerController::ClientTravelInternal(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravelInternal");
		
		APlayerController_ClientTravelInternal_Params params {};
		params.URL = URL;
		params.TravelType = TravelType;
		params.bSeamless = bSeamless;
		params.MapPackageGuid = MapPackageGuid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740890
	 * 		Name   -> Function Engine.PlayerController.ClientTravel
	 * 		Flags  -> (Final, Native, Public, HasDefaults)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 * 		ETravelType                                        TravelType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSeamless                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FGuid                                       MapPackageGuid                                             (Parm, ZeroConstructor)
	 */
	void APlayerController::ClientTravel(const class FString& URL, ETravelType TravelType, bool bSeamless, const struct FGuid& MapPackageGuid)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTravel");
		
		APlayerController_ClientTravel_Params params {};
		params.URL = URL;
		params.TravelType = TravelType;
		params.bSeamless = bSeamless;
		params.MapPackageGuid = MapPackageGuid;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740BD0
	 * 		Name   -> Function Engine.PlayerController.ClientTeleportSucceeded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     TeleportLoc                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    TeleportRot                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSimpleTeleport                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientTeleportSucceeded(const struct FVector& TeleportLoc, const struct FRotator& TeleportRot, bool bSimpleTeleport)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeleportSucceeded");
		
		APlayerController_ClientTeleportSucceeded_Params params {};
		params.TeleportLoc = TeleportLoc;
		params.TeleportRot = TeleportRot;
		params.bSimpleTeleport = bSimpleTeleport;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02740DE0
	 * 		Name   -> Function Engine.PlayerController.ClientTeamMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APlayerState*                                SenderPlayerState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientTeamMessage(class APlayerState* SenderPlayerState, const class FString& S, const class FName& Type, float MsgLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientTeamMessage");
		
		APlayerController_ClientTeamMessage_Params params {};
		params.SenderPlayerState = SenderPlayerState;
		params.S = S;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741090
	 * 		Name   -> Function Engine.PlayerController.ClientStopForceFeedback
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UForceFeedbackEffect*                        ForceFeedbackEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopForceFeedback");
		
		APlayerController_ClientStopForceFeedback_Params params {};
		params.ForceFeedbackEffect = ForceFeedbackEffect;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027411F0
	 * 		Name   -> Function Engine.PlayerController.ClientStopCameraShake
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientStopCameraShake(class UClass* Shake)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraShake");
		
		APlayerController_ClientStopCameraShake_Params params {};
		params.Shake = Shake;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741300
	 * 		Name   -> Function Engine.PlayerController.ClientStopCameraAnim
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UCameraAnim*                                 AnimToStop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientStopCameraAnim(class UCameraAnim* AnimToStop)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientStopCameraAnim");
		
		APlayerController_ClientStopCameraAnim_Params params {};
		params.AnimToStop = AnimToStop;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741410
	 * 		Name   -> Function Engine.PlayerController.ClientSpawnCameraLensEffect
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      LensEffectEmitterClass                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSpawnCameraLensEffect");
		
		APlayerController_ClientSpawnCameraLensEffect_Params params {};
		params.LensEffectEmitterClass = LensEffectEmitterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741520
	 * 		Name   -> Function Engine.PlayerController.ClientSetViewTarget
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FViewTargetTransitionParams                 TransitionParams                                           (Parm)
	 */
	void APlayerController::ClientSetViewTarget(class AActor* A, const struct FViewTargetTransitionParams& TransitionParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetViewTarget");
		
		APlayerController_ClientSetViewTarget_Params params {};
		params.A = A;
		params.TransitionParams = TransitionParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027416D0
	 * 		Name   -> Function Engine.PlayerController.ClientSetHUD
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewHUDClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSetHUD(class UClass* NewHUDClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetHUD");
		
		APlayerController_ClientSetHUD_Params params {};
		params.NewHUDClass = NewHUDClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027417A0
	 * 		Name   -> Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ForceDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            CinematicTextureGroups                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32_t CinematicTextureGroups)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident");
		
		APlayerController_ClientSetForceMipLevelsToBeResident_Params params {};
		params.Material = Material;
		params.ForceDuration = ForceDuration;
		params.CinematicTextureGroups = CinematicTextureGroups;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741A20
	 * 		Name   -> Function Engine.PlayerController.ClientSetCinematicMode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bInCinematicMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsMovement                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCinematicMode");
		
		APlayerController_ClientSetCinematicMode_Params params {};
		params.bInCinematicMode = bInCinematicMode;
		params.bAffectsMovement = bAffectsMovement;
		params.bAffectsTurning = bAffectsTurning;
		params.bAffectsHUD = bAffectsHUD;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741CC0
	 * 		Name   -> Function Engine.PlayerController.ClientSetCameraMode
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        NewCamMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSetCameraMode(const class FName& NewCamMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraMode");
		
		APlayerController_ClientSetCameraMode_Params params {};
		params.NewCamMode = NewCamMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02741DD0
	 * 		Name   -> Function Engine.PlayerController.ClientSetCameraFade
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		bool                                               bEnableFading                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FColor                                      FadeColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   FadeAlpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFadeAudio                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSetCameraFade(bool bEnableFading, const struct FColor& FadeColor, const struct FVector2D& FadeAlpha, float FadeTime, bool bFadeAudio)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetCameraFade");
		
		APlayerController_ClientSetCameraFade_Params params {};
		params.bEnableFading = bEnableFading;
		params.FadeColor = FadeColor;
		params.FadeAlpha = FadeAlpha;
		params.FadeTime = FadeTime;
		params.bFadeAudio = bFadeAudio;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EB1E50
	 * 		Name   -> Function Engine.PlayerController.ClientSetBlockOnAsyncLoading
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientSetBlockOnAsyncLoading()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSetBlockOnAsyncLoading");
		
		APlayerController_ClientSetBlockOnAsyncLoading_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027420D0
	 * 		Name   -> Function Engine.PlayerController.ClientSendNetExecCommandToServer
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		bool                                               bIsReliable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientSendNetExecCommandToServer(class AActor* forActor, const class FName& CommandName, const struct FBPNetExecParams& ExecParams, bool bIsReliable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientSendNetExecCommandToServer");
		
		APlayerController_ClientSendNetExecCommandToServer_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		params.bIsReliable = bIsReliable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742370
	 * 		Name   -> Function Engine.PlayerController.ClientReturnToMainMenu
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      ReturnReason                                               (Parm, ZeroConstructor)
	 */
	void APlayerController::ClientReturnToMainMenu(const class FString& ReturnReason)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReturnToMainMenu");
		
		APlayerController_ClientReturnToMainMenu_Params params {};
		params.ReturnReason = ReturnReason;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742470
	 * 		Name   -> Function Engine.PlayerController.ClientRetryClientRestart
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientRetryClientRestart(class APawn* NewPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRetryClientRestart");
		
		APlayerController_ClientRetryClientRestart_Params params {};
		params.NewPawn = NewPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742540
	 * 		Name   -> Function Engine.PlayerController.ClientRestart
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientRestart(class APawn* NewPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRestart");
		
		APlayerController_ClientRestart_Params params {};
		params.NewPawn = NewPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742610
	 * 		Name   -> Function Engine.PlayerController.ClientReset
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReset");
		
		APlayerController_ClientReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742630
	 * 		Name   -> Function Engine.PlayerController.ClientRepObjRef
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientRepObjRef(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientRepObjRef");
		
		APlayerController_ClientRepObjRef_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742720
	 * 		Name   -> Function Engine.PlayerController.ClientReceiveLocalizedMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class UClass*                                      Message                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Switch                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerState*                                RelatedPlayerState_2                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerState*                                RelatedPlayerState_3                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     OptionalObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientReceiveLocalizedMessage(class UClass* Message, int32_t Switch, class APlayerState* RelatedPlayerState_2, class APlayerState* RelatedPlayerState_3, class UObject* OptionalObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientReceiveLocalizedMessage");
		
		APlayerController_ClientReceiveLocalizedMessage_Params params {};
		params.Message = Message;
		params.Switch = Switch;
		params.RelatedPlayerState_2 = RelatedPlayerState_2;
		params.RelatedPlayerState_3 = RelatedPlayerState_3;
		params.OptionalObject = OptionalObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742A10
	 * 		Name   -> Function Engine.PlayerController.ClientProcessSimpleNetExecCommandUnreliableBP
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientProcessSimpleNetExecCommandUnreliableBP(class AActor* forActor, const class FName& CommandName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessSimpleNetExecCommandUnreliableBP");
		
		APlayerController_ClientProcessSimpleNetExecCommandUnreliableBP_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742B70
	 * 		Name   -> Function Engine.PlayerController.ClientProcessSimpleNetExecCommandBP
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientProcessSimpleNetExecCommandBP(class AActor* forActor, const class FName& CommandName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessSimpleNetExecCommandBP");
		
		APlayerController_ClientProcessSimpleNetExecCommandBP_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742CD0
	 * 		Name   -> Function Engine.PlayerController.ClientProcessNetExecCommandUnreliableBP
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (Parm)
	 */
	void APlayerController::ClientProcessNetExecCommandUnreliableBP(class AActor* forActor, const class FName& CommandName, const struct FBPNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessNetExecCommandUnreliableBP");
		
		APlayerController_ClientProcessNetExecCommandUnreliableBP_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02742F50
	 * 		Name   -> Function Engine.PlayerController.ClientProcessNetExecCommandUnreliable
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FNetExecParams                              ExecParams                                                 (Parm)
	 */
	void APlayerController::ClientProcessNetExecCommandUnreliable(class AActor* forActor, const class FName& CommandName, const struct FNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessNetExecCommandUnreliable");
		
		APlayerController_ClientProcessNetExecCommandUnreliable_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743190
	 * 		Name   -> Function Engine.PlayerController.ClientProcessNetExecCommandBP
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FBPNetExecParams                            ExecParams                                                 (Parm)
	 */
	void APlayerController::ClientProcessNetExecCommandBP(class AActor* forActor, const class FName& CommandName, const struct FBPNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessNetExecCommandBP");
		
		APlayerController_ClientProcessNetExecCommandBP_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743410
	 * 		Name   -> Function Engine.PlayerController.ClientProcessNetExecCommand
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      forActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        CommandName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FNetExecParams                              ExecParams                                                 (Parm)
	 */
	void APlayerController::ClientProcessNetExecCommand(class AActor* forActor, const class FName& CommandName, const struct FNetExecParams& ExecParams)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientProcessNetExecCommand");
		
		APlayerController_ClientProcessNetExecCommand_Params params {};
		params.forActor = forActor;
		params.CommandName = CommandName;
		params.ExecParams = ExecParams;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743650
	 * 		Name   -> Function Engine.PlayerController.ClientPrestreamTextures
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      ForcedActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ForceDuration                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableStreaming                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            CinematicTextureGroups                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32_t CinematicTextureGroups)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrestreamTextures");
		
		APlayerController_ClientPrestreamTextures_Params params {};
		params.ForcedActor = ForcedActor;
		params.ForceDuration = ForceDuration;
		params.bEnableStreaming = bEnableStreaming;
		params.CinematicTextureGroups = CinematicTextureGroups;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743950
	 * 		Name   -> Function Engine.PlayerController.ClientPrepareMapChange
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFirst                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLast                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPrepareMapChange(const class FName& LevelName, bool bFirst, bool bLast)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPrepareMapChange");
		
		APlayerController_ClientPrepareMapChange_Params params {};
		params.LevelName = LevelName;
		params.bFirst = bFirst;
		params.bLast = bLast;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743B30
	 * 		Name   -> Function Engine.PlayerController.ClientPlaySoundAtLocation
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySoundAtLocation");
		
		APlayerController_ClientPlaySoundAtLocation_Params params {};
		params.Sound = Sound;
		params.Location = Location;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743DF0
	 * 		Name   -> Function Engine.PlayerController.ClientPlaySound
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlaySound");
		
		APlayerController_ClientPlaySound_Params params {};
		params.Sound = Sound;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02743FD0
	 * 		Name   -> Function Engine.PlayerController.ClientPlayForceFeedback
	 * 		Flags  -> (Net, Native, Event, Public, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UForceFeedbackEffect*                        ForceFeedbackEffect                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        Tag                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, bool bLooping, const class FName& Tag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayForceFeedback");
		
		APlayerController_ClientPlayForceFeedback_Params params {};
		params.ForceFeedbackEffect = ForceFeedbackEffect;
		params.bLooping = bLooping;
		params.Tag = Tag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027441B0
	 * 		Name   -> Function Engine.PlayerController.ClientPlayCameraShake
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECameraAnimPlaySpace                               PlaySpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    UserPlaySpaceRot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Speed                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceUseWorldCameraShakeScale                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPlayCameraShake(class UClass* Shake, float Scale, ECameraAnimPlaySpace PlaySpace, const struct FRotator& UserPlaySpaceRot, float Speed, bool bForceUseWorldCameraShakeScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraShake");
		
		APlayerController_ClientPlayCameraShake_Params params {};
		params.Shake = Shake;
		params.Scale = Scale;
		params.PlaySpace = PlaySpace;
		params.UserPlaySpaceRot = UserPlaySpaceRot;
		params.Speed = Speed;
		params.bForceUseWorldCameraShakeScale = bForceUseWorldCameraShakeScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744590
	 * 		Name   -> Function Engine.PlayerController.ClientPlayCameraAnim
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient, BlueprintCallable)
	 * Parameters:
	 * 		class UCameraAnim*                                 AnimToPlay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLoop                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bRandomStartTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECameraAnimPlaySpace                               Space                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    CustomPlaySpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientPlayCameraAnim(class UCameraAnim* AnimToPlay, float Scale, float Rate, float BlendInTime, float BlendOutTime, bool bLoop, bool bRandomStartTime, ECameraAnimPlaySpace Space, const struct FRotator& CustomPlaySpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientPlayCameraAnim");
		
		APlayerController_ClientPlayCameraAnim_Params params {};
		params.AnimToPlay = AnimToPlay;
		params.Scale = Scale;
		params.Rate = Rate;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		params.bLoop = bLoop;
		params.bRandomStartTime = bRandomStartTime;
		params.Space = Space;
		params.CustomPlaySpace = CustomPlaySpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744AB0
	 * 		Name   -> Function Engine.PlayerController.ClientNotifyRespawned
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               IsFirstSpawn                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientNotifyRespawned(class APawn* NewPawn, bool IsFirstSpawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientNotifyRespawned");
		
		APlayerController_ClientNotifyRespawned_Params params {};
		params.NewPawn = NewPawn;
		params.IsFirstSpawn = IsFirstSpawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744C10
	 * 		Name   -> Function Engine.PlayerController.ClientNotifyReconnected
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class APawn*                                       NewPawn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientNotifyReconnected(class APawn* NewPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientNotifyReconnected");
		
		APlayerController_ClientNotifyReconnected_Params params {};
		params.NewPawn = NewPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744CE0
	 * 		Name   -> Function Engine.PlayerController.ClientNetGUIDActorDeletion
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FNetworkGUID                                TheNetGUID                                                 (Parm)
	 */
	void APlayerController::ClientNetGUIDActorDeletion(const struct FNetworkGUID& TheNetGUID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientNetGUIDActorDeletion");
		
		APlayerController_ClientNetGUIDActorDeletion_Params params {};
		params.TheNetGUID = TheNetGUID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744DB0
	 * 		Name   -> Function Engine.PlayerController.ClientMutePlayer
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		struct FUniqueNetIdRepl                            PlayerId                                                   (Parm)
	 */
	void APlayerController::ClientMutePlayer(const struct FUniqueNetIdRepl& PlayerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMutePlayer");
		
		APlayerController_ClientMutePlayer_Params params {};
		params.PlayerId = PlayerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02744ED0
	 * 		Name   -> Function Engine.PlayerController.ClientMessage
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 * 		class FName                                        Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MsgLifeTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientMessage(const class FString& S, const class FName& Type, float MsgLifeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientMessage");
		
		APlayerController_ClientMessage_Params params {};
		params.S = S;
		params.Type = Type;
		params.MsgLifeTime = MsgLifeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027450F0
	 * 		Name   -> Function Engine.PlayerController.ClientIgnoreMoveInput
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientIgnoreMoveInput(bool bIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreMoveInput");
		
		APlayerController_ClientIgnoreMoveInput_Params params {};
		params.bIgnore = bIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745220
	 * 		Name   -> Function Engine.PlayerController.ClientIgnoreLookInput
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bIgnore                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientIgnoreLookInput(bool bIgnore)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientIgnoreLookInput");
		
		APlayerController_ClientIgnoreLookInput_Params params {};
		params.bIgnore = bIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745350
	 * 		Name   -> Function Engine.PlayerController.ClientGotoState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class FName                                        NewState                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientGotoState(const class FName& NewState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGotoState");
		
		APlayerController_ClientGotoState_Params params {};
		params.NewState = NewState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745450
	 * 		Name   -> Function Engine.PlayerController.ClientGameEnded
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      EndGameFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsWinner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientGameEnded");
		
		APlayerController_ClientGameEnded_Params params {};
		params.EndGameFocus = EndGameFocus;
		params.bIsWinner = bIsWinner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027455B0
	 * 		Name   -> Function Engine.PlayerController.ClientForceGarbageCollection
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientForceGarbageCollection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientForceGarbageCollection");
		
		APlayerController_ClientForceGarbageCollection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027455D0
	 * 		Name   -> Function Engine.PlayerController.ClientFlushLevelStreaming
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientFlushLevelStreaming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientFlushLevelStreaming");
		
		APlayerController_ClientFlushLevelStreaming_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027455F0
	 * 		Name   -> Function Engine.PlayerController.ClientEnableNetworkVoice
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientEnableNetworkVoice(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientEnableNetworkVoice");
		
		APlayerController_ClientEnableNetworkVoice_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027456F0
	 * 		Name   -> Function Engine.PlayerController.ClientCommitMapChange
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientCommitMapChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCommitMapChange");
		
		APlayerController_ClientCommitMapChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745710
	 * 		Name   -> Function Engine.PlayerController.ClientClearCameraLensEffects
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
	 */
	void APlayerController::ClientClearCameraLensEffects()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientClearCameraLensEffects");
		
		APlayerController_ClientClearCameraLensEffects_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745760
	 * 		Name   -> Function Engine.PlayerController.ClientCapBandwidth
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		int32_t                                            Cap                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientCapBandwidth(int32_t Cap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCapBandwidth");
		
		APlayerController_ClientCapBandwidth_Params params {};
		params.Cap = Cap;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745880
	 * 		Name   -> Function Engine.PlayerController.ClientCancelPendingMapChange
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void APlayerController::ClientCancelPendingMapChange()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientCancelPendingMapChange");
		
		APlayerController_ClientCancelPendingMapChange_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027458A0
	 * 		Name   -> Function Engine.PlayerController.ClientAddTextureStreamingLoc
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     InLoc                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOverrideLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ClientAddTextureStreamingLoc(const struct FVector& InLoc, float Duration, bool bOverrideLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClientAddTextureStreamingLoc");
		
		APlayerController_ClientAddTextureStreamingLoc_Params params {};
		params.InLoc = InLoc;
		params.Duration = Duration;
		params.bOverrideLocation = bOverrideLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745AB0
	 * 		Name   -> Function Engine.PlayerController.ClearAudioListenerOverride
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void APlayerController::ClearAudioListenerOverride()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ClearAudioListenerOverride");
		
		APlayerController_ClearAudioListenerOverride_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745AE0
	 * 		Name   -> Function Engine.PlayerController.Camera
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        NewMode                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::Camera(const class FName& NewMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.Camera");
		
		APlayerController_Camera_Params params {};
		params.NewMode = NewMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745C00
	 * 		Name   -> Function Engine.PlayerController.BPGetAimedUseActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AActor* APlayerController::BPGetAimedUseActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.BPGetAimedUseActor");
		
		APlayerController_BPGetAimedUseActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745C40
	 * 		Name   -> Function Engine.PlayerController.AddYawInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::AddYawInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddYawInput");
		
		APlayerController_AddYawInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745D60
	 * 		Name   -> Function Engine.PlayerController.AddRollInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::AddRollInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddRollInput");
		
		APlayerController_AddRollInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745E80
	 * 		Name   -> Function Engine.PlayerController.AddPitchInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::AddPitchInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.AddPitchInput");
		
		APlayerController_AddPitchInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02745FA0
	 * 		Name   -> Function Engine.PlayerController.ActivateTouchInterface
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTouchInterface*                             NewTouchInterface                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APlayerController::ActivateTouchInterface(class UTouchInterface* NewTouchInterface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerController.ActivateTouchInterface");
		
		APlayerController_ActivateTouchInterface_Params params {};
		params.NewTouchInterface = NewTouchInterface;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FF0
	 * 		Name   -> Function Engine.HUD.ShowHUD
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void AHUD::ShowHUD()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowHUD");
		
		AHUD_ShowHUD_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A050
	 * 		Name   -> Function Engine.HUD.ShowDebugToggleSubCategory
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        Category                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ShowDebugToggleSubCategory(const class FName& Category)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebugToggleSubCategory");
		
		AHUD_ShowDebugToggleSubCategory_Params params {};
		params.Category = Category;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A120
	 * 		Name   -> Function Engine.HUD.ShowDebug
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        DebugType                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ShowDebug(const class FName& DebugType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ShowDebug");
		
		AHUD_ShowDebug_Params params {};
		params.DebugType = DebugType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A1F0
	 * 		Name   -> Function Engine.HUD.RemoveDebugText
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLeaveDurationText                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveDebugText");
		
		AHUD_RemoveDebugText_Params params {};
		params.SrcActor = SrcActor;
		params.bLeaveDurationText = bLeaveDurationText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A3A0
	 * 		Name   -> Function Engine.HUD.RemoveAllDebugStrings
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void AHUD::RemoveAllDebugStrings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.RemoveAllDebugStrings");
		
		AHUD_RemoveAllDebugStrings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.HUD.ReceiveHitBoxRelease
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ReceiveHitBoxRelease(const class FName& BoxName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxRelease");
		
		AHUD_ReceiveHitBoxRelease_Params params {};
		params.BoxName = BoxName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.HUD.ReceiveHitBoxEndCursorOver
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ReceiveHitBoxEndCursorOver(const class FName& BoxName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxEndCursorOver");
		
		AHUD_ReceiveHitBoxEndCursorOver_Params params {};
		params.BoxName = BoxName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.HUD.ReceiveHitBoxClick
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ReceiveHitBoxClick(const class FName& BoxName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxClick");
		
		AHUD_ReceiveHitBoxClick_Params params {};
		params.BoxName = BoxName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.HUD.ReceiveHitBoxBeginCursorOver
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FName                                        BoxName                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ReceiveHitBoxBeginCursorOver(const class FName& BoxName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveHitBoxBeginCursorOver");
		
		AHUD_ReceiveHitBoxBeginCursorOver_Params params {};
		params.BoxName = BoxName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.HUD.ReceiveDrawHUD
	 * 		Flags  -> (BlueprintCosmetic, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		int32_t                                            SizeX                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            SizeY                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::ReceiveDrawHUD(int32_t SizeX, int32_t SizeY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.ReceiveDrawHUD");
		
		AHUD_ReceiveDrawHUD_Params params {};
		params.SizeX = SizeX;
		params.SizeY = SizeY;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A3D0
	 * 		Name   -> Function Engine.HUD.Project
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector AHUD::Project(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.Project");
		
		AHUD_Project_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A610
	 * 		Name   -> Function Engine.HUD.GetTextSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor)
	 * 		float                                              OutWidth                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutHeight                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::GetTextSize(const class FString& Text, float* OutWidth, float* OutHeight, class UFont* Font, float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetTextSize");
		
		AHUD_GetTextSize_Params params {};
		params.Text = Text;
		params.Font = Font;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutWidth != nullptr)
			*OutWidth = params.OutWidth;
		if (OutHeight != nullptr)
			*OutHeight = params.OutHeight;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E6E120
	 * 		Name   -> Function Engine.HUD.GetOwningPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APlayerController* AHUD::GetOwningPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPlayerController");
		
		AHUD_GetOwningPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A950
	 * 		Name   -> Function Engine.HUD.GetOwningPawn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* AHUD::GetOwningPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetOwningPawn");
		
		AHUD_GetOwningPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231A990
	 * 		Name   -> Function Engine.HUD.GetActorsInSelectionRectangle
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      ClassFilter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   FirstPoint                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   SecondPoint                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIncludeNonCollidingComponents                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bActorMustBeFullyEnclosed                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::GetActorsInSelectionRectangle(class UClass* ClassFilter, const struct FVector2D& FirstPoint, const struct FVector2D& SecondPoint, TArray<class AActor*>* OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.GetActorsInSelectionRectangle");
		
		AHUD_GetActorsInSelectionRectangle_Params params {};
		params.ClassFilter = ClassFilter;
		params.FirstPoint = FirstPoint;
		params.SecondPoint = SecondPoint;
		params.bIncludeNonCollidingComponents = bIncludeNonCollidingComponents;
		params.bActorMustBeFullyEnclosed = bActorMustBeFullyEnclosed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231AD00
	 * 		Name   -> Function Engine.HUD.DrawTextureSimple
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTextureSimple");
		
		AHUD_DrawTextureSimple_Params params {};
		params.Texture = Texture;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231AFF0
	 * 		Name   -> Function Engine.HUD.DrawTexture
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TextureU                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TextureV                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TextureUWidth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TextureVHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                TintColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		EBlendMode                                         BlendMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		struct FVector2D                                   RotPivot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void AHUD::DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, const struct FLinearColor& TintColor, EBlendMode BlendMode, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawTexture");
		
		AHUD_DrawTexture_Params params {};
		params.Texture = Texture;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.TextureU = TextureU;
		params.TextureV = TextureV;
		params.TextureUWidth = TextureUWidth;
		params.TextureVHeight = TextureVHeight;
		params.TintColor = TintColor;
		params.BlendMode = BlendMode;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		params.Rotation = Rotation;
		params.RotPivot = RotPivot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231B840
	 * 		Name   -> Function Engine.HUD.DrawText
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor)
	 * 		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UFont*                                       Font                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::DrawText(const class FString& Text, const struct FLinearColor& TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawText");
		
		AHUD_DrawText_Params params {};
		params.Text = Text;
		params.TextColor = TextColor;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.Font = Font;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231BC90
	 * 		Name   -> Function Engine.HUD.DrawRect
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                RectColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::DrawRect(const struct FLinearColor& RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawRect");
		
		AHUD_DrawRect_Params params {};
		params.RectColor = RectColor;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231BFA0
	 * 		Name   -> Function Engine.HUD.DrawMaterialSimple
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterialSimple");
		
		AHUD_DrawMaterialSimple_Params params {};
		params.Material = Material;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231C3B0
	 * 		Name   -> Function Engine.HUD.DrawMaterial
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenW                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenH                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaterialU                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaterialV                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaterialUWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaterialVHeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bScalePosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		struct FVector2D                                   RotPivot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void AHUD::DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, const struct FVector2D& RotPivot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawMaterial");
		
		AHUD_DrawMaterial_Params params {};
		params.Material = Material;
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		params.ScreenW = ScreenW;
		params.ScreenH = ScreenH;
		params.MaterialU = MaterialU;
		params.MaterialV = MaterialV;
		params.MaterialUWidth = MaterialUWidth;
		params.MaterialVHeight = MaterialVHeight;
		params.Scale = Scale;
		params.bScalePosition = bScalePosition;
		params.Rotation = Rotation;
		params.RotPivot = RotPivot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231CB00
	 * 		Name   -> Function Engine.HUD.DrawLine
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              StartScreenX                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StartScreenY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EndScreenX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EndScreenY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, const struct FLinearColor& LineColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.DrawLine");
		
		AHUD_DrawLine_Params params {};
		params.StartScreenX = StartScreenX;
		params.StartScreenY = StartScreenY;
		params.EndScreenX = EndScreenX;
		params.EndScreenY = EndScreenY;
		params.LineColor = LineColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231CE20
	 * 		Name   -> Function Engine.HUD.Deproject
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              ScreenX                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScreenY                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldPosition                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::Deproject(float ScreenX, float ScreenY, struct FVector* WorldPosition, struct FVector* WorldDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.Deproject");
		
		AHUD_Deproject_Params params {};
		params.ScreenX = ScreenX;
		params.ScreenY = ScreenY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WorldPosition != nullptr)
			*WorldPosition = params.WorldPosition;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231D060
	 * 		Name   -> Function Engine.HUD.AddHitBox
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bConsumesInput                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::AddHitBox(const struct FVector2D& Position, const struct FVector2D& Size, const class FName& InName, bool bConsumesInput, int32_t Priority)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddHitBox");
		
		AHUD_AddHitBox_Params params {};
		params.Position = Position;
		params.Size = Size;
		params.InName = InName;
		params.bConsumesInput = bConsumesInput;
		params.Priority = Priority;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231D360
	 * 		Name   -> Function Engine.HUD.AddDebugText
	 * 		Flags  -> (Final, Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		class FString                                      DebugText                                                  (Parm, ZeroConstructor)
	 * 		class AActor*                                      SrcActor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Offset                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     DesiredOffset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FColor                                      TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipOverwriteCheck                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAbsoluteLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bKeepAttachedToActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UFont*                                       InFont                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FontScale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AHUD::AddDebugText(const class FString& DebugText, class AActor* SrcActor, float Duration, const struct FVector& Offset, const struct FVector& DesiredOffset, const struct FColor& TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HUD.AddDebugText");
		
		AHUD_AddDebugText_Params params {};
		params.DebugText = DebugText;
		params.SrcActor = SrcActor;
		params.Duration = Duration;
		params.Offset = Offset;
		params.DesiredOffset = DesiredOffset;
		params.TextColor = TextColor;
		params.bSkipOverwriteCheck = bSkipOverwriteCheck;
		params.bAbsoluteLocation = bAbsoluteLocation;
		params.bKeepAttachedToActor = bKeepAttachedToActor;
		params.InFont = InFont;
		params.FontScale = FontScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.HUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Info");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027398B0
	 * 		Name   -> Function Engine.PlayerState.OnRep_UniqueId
	 * 		Flags  -> (Native, Public)
	 */
	void APlayerState::OnRep_UniqueId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_UniqueId");
		
		APlayerState_OnRep_UniqueId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027398F0
	 * 		Name   -> Function Engine.PlayerState.OnRep_Score
	 * 		Flags  -> (Native, Public)
	 */
	void APlayerState::OnRep_Score()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_Score");
		
		APlayerState_OnRep_Score_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319DF0
	 * 		Name   -> Function Engine.PlayerState.OnRep_PlayerName
	 * 		Flags  -> (Native, Public)
	 */
	void APlayerState::OnRep_PlayerName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_PlayerName");
		
		APlayerState_OnRep_PlayerName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FD0
	 * 		Name   -> Function Engine.PlayerState.OnRep_bIsInactive
	 * 		Flags  -> (Native, Public)
	 */
	void APlayerState::OnRep_bIsInactive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.OnRep_bIsInactive");
		
		APlayerState_OnRep_bIsInactive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739930
	 * 		Name   -> Function Engine.PlayerState.GetExactPing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 */
	float APlayerState::GetExactPing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerState.GetExactPing");
		
		APlayerState_GetExactPing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABrush.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABrush::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Brush");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748440
	 * 		Name   -> Function Engine.Volume.BPEncompassesPoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutDistanceToPoint                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AVolume::BPEncompassesPoint(const struct FVector& Point, float* OutDistanceToPoint, float SphereRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Volume.BPEncompassesPoint");
		
		AVolume_BPEncompassesPoint_Params params {};
		params.Point = Point;
		params.SphereRadius = SphereRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutDistanceToPoint != nullptr)
			*OutDistanceToPoint = params.OutDistanceToPoint;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Volume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.DestructibleActor.SetFadingStaticMesh
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UStaticMesh*                                 TheMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADestructibleActor::SetFadingStaticMesh(class UStaticMesh* TheMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleActor.SetFadingStaticMesh");
		
		ADestructibleActor_SetFadingStaticMesh_Params params {};
		params.TheMesh = TheMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.DestructibleActor.SetFadingSkeletalMesh
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class USkeletalMesh*                               TheMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADestructibleActor::SetFadingSkeletalMesh(class USkeletalMesh* TheMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleActor.SetFadingSkeletalMesh");
		
		ADestructibleActor_SetFadingSkeletalMesh_Params params {};
		params.TheMesh = TheMesh;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.DestructibleActor.GetFadingMeshComponent
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	class UMeshComponent* ADestructibleActor::GetFadingMeshComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleActor.GetFadingMeshComponent");
		
		ADestructibleActor_GetFadingMeshComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.DestructibleActor.ActorFractureSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     HitPoint                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void ADestructibleActor::ActorFractureSignature__DelegateSignature(const struct FVector& HitPoint, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleActor.ActorFractureSignature__DelegateSignature");
		
		ADestructibleActor_ActorFractureSignature__DelegateSignature_Params params {};
		params.HitPoint = HitPoint;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADestructibleActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADestructibleActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DestructibleActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DataAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738DB0
	 * 		Name   -> Function Engine.Light.ToggleEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void ALight::ToggleEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.ToggleEnabled");
		
		ALight_ToggleEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738E00
	 * 		Name   -> Function Engine.Light.SetLightFunctionScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLightFunctionScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionScale");
		
		ALight_SetLightFunctionScale_Params params {};
		params.NewLightFunctionScale = NewLightFunctionScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738F60
	 * 		Name   -> Function Engine.Light.SetLightFunctionMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          NewLightFunctionMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionMaterial");
		
		ALight_SetLightFunctionMaterial_Params params {};
		params.NewLightFunctionMaterial = NewLightFunctionMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739030
	 * 		Name   -> Function Engine.Light.SetLightFunctionFadeDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewLightFunctionFadeDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightFunctionFadeDistance");
		
		ALight_SetLightFunctionFadeDistance_Params params {};
		params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739100
	 * 		Name   -> Function Engine.Light.SetLightColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetLightColor(const struct FLinearColor& NewLightColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetLightColor");
		
		ALight_SetLightColor_Params params {};
		params.NewLightColor = NewLightColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739230
	 * 		Name   -> Function Engine.Light.SetEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bSetEnabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetEnabled(bool bSetEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetEnabled");
		
		ALight_SetEnabled_Params params {};
		params.bSetEnabled = bSetEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739320
	 * 		Name   -> Function Engine.Light.SetCastShadows
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetCastShadows(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetCastShadows");
		
		ALight_SetCastShadows_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739400
	 * 		Name   -> Function Engine.Light.SetBrightness
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetBrightness(float NewBrightness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetBrightness");
		
		ALight_SetBrightness_Params params {};
		params.NewBrightness = NewBrightness;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739520
	 * 		Name   -> Function Engine.Light.SetAffectTranslucentLighting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALight::SetAffectTranslucentLighting(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.SetAffectTranslucentLighting");
		
		ALight_SetAffectTranslucentLighting_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739600
	 * 		Name   -> Function Engine.Light.OnRep_bEnabled
	 * 		Flags  -> (Native, Public)
	 */
	void ALight::OnRep_bEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.OnRep_bEnabled");
		
		ALight_OnRep_bEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739660
	 * 		Name   -> Function Engine.Light.IsEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ALight::IsEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.IsEnabled");
		
		ALight_IsEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027396A0
	 * 		Name   -> Function Engine.Light.GetLightColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FLinearColor ALight::GetLightColor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.GetLightColor");
		
		ALight_GetLightColor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739760
	 * 		Name   -> Function Engine.Light.GetBrightness
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float ALight::GetBrightness()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Light.GetBrightness");
		
		ALight_GetBrightness_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Light");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FAE0
	 * 		Name   -> Function Engine.DamageType.HandleDamage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, Const)
	 * Parameters:
	 * 		class AActor*                                      Victim                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDamageEvent                                DamageEvent                                                (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UDamageType::HandleDamage(class AActor* Victim, float DamageAmount, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DamageType.HandleDamage");
		
		UDamageType_HandleDamage_Params params {};
		params.Victim = Victim;
		params.DamageAmount = DamageAmount;
		params.DamageEvent = DamageEvent;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDamageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDamageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DamageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlueprintFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlueprintFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlueprintFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANote.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANote::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Note");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASplineActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASplineActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SplineActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319520
	 * 		Name   -> Function Engine.Emitter.ToggleActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AEmitter::ToggleActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ToggleActive");
		
		AEmitter_ToggleActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319590
	 * 		Name   -> Function Engine.Emitter.SetVectorParameter
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetVectorParameter(const class FName& ParameterName, const struct FVector& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetVectorParameter");
		
		AEmitter_SetVectorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319710
	 * 		Name   -> Function Engine.Emitter.SetTemplate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             NewTemplate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetTemplate(class UParticleSystem* NewTemplate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetTemplate");
		
		AEmitter_SetTemplate_Params params {};
		params.NewTemplate = NewTemplate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319840
	 * 		Name   -> Function Engine.Emitter.SetMaterialParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetMaterialParameter(const class FName& ParameterName, class UMaterialInterface* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetMaterialParameter");
		
		AEmitter_SetMaterialParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023199A0
	 * 		Name   -> Function Engine.Emitter.SetFloatParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetFloatParameter(const class FName& ParameterName, float Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetFloatParameter");
		
		AEmitter_SetFloatParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319B10
	 * 		Name   -> Function Engine.Emitter.SetColorParameter
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetColorParameter(const class FName& ParameterName, const struct FLinearColor& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetColorParameter");
		
		AEmitter_SetColorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319C90
	 * 		Name   -> Function Engine.Emitter.SetActorParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::SetActorParameter(const class FName& ParameterName, class AActor* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.SetActorParameter");
		
		AEmitter_SetActorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Emitter.ParticleSpawnSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::ParticleSpawnSignature__DelegateSignature(const class FName& EventName, float EmitterTime, const struct FVector& Location, const struct FVector& Velocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ParticleSpawnSignature__DelegateSignature");
		
		AEmitter_ParticleSpawnSignature__DelegateSignature_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.Location = Location;
		params.Velocity = Velocity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Emitter.ParticleDeathSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ParticleTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::ParticleDeathSignature__DelegateSignature(const class FName& EventName, float EmitterTime, int32_t ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ParticleDeathSignature__DelegateSignature");
		
		AEmitter_ParticleDeathSignature__DelegateSignature_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.ParticleTime = ParticleTime;
		params.Location = Location;
		params.Velocity = Velocity;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Emitter.ParticleCollisionSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ParticleTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Velocity                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Normal                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::ParticleCollisionSignature__DelegateSignature(const class FName& EventName, float EmitterTime, int32_t ParticleTime, const struct FVector& Location, const struct FVector& Velocity, const struct FVector& Direction, const struct FVector& Normal, const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ParticleCollisionSignature__DelegateSignature");
		
		AEmitter_ParticleCollisionSignature__DelegateSignature_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.ParticleTime = ParticleTime;
		params.Location = Location;
		params.Velocity = Velocity;
		params.Direction = Direction;
		params.Normal = Normal;
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Emitter.ParticleBurstSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              EmitterTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ParticleCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::ParticleBurstSignature__DelegateSignature(const class FName& EventName, float EmitterTime, int32_t ParticleCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.ParticleBurstSignature__DelegateSignature");
		
		AEmitter_ParticleBurstSignature__DelegateSignature_Params params {};
		params.EventName = EventName;
		params.EmitterTime = EmitterTime;
		params.ParticleCount = ParticleCount;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319DF0
	 * 		Name   -> Function Engine.Emitter.OnRep_bCurrentlyActive
	 * 		Flags  -> (Native, Public)
	 */
	void AEmitter::OnRep_bCurrentlyActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnRep_bCurrentlyActive");
		
		AEmitter_OnRep_bCurrentlyActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319E10
	 * 		Name   -> Function Engine.Emitter.OnParticleSystemFinished
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    FinishedComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void AEmitter::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.OnParticleSystemFinished");
		
		AEmitter_OnParticleSystemFinished_Params params {};
		params.FinishedComponent = FinishedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319F30
	 * 		Name   -> Function Engine.Emitter.IsActive
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool AEmitter::IsActive()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.IsActive");
		
		AEmitter_IsActive_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FB0
	 * 		Name   -> Function Engine.Emitter.Deactivate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AEmitter::Deactivate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Deactivate");
		
		AEmitter_Deactivate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FD0
	 * 		Name   -> Function Engine.Emitter.Activate
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AEmitter::Activate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Emitter.Activate");
		
		AEmitter_Activate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Emitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E6B460
	 * 		Name   -> Function Engine.Pawn.SpawnDefaultController
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void APawn::SpawnDefaultController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SpawnDefaultController");
		
		APawn_SpawnDefaultController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736FC0
	 * 		Name   -> Function Engine.Pawn.SetMovementTether
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InTetherActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::SetMovementTether(class AActor* InTetherActor, float Radius, float Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SetMovementTether");
		
		APawn_SetMovementTether_Params params {};
		params.InTetherActor = InTetherActor;
		params.Radius = Radius;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027371A0
	 * 		Name   -> Function Engine.Pawn.SetCanAffectNavigationGeneration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::SetCanAffectNavigationGeneration(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.SetCanAffectNavigationGeneration");
		
		APawn_SetCanAffectNavigationGeneration_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Pawn.ReceiveUnpossessed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 OldController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::ReceiveUnpossessed(class AController* OldController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceiveUnpossessed");
		
		APawn_ReceiveUnpossessed_Params params {};
		params.OldController = OldController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Pawn.ReceivePossessed
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 NewController                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::ReceivePossessed(class AController* NewController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ReceivePossessed");
		
		APawn_ReceivePossessed_Params params {};
		params.NewController = NewController;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027372B0
	 * 		Name   -> Function Engine.Pawn.PawnMakeNoise
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NoiseLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUseNoiseMakerLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      NoiseMaker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::PawnMakeNoise(float Loudness, const struct FVector& NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.PawnMakeNoise");
		
		APawn_PawnMakeNoise_Params params {};
		params.Loudness = Loudness;
		params.NoiseLocation = NoiseLocation;
		params.bUseNoiseMakerLocation = bUseNoiseMakerLocation;
		params.NoiseMaker = NoiseMaker;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737540
	 * 		Name   -> Function Engine.Pawn.OnRep_PlayerState
	 * 		Flags  -> (Native, Public)
	 */
	void APawn::OnRep_PlayerState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_PlayerState");
		
		APawn_OnRep_PlayerState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737560
	 * 		Name   -> Function Engine.Pawn.OnRep_Controller
	 * 		Flags  -> (Native, Public)
	 */
	void APawn::OnRep_Controller()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.OnRep_Controller");
		
		APawn_OnRep_Controller_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Pawn.MovementTetherEvent__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      TetherObject                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::MovementTetherEvent__DelegateSignature(class APawn* Pawn, class AActor* TetherObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.MovementTetherEvent__DelegateSignature");
		
		APawn_MovementTetherEvent__DelegateSignature_Params params {};
		params.Pawn = Pawn;
		params.TetherObject = TetherObject;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737580
	 * 		Name   -> Function Engine.Pawn.LaunchPawn
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::LaunchPawn(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.LaunchPawn");
		
		APawn_LaunchPawn_Params params {};
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027377A0
	 * 		Name   -> Function Engine.Pawn.K2_GetMovementInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector APawn::K2_GetMovementInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.K2_GetMovementInputVector");
		
		APawn_K2_GetMovementInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027377D0
	 * 		Name   -> Function Engine.Pawn.IsWithinTether
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsWithinTether()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsWithinTether");
		
		APawn_IsWithinTether_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737800
	 * 		Name   -> Function Engine.Pawn.IsWalking
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsWalking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsWalking");
		
		APawn_IsWalking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737890
	 * 		Name   -> Function Engine.Pawn.IsTargetWithinTether
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              AdditionalRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool APawn::IsTargetWithinTether(const struct FVector& Destination, float AdditionalRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsTargetWithinTether");
		
		APawn_IsTargetWithinTether_Params params {};
		params.Destination = Destination;
		params.AdditionalRadius = AdditionalRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F0B070
	 * 		Name   -> Function Engine.Pawn.IsMovementTethered
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsMovementTethered()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsMovementTethered");
		
		APawn_IsMovementTethered_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027379F0
	 * 		Name   -> Function Engine.Pawn.IsMoveInputIgnored
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsMoveInputIgnored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsMoveInputIgnored");
		
		APawn_IsMoveInputIgnored_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737A70
	 * 		Name   -> Function Engine.Pawn.IsLocallyControlled
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsLocallyControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsLocallyControlled");
		
		APawn_IsLocallyControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737AE0
	 * 		Name   -> Function Engine.Pawn.IsFalling
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsFalling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsFalling");
		
		APawn_IsFalling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737B70
	 * 		Name   -> Function Engine.Pawn.IsCrouched
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsCrouched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsCrouched");
		
		APawn_IsCrouched_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737C00
	 * 		Name   -> Function Engine.Pawn.IsControlled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool APawn::IsControlled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.IsControlled");
		
		APawn_IsControlled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737C50
	 * 		Name   -> Function Engine.Pawn.InterceptInputEvent
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class FString                                      InputName                                                  (Parm, ZeroConstructor)
	 */
	void APawn::InterceptInputEvent(const class FString& InputName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.InterceptInputEvent");
		
		APawn_InterceptInputEvent_Params params {};
		params.InputName = InputName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737D60
	 * 		Name   -> Function Engine.Pawn.GetTetherObject
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AActor* APawn::GetTetherObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetTetherObject");
		
		APawn_GetTetherObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737D90
	 * 		Name   -> Function Engine.Pawn.GetTetheredVelocity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     RequestedVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector APawn::GetTetheredVelocity(const struct FVector& RequestedVelocity, float DeltaSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetTetheredVelocity");
		
		APawn_GetTetheredVelocity_Params params {};
		params.RequestedVelocity = RequestedVelocity;
		params.DeltaSeconds = DeltaSeconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02737F40
	 * 		Name   -> Function Engine.Pawn.GetTetheredDestination
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              AdditionalRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector APawn::GetTetheredDestination(const struct FVector& Destination, float AdditionalRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetTetheredDestination");
		
		APawn_GetTetheredDestination_Params params {};
		params.Destination = Destination;
		params.AdditionalRadius = AdditionalRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027377A0
	 * 		Name   -> Function Engine.Pawn.GetPendingMovementInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector APawn::GetPendingMovementInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetPendingMovementInputVector");
		
		APawn_GetPendingMovementInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027380F0
	 * 		Name   -> Function Engine.Pawn.GetNavAgentLocation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector APawn::GetNavAgentLocation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetNavAgentLocation");
		
		APawn_GetNavAgentLocation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738140
	 * 		Name   -> Function Engine.Pawn.GetMovementComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPawnMovementComponent* APawn::GetMovementComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementComponent");
		
		APawn_GetMovementComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738170
	 * 		Name   -> Function Engine.Pawn.GetMovementBaseActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class APawn*                                       Pawn                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AActor* APawn::STATIC_GetMovementBaseActor(class APawn* Pawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetMovementBaseActor");
		
		APawn_GetMovementBaseActor_Params params {};
		params.Pawn = Pawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738280
	 * 		Name   -> Function Engine.Pawn.GetLastMovementInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector APawn::GetLastMovementInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetLastMovementInputVector");
		
		APawn_GetLastMovementInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027382B0
	 * 		Name   -> Function Engine.Pawn.GetControlRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator APawn::GetControlRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetControlRotation");
		
		APawn_GetControlRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738320
	 * 		Name   -> Function Engine.Pawn.GetController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class AController* APawn::GetController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetController");
		
		APawn_GetController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738340
	 * 		Name   -> Function Engine.Pawn.GetBaseAimRotation
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator APawn::GetBaseAimRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.GetBaseAimRotation");
		
		APawn_GetBaseAimRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738380
	 * 		Name   -> Function Engine.Pawn.DetachFromControllerPendingDestroy
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void APawn::DetachFromControllerPendingDestroy()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.DetachFromControllerPendingDestroy");
		
		APawn_DetachFromControllerPendingDestroy_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738410
	 * 		Name   -> Function Engine.Pawn.ConsumeMovementInputVector
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector APawn::ConsumeMovementInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ConsumeMovementInputVector");
		
		APawn_ConsumeMovementInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027384B0
	 * 		Name   -> Function Engine.Pawn.ClearMovementTether
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void APawn::ClearMovementTether()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.ClearMovementTether");
		
		APawn_ClearMovementTether_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738500
	 * 		Name   -> Function Engine.Pawn.AddMovementInput
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     WorldDirection                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScaleValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::AddMovementInput(const struct FVector& WorldDirection, float ScaleValue, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddMovementInput");
		
		APawn_AddMovementInput_Params params {};
		params.WorldDirection = WorldDirection;
		params.ScaleValue = ScaleValue;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027386F0
	 * 		Name   -> Function Engine.Pawn.AddControllerYawInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::AddControllerYawInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerYawInput");
		
		APawn_AddControllerYawInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738820
	 * 		Name   -> Function Engine.Pawn.AddControllerRollInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::AddControllerRollInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerRollInput");
		
		APawn_AddControllerRollInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738950
	 * 		Name   -> Function Engine.Pawn.AddControllerPitchInput
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APawn::AddControllerPitchInput(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Pawn.AddControllerPitchInput");
		
		APawn_AddControllerPitchInput_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Pawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E9A0
	 * 		Name   -> Function Engine.Character.UnProne
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::UnProne(bool bClientSimulation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.UnProne");
		
		ACharacter_UnProne_Params params {};
		params.bClientSimulation = bClientSimulation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231EAC0
	 * 		Name   -> Function Engine.Character.UnCrouch
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::UnCrouch(bool bClientSimulation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.UnCrouch");
		
		ACharacter_UnCrouch_Params params {};
		params.bClientSimulation = bClientSimulation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231EBE0
	 * 		Name   -> Function Engine.Character.StopJumping
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ACharacter::StopJumping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.StopJumping");
		
		ACharacter_StopJumping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231EC30
	 * 		Name   -> Function Engine.Character.StopAnimMontage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::StopAnimMontage(class UAnimMontage* AnimMontage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.StopAnimMontage");
		
		ACharacter_StopAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231ED00
	 * 		Name   -> Function Engine.Character.ShouldForceDedicatedMovementTickEveryFrame
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ACharacter::ShouldForceDedicatedMovementTickEveryFrame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.ShouldForceDedicatedMovementTickEveryFrame");
		
		ACharacter_ShouldForceDedicatedMovementTickEveryFrame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231ED30
	 * 		Name   -> Function Engine.Character.ReplicateMovementToSimulatedClients
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	bool ACharacter::ReplicateMovementToSimulatedClients()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.ReplicateMovementToSimulatedClients");
		
		ACharacter_ReplicateMovementToSimulatedClients_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231ED80
	 * 		Name   -> Function Engine.Character.Prone
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::Prone(bool bClientSimulation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.Prone");
		
		ACharacter_Prone_Params params {};
		params.bClientSimulation = bClientSimulation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231EEC0
	 * 		Name   -> Function Engine.Character.PlayAnimMontage
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimMontage*                                AnimMontage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        StartSectionName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceTickPoseAndServerUpdateMesh                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceTickPoseOnServer                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendInTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendOutTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float ACharacter::PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, const class FName& StartSectionName, bool bForceTickPoseAndServerUpdateMesh, bool bForceTickPoseOnServer, float BlendInTime, float BlendOutTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.PlayAnimMontage");
		
		ACharacter_PlayAnimMontage_Params params {};
		params.AnimMontage = AnimMontage;
		params.InPlayRate = InPlayRate;
		params.StartSectionName = StartSectionName;
		params.bForceTickPoseAndServerUpdateMesh = bForceTickPoseAndServerUpdateMesh;
		params.bForceTickPoseOnServer = bForceTickPoseOnServer;
		params.BlendInTime = BlendInTime;
		params.BlendOutTime = BlendOutTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F2C0
	 * 		Name   -> Function Engine.Character.OverrideTerminalVelocity
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	float ACharacter::OverrideTerminalVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OverrideTerminalVelocity");
		
		ACharacter_OverrideTerminalVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F300
	 * 		Name   -> Function Engine.Character.OnWalkingOffLedge
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void ACharacter::OnWalkingOffLedge()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnWalkingOffLedge");
		
		ACharacter_OnWalkingOffLedge_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F340
	 * 		Name   -> Function Engine.Character.OnRep_RootMotion
	 * 		Flags  -> (Final, Native, Public)
	 */
	void ACharacter::OnRep_RootMotion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_RootMotion");
		
		ACharacter_OnRep_RootMotion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F360
	 * 		Name   -> Function Engine.Character.OnRep_ReplicatedBasedMovement
	 * 		Flags  -> (Native, Public)
	 */
	void ACharacter::OnRep_ReplicatedBasedMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_ReplicatedBasedMovement");
		
		ACharacter_OnRep_ReplicatedBasedMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F380
	 * 		Name   -> Function Engine.Character.OnRep_IsProne
	 * 		Flags  -> (Native, Public)
	 */
	void ACharacter::OnRep_IsProne()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsProne");
		
		ACharacter_OnRep_IsProne_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F400
	 * 		Name   -> Function Engine.Character.OnRep_IsCrouched
	 * 		Flags  -> (Native, Public)
	 */
	void ACharacter::OnRep_IsCrouched()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnRep_IsCrouched");
		
		ACharacter_OnRep_IsCrouched_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.OnLaunched
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::OnLaunched(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLaunched");
		
		ACharacter_OnLaunched_Params params {};
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.OnLanded
	 * 		Flags  -> (Event, Public, HasOutParms, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void ACharacter::OnLanded(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnLanded");
		
		ACharacter_OnLanded_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F480
	 * 		Name   -> Function Engine.Character.OnJumped
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void ACharacter::OnJumped()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.OnJumped");
		
		ACharacter_OnJumped_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F4A0
	 * 		Name   -> Function Engine.Character.NetTeleportSucceeded
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     ToLoc                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    ToRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::NetTeleportSucceeded(const struct FVector& ToLoc, const struct FRotator& ToRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.NetTeleportSucceeded");
		
		ACharacter_NetTeleportSucceeded_Params params {};
		params.ToLoc = ToLoc;
		params.ToRot = ToRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.MovementModeChangedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class ACharacter*                                  Character                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EMovementMode                                      PrevMovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      PreviousCustomMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::MovementModeChangedSignature__DelegateSignature(class ACharacter* Character, EMovementMode PrevMovementMode, unsigned char PreviousCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.MovementModeChangedSignature__DelegateSignature");
		
		ACharacter_MovementModeChangedSignature__DelegateSignature_Params params {};
		params.Character = Character;
		params.PrevMovementMode = PrevMovementMode;
		params.PreviousCustomMode = PreviousCustomMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F610
	 * 		Name   -> Function Engine.Character.LaunchCharacter
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     LaunchVelocity                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bXYOverride                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bZOverride                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::LaunchCharacter(const struct FVector& LaunchVelocity, bool bXYOverride, bool bZOverride)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.LaunchCharacter");
		
		ACharacter_LaunchCharacter_Params params {};
		params.LaunchVelocity = LaunchVelocity;
		params.bXYOverride = bXYOverride;
		params.bZOverride = bZOverride;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.K2_UpdateCustomMovement
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::K2_UpdateCustomMovement(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_UpdateCustomMovement");
		
		ACharacter_K2_UpdateCustomMovement_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.K2_OnStartCrouch
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              HalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScaledHalfHeightAdjust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnStartCrouch");
		
		ACharacter_K2_OnStartCrouch_Params params {};
		params.HalfHeightAdjust = HalfHeightAdjust;
		params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.K2_OnMovementModeChanged
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		EMovementMode                                      PrevMovementMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EMovementMode                                      NewMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      PrevCustomMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      NewCustomMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::K2_OnMovementModeChanged(EMovementMode PrevMovementMode, EMovementMode NewMovementMode, unsigned char PrevCustomMode, unsigned char NewCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnMovementModeChanged");
		
		ACharacter_K2_OnMovementModeChanged_Params params {};
		params.PrevMovementMode = PrevMovementMode;
		params.NewMovementMode = NewMovementMode;
		params.PrevCustomMode = PrevCustomMode;
		params.NewCustomMode = NewCustomMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.K2_OnEndCrouch
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              HalfHeightAdjust                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScaledHalfHeightAdjust                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.K2_OnEndCrouch");
		
		ACharacter_K2_OnEndCrouch_Params params {};
		params.HalfHeightAdjust = HalfHeightAdjust;
		params.ScaledHalfHeightAdjust = ScaledHalfHeightAdjust;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F810
	 * 		Name   -> Function Engine.Character.Jump
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ACharacter::Jump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.Jump");
		
		ACharacter_Jump_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F860
	 * 		Name   -> Function Engine.Character.IsRagdolled
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	bool ACharacter::IsRagdolled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.IsRagdolled");
		
		ACharacter_IsRagdolled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F890
	 * 		Name   -> Function Engine.Character.IsPlayingRootMotion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ACharacter::IsPlayingRootMotion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.IsPlayingRootMotion");
		
		ACharacter_IsPlayingRootMotion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F8E0
	 * 		Name   -> Function Engine.Character.IsJumpProvidingForce
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ACharacter::IsJumpProvidingForce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.IsJumpProvidingForce");
		
		ACharacter_IsJumpProvidingForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F930
	 * 		Name   -> Function Engine.Character.GetLastMovementDesiredRotation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FRotator ACharacter::GetLastMovementDesiredRotation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.GetLastMovementDesiredRotation");
		
		ACharacter_GetLastMovementDesiredRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F960
	 * 		Name   -> Function Engine.Character.GetCurrentMontage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UAnimMontage* ACharacter::GetCurrentMontage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.GetCurrentMontage");
		
		ACharacter_GetCurrentMontage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231F990
	 * 		Name   -> Function Engine.Character.Crouch
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bClientSimulation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::Crouch(bool bClientSimulation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.Crouch");
		
		ACharacter_Crouch_Params params {};
		params.bClientSimulation = bClientSimulation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FAD0
	 * 		Name   -> Function Engine.Character.ClientCheatWalk
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void ACharacter::ClientCheatWalk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatWalk");
		
		ACharacter_ClientCheatWalk_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FAF0
	 * 		Name   -> Function Engine.Character.ClientCheatGhost
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void ACharacter::ClientCheatGhost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatGhost");
		
		ACharacter_ClientCheatGhost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FB80
	 * 		Name   -> Function Engine.Character.ClientCheatFly
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetClient)
	 */
	void ACharacter::ClientCheatFly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.ClientCheatFly");
		
		ACharacter_ClientCheatFly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.CharacterMovementUpdatedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		float                                              DeltaSeconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OldLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OldVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ACharacter::CharacterMovementUpdatedSignature__DelegateSignature(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.CharacterMovementUpdatedSignature__DelegateSignature");
		
		ACharacter_CharacterMovementUpdatedSignature__DelegateSignature_Params params {};
		params.DeltaSeconds = DeltaSeconds;
		params.OldLocation = OldLocation;
		params.OldVelocity = OldVelocity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F6FA00
	 * 		Name   -> Function Engine.Character.CanJumpInternal
	 * 		Flags  -> (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 */
	bool ACharacter::CanJumpInternal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJumpInternal");
		
		ACharacter_CanJumpInternal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FBA0
	 * 		Name   -> Function Engine.Character.CanJump
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ACharacter::CanJump()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.CanJump");
		
		ACharacter_CanJump_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FC10
	 * 		Name   -> Function Engine.Character.BPOverrideCharacterSound
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class USoundBase*                                  SoundIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class USoundBase* ACharacter::BPOverrideCharacterSound(class USoundBase* SoundIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.BPOverrideCharacterSound");
		
		ACharacter_BPOverrideCharacterSound_Params params {};
		params.SoundIn = SoundIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FD60
	 * 		Name   -> Function Engine.Character.BPOverrideCharacterParticle
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UParticleSystem*                             ParticleIn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UParticleSystem* ACharacter::BPOverrideCharacterParticle(class UParticleSystem* ParticleIn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.BPOverrideCharacterParticle");
		
		ACharacter_BPOverrideCharacterParticle_Params params {};
		params.ParticleIn = ParticleIn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FEB0
	 * 		Name   -> Function Engine.Character.BPModifyRootMotionDeltaRotation
	 * 		Flags  -> (Native, Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FRotator                                    Delta                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator ACharacter::BPModifyRootMotionDeltaRotation(const struct FRotator& Delta)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.BPModifyRootMotionDeltaRotation");
		
		ACharacter_BPModifyRootMotionDeltaRotation_Params params {};
		params.Delta = Delta;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.BPAcknowledgeServerCorrection
	 * 		Flags  -> (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool ACharacter::BPAcknowledgeServerCorrection(float TimeStamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, const class FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.BPAcknowledgeServerCorrection");
		
		ACharacter_BPAcknowledgeServerCorrection_Params params {};
		params.TimeStamp = TimeStamp;
		params.NewLoc = NewLoc;
		params.NewVel = NewVel;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.Character.BP_PreventMovementMode
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		EMovementMode                                      NewMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      NewCustomMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool ACharacter::BP_PreventMovementMode(EMovementMode NewMovementMode, unsigned char NewCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Character.BP_PreventMovementMode");
		
		ACharacter_BP_PreventMovementMode_Params params {};
		params.NewMovementMode = NewMovementMode;
		params.NewCustomMode = NewCustomMode;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACharacter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACharacter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Character");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReverbVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReverbVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReverbVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027397A0
	 * 		Name   -> Function Engine.WorldSettings.PooledParticleSystemFinished
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    FinishedComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void AWorldSettings::PooledParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WorldSettings.PooledParticleSystemFinished");
		
		AWorldSettings_PooledParticleSystemFinished_Params params {};
		params.FinishedComponent = FinishedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWorldSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWorldSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WorldSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320950
	 * 		Name   -> Function Engine.MovementComponent.StopMovementImmediately
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UMovementComponent::StopMovementImmediately()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.StopMovementImmediately");
		
		UMovementComponent_StopMovementImmediately_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320970
	 * 		Name   -> Function Engine.MovementComponent.SnapUpdatedComponentToPlane
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UMovementComponent::SnapUpdatedComponentToPlane()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SnapUpdatedComponentToPlane");
		
		UMovementComponent_SnapUpdatedComponentToPlane_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320990
	 * 		Name   -> Function Engine.MovementComponent.ShouldForceDedicatedTickEveryFrame
	 * 		Flags  -> (Native, Protected, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UMovementComponent::ShouldForceDedicatedTickEveryFrame()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ShouldForceDedicatedTickEveryFrame");
		
		UMovementComponent_ShouldForceDedicatedTickEveryFrame_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023209C0
	 * 		Name   -> Function Engine.MovementComponent.SetUpdatedComponent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         NewUpdatedComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UMovementComponent::SetUpdatedComponent(class UPrimitiveComponent* NewUpdatedComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetUpdatedComponent");
		
		UMovementComponent_SetUpdatedComponent_Params params {};
		params.NewUpdatedComponent = NewUpdatedComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320A90
	 * 		Name   -> Function Engine.MovementComponent.SetPlaneConstraintOrigin
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     PlaneOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMovementComponent::SetPlaneConstraintOrigin(const struct FVector& PlaneOrigin)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintOrigin");
		
		UMovementComponent_SetPlaneConstraintOrigin_Params params {};
		params.PlaneOrigin = PlaneOrigin;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320B90
	 * 		Name   -> Function Engine.MovementComponent.SetPlaneConstraintNormal
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMovementComponent::SetPlaneConstraintNormal(const struct FVector& PlaneNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintNormal");
		
		UMovementComponent_SetPlaneConstraintNormal_Params params {};
		params.PlaneNormal = PlaneNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320C70
	 * 		Name   -> Function Engine.MovementComponent.SetPlaneConstraintFromVectors
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Forward                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Up                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMovementComponent::SetPlaneConstraintFromVectors(const struct FVector& Forward, const struct FVector& Up)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.SetPlaneConstraintFromVectors");
		
		UMovementComponent_SetPlaneConstraintFromVectors_Params params {};
		params.Forward = Forward;
		params.Up = Up;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320DE0
	 * 		Name   -> Function Engine.MovementComponent.PhysicsVolumeChanged
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class APhysicsVolume*                              NewVolume                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMovementComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.PhysicsVolumeChanged");
		
		UMovementComponent_PhysicsVolumeChanged_Params params {};
		params.NewVolume = NewVolume;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320EB0
	 * 		Name   -> Function Engine.MovementComponent.K2_MoveUpdatedComponent
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Delta                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UMovementComponent::K2_MoveUpdatedComponent(const struct FVector& Delta, const struct FRotator& NewRotation, struct FHitResult* OutHit, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_MoveUpdatedComponent");
		
		UMovementComponent_K2_MoveUpdatedComponent_Params params {};
		params.Delta = Delta;
		params.NewRotation = NewRotation;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321150
	 * 		Name   -> Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UMovementComponent::K2_GetModifiedMaxSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetModifiedMaxSpeed");
		
		UMovementComponent_K2_GetModifiedMaxSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023211C0
	 * 		Name   -> Function Engine.MovementComponent.K2_GetMaxSpeedModifier
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UMovementComponent::K2_GetMaxSpeedModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.K2_GetMaxSpeedModifier");
		
		UMovementComponent_K2_GetMaxSpeedModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321240
	 * 		Name   -> Function Engine.MovementComponent.IsExceedingMaxSpeed
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              MaxSpeed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UMovementComponent::IsExceedingMaxSpeed(float MaxSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.IsExceedingMaxSpeed");
		
		UMovementComponent_IsExceedingMaxSpeed_Params params {};
		params.MaxSpeed = MaxSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321380
	 * 		Name   -> Function Engine.MovementComponent.GetPlaneConstraintOrigin
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UMovementComponent::GetPlaneConstraintOrigin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintOrigin");
		
		UMovementComponent_GetPlaneConstraintOrigin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023213B0
	 * 		Name   -> Function Engine.MovementComponent.GetPlaneConstraintNormal
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UMovementComponent::GetPlaneConstraintNormal()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPlaneConstraintNormal");
		
		UMovementComponent_GetPlaneConstraintNormal_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023213E0
	 * 		Name   -> Function Engine.MovementComponent.GetPhysicsVolume
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APhysicsVolume* UMovementComponent::GetPhysicsVolume()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetPhysicsVolume");
		
		UMovementComponent_GetPhysicsVolume_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321490
	 * 		Name   -> Function Engine.MovementComponent.GetMaxSpeed
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UMovementComponent::GetMaxSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetMaxSpeed");
		
		UMovementComponent_GetMaxSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023214D0
	 * 		Name   -> Function Engine.MovementComponent.GetGravityZ
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UMovementComponent::GetGravityZ()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.GetGravityZ");
		
		UMovementComponent_GetGravityZ_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321510
	 * 		Name   -> Function Engine.MovementComponent.ConstrainLocationToPlane
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UMovementComponent::ConstrainLocationToPlane(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainLocationToPlane");
		
		UMovementComponent_ConstrainLocationToPlane_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321610
	 * 		Name   -> Function Engine.MovementComponent.ConstrainDirectionToPlane
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UMovementComponent::ConstrainDirectionToPlane(const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MovementComponent.ConstrainDirectionToPlane");
		
		UMovementComponent_ConstrainDirectionToPlane_Params params {};
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321710
	 * 		Name   -> Function Engine.NavMovementComponent.StopMovementKeepPathing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UNavMovementComponent::StopMovementKeepPathing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopMovementKeepPathing");
		
		UNavMovementComponent_StopMovementKeepPathing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E9F030
	 * 		Name   -> Function Engine.NavMovementComponent.StopActiveMovement
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UNavMovementComponent::StopActiveMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.StopActiveMovement");
		
		UNavMovementComponent_StopActiveMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321780
	 * 		Name   -> Function Engine.NavMovementComponent.IsSwimming
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavMovementComponent::IsSwimming()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsSwimming");
		
		UNavMovementComponent_IsSwimming_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023217B0
	 * 		Name   -> Function Engine.NavMovementComponent.IsMovingOnGround
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavMovementComponent::IsMovingOnGround()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsMovingOnGround");
		
		UNavMovementComponent_IsMovingOnGround_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023217E0
	 * 		Name   -> Function Engine.NavMovementComponent.IsFlying
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavMovementComponent::IsFlying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFlying");
		
		UNavMovementComponent_IsFlying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321810
	 * 		Name   -> Function Engine.NavMovementComponent.IsFalling
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavMovementComponent::IsFalling()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsFalling");
		
		UNavMovementComponent_IsFalling_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321840
	 * 		Name   -> Function Engine.NavMovementComponent.IsCrouching
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavMovementComponent::IsCrouching()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavMovementComponent.IsCrouching");
		
		UNavMovementComponent_IsCrouching_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321870
	 * 		Name   -> Function Engine.PawnMovementComponent.K2_GetInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UPawnMovementComponent::K2_GetInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.K2_GetInputVector");
		
		UPawnMovementComponent_K2_GetInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023218E0
	 * 		Name   -> Function Engine.PawnMovementComponent.IsMoveInputIgnored
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UPawnMovementComponent::IsMoveInputIgnored()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.IsMoveInputIgnored");
		
		UPawnMovementComponent_IsMoveInputIgnored_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321870
	 * 		Name   -> Function Engine.PawnMovementComponent.GetPendingInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UPawnMovementComponent::GetPendingInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPendingInputVector");
		
		UPawnMovementComponent_GetPendingInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321910
	 * 		Name   -> Function Engine.PawnMovementComponent.GetPawnOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APawn* UPawnMovementComponent::GetPawnOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetPawnOwner");
		
		UPawnMovementComponent_GetPawnOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321930
	 * 		Name   -> Function Engine.PawnMovementComponent.GetLastInputVector
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UPawnMovementComponent::GetLastInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.GetLastInputVector");
		
		UPawnMovementComponent_GetLastInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023219A0
	 * 		Name   -> Function Engine.PawnMovementComponent.ConsumeInputVector
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector UPawnMovementComponent::ConsumeInputVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.ConsumeInputVector");
		
		UPawnMovementComponent_ConsumeInputVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023219E0
	 * 		Name   -> Function Engine.PawnMovementComponent.AddInputVector
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     WorldVector                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForce                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPawnMovementComponent::AddInputVector(const struct FVector& WorldVector, bool bForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnMovementComponent.AddInputVector");
		
		UPawnMovementComponent_AddInputVector_Params params {};
		params.WorldVector = WorldVector;
		params.bForce = bForce;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPawnMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPawnMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PawnMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321B90
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetWalkableFloorZ
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InWalkableFloorZ                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorZ");
		
		UCharacterMovementComponent_SetWalkableFloorZ_Params params {};
		params.InWalkableFloorZ = InWalkableFloorZ;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321CA0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InWalkableFloorAngle                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetWalkableFloorAngle");
		
		UCharacterMovementComponent_SetWalkableFloorAngle_Params params {};
		params.InWalkableFloorAngle = InWalkableFloorAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321DA0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetMovementMode
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EMovementMode                                      NewMovementMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      NewCustomMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetMovementMode(EMovementMode NewMovementMode, unsigned char NewCustomMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetMovementMode");
		
		UCharacterMovementComponent_SetMovementMode_Params params {};
		params.NewMovementMode = NewMovementMode;
		params.NewCustomMode = NewCustomMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E8ADB0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetGroupsToIgnore
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetGroupsToIgnore(int32_t GroupFlags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToIgnore");
		
		UCharacterMovementComponent_SetGroupsToIgnore_Params params {};
		params.GroupFlags = GroupFlags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E8ADB0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetGroupsToAvoid
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetGroupsToAvoid(int32_t GroupFlags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetGroupsToAvoid");
		
		UCharacterMovementComponent_SetGroupsToAvoid_Params params {};
		params.GroupFlags = GroupFlags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02321F00
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetBase
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNotifyActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetBase(class UPrimitiveComponent* NewBase, const class FName& BoneName, bool bNotifyActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetBase");
		
		UCharacterMovementComponent_SetBase_Params params {};
		params.NewBase = NewBase;
		params.BoneName = BoneName;
		params.bNotifyActor = bNotifyActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E8ADB0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetAvoidanceGroup
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            GroupFlags                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetAvoidanceGroup(int32_t GroupFlags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceGroup");
		
		UCharacterMovementComponent_SetAvoidanceGroup_Params params {};
		params.GroupFlags = GroupFlags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E8ADB0
	 * 		Name   -> Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::SetAvoidanceEnabled(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.SetAvoidanceEnabled");
		
		UCharacterMovementComponent_SetAvoidanceEnabled_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02322120
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveWithRotation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel                                                    (Parm)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
	 * 		unsigned char                                      CompressedMoveFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    ClientRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveWithRotation(float TimeStamp, const struct FVector_NetQuantize100& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode, const struct FRotator& ClientRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveWithRotation");
		
		UCharacterMovementComponent_ServerMoveWithRotation_Params params {};
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.CompressedMoveFlags = CompressedMoveFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		params.ClientRotation = ClientRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02322780
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveOnlyRotation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveOnlyRotation(float TimeStamp, unsigned char ClientRoll, uint32_t View)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveOnlyRotation");
		
		UCharacterMovementComponent_ServerMoveOnlyRotation_Params params {};
		params.TimeStamp = TimeStamp;
		params.ClientRoll = ClientRoll;
		params.View = View;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023229B0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveOldWithRotation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		float                                              OldTimeStamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      OldAccel                                                   (Parm)
	 * 		unsigned char                                      OldMoveFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    OldRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveOldWithRotation(float OldTimeStamp, const struct FVector_NetQuantize100& OldAccel, unsigned char OldMoveFlags, const struct FRotator& OldRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveOldWithRotation");
		
		UCharacterMovementComponent_ServerMoveOldWithRotation_Params params {};
		params.OldTimeStamp = OldTimeStamp;
		params.OldAccel = OldAccel;
		params.OldMoveFlags = OldMoveFlags;
		params.OldRotation = OldRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02322C90
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveOld
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              OldTimeStamp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      OldAccel                                                   (Parm)
	 * 		unsigned char                                      OldMoveFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveOld(float OldTimeStamp, const struct FVector_NetQuantize100& OldAccel, unsigned char OldMoveFlags)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveOld");
		
		UCharacterMovementComponent_ServerMoveOld_Params params {};
		params.OldTimeStamp = OldTimeStamp;
		params.OldAccel = OldAccel;
		params.OldMoveFlags = OldMoveFlags;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02322EC0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveDualWithRotation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, HasDefaults, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel0                                                   (Parm)
	 * 		unsigned char                                      PendingFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel                                                    (Parm)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
	 * 		unsigned char                                      NewFlags                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InRotation0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveDualWithRotation(float TimeStamp0, const struct FVector_NetQuantize100& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize100& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode, const struct FRotator& InRotation0, const struct FRotator& InRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveDualWithRotation");
		
		UCharacterMovementComponent_ServerMoveDualWithRotation_Params params {};
		params.TimeStamp0 = TimeStamp0;
		params.InAccel0 = InAccel0;
		params.PendingFlags = PendingFlags;
		params.View0 = View0;
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.NewFlags = NewFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		params.InRotation0 = InRotation0;
		params.InRotation = InRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02323860
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveDualOnlyRotation
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveDualOnlyRotation(float TimeStamp0, uint32_t View0, float TimeStamp, unsigned char ClientRoll, uint32_t View)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveDualOnlyRotation");
		
		UCharacterMovementComponent_ServerMoveDualOnlyRotation_Params params {};
		params.TimeStamp0 = TimeStamp0;
		params.View0 = View0;
		params.TimeStamp = TimeStamp;
		params.ClientRoll = ClientRoll;
		params.View = View;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02323C00
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMoveDual
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel0                                                   (Parm)
	 * 		unsigned char                                      PendingFlags                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View0                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel                                                    (Parm)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
	 * 		unsigned char                                      NewFlags                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMoveDual(float TimeStamp0, const struct FVector_NetQuantize100& InAccel0, unsigned char PendingFlags, uint32_t View0, float TimeStamp, const struct FVector_NetQuantize100& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMoveDual");
		
		UCharacterMovementComponent_ServerMoveDual_Params params {};
		params.TimeStamp0 = TimeStamp0;
		params.InAccel0 = InAccel0;
		params.PendingFlags = PendingFlags;
		params.View0 = View0;
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.NewFlags = NewFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324420
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerMove
	 * 		Flags  -> (Net, Native, Event, Public, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantize100                      InAccel                                                    (Parm)
	 * 		struct FVector_NetQuantize100                      ClientLoc                                                  (Parm)
	 * 		unsigned char                                      CompressedMoveFlags                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientRoll                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		uint32_t                                           View                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         ClientMovementBase                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ClientBaseBoneName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ClientMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerMove(float TimeStamp, const struct FVector_NetQuantize100& InAccel, const struct FVector_NetQuantize100& ClientLoc, unsigned char CompressedMoveFlags, unsigned char ClientRoll, uint32_t View, class UPrimitiveComponent* ClientMovementBase, const class FName& ClientBaseBoneName, unsigned char ClientMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerMove");
		
		UCharacterMovementComponent_ServerMove_Params params {};
		params.TimeStamp = TimeStamp;
		params.InAccel = InAccel;
		params.ClientLoc = ClientLoc;
		params.CompressedMoveFlags = CompressedMoveFlags;
		params.ClientRoll = ClientRoll;
		params.View = View;
		params.ClientMovementBase = ClientMovementBase;
		params.ClientBaseBoneName = ClientBaseBoneName;
		params.ClientMovementMode = ClientMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023249E0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ServerJumpOutOfWater
	 * 		Flags  -> (Net, Native, Event, Public, NetServer)
	 * Parameters:
	 * 		struct FVector_NetQuantize100                      WallNormal                                                 (Parm)
	 * 		unsigned char                                      JumpFlag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ServerJumpOutOfWater(const struct FVector_NetQuantize100& WallNormal, unsigned char JumpFlag)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ServerJumpOutOfWater");
		
		UCharacterMovementComponent_ServerJumpOutOfWater_Params params {};
		params.WallNormal = WallNormal;
		params.JumpFlag = JumpFlag;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324B40
	 * 		Name   -> Function Engine.CharacterMovementComponent.RequestDirectMove
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     MoveVelocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceMaxSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::RequestDirectMove(const struct FVector& MoveVelocity, bool bForceMaxSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.RequestDirectMove");
		
		UCharacterMovementComponent_RequestDirectMove_Params params {};
		params.MoveVelocity = MoveVelocity;
		params.bForceMaxSpeed = bForceMaxSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324C90
	 * 		Name   -> Function Engine.CharacterMovementComponent.NewFallVelocity
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     InitialVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Gravity                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UCharacterMovementComponent::NewFallVelocity(const struct FVector& InitialVelocity, const struct FVector& Gravity, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.NewFallVelocity");
		
		UCharacterMovementComponent_NewFallVelocity_Params params {};
		params.InitialVelocity = InitialVelocity;
		params.Gravity = Gravity;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324E70
	 * 		Name   -> Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::K2_GetWalkableFloorZ()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ");
		
		UCharacterMovementComponent_K2_GetWalkableFloorZ_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324E90
	 * 		Name   -> Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::K2_GetWalkableFloorAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle");
		
		UCharacterMovementComponent_K2_GetWalkableFloorAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324EB0
	 * 		Name   -> Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::K2_GetModifiedMaxAcceleration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration");
		
		UCharacterMovementComponent_K2_GetModifiedMaxAcceleration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324F00
	 * 		Name   -> Function Engine.CharacterMovementComponent.IsWalking
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UCharacterMovementComponent::IsWalking()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalking");
		
		UCharacterMovementComponent_IsWalking_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02324F80
	 * 		Name   -> Function Engine.CharacterMovementComponent.IsWalkable
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UCharacterMovementComponent::IsWalkable(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsWalkable");
		
		UCharacterMovementComponent_IsWalkable_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325050
	 * 		Name   -> Function Engine.CharacterMovementComponent.IsOnWalkableFloor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UCharacterMovementComponent::IsOnWalkableFloor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.IsOnWalkableFloor");
		
		UCharacterMovementComponent_IsOnWalkableFloor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325080
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetValidPerchRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::GetValidPerchRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetValidPerchRadius");
		
		UCharacterMovementComponent_GetValidPerchRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023250B0
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::GetPerchRadiusThreshold()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold");
		
		UCharacterMovementComponent_GetPerchRadiusThreshold_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023250E0
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetMovementBase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPrimitiveComponent* UCharacterMovementComponent::GetMovementBase()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMovementBase");
		
		UCharacterMovementComponent_GetMovementBase_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325120
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetMaxJumpHeight
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::GetMaxJumpHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxJumpHeight");
		
		UCharacterMovementComponent_GetMaxJumpHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325160
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetMaxAcceleration
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::GetMaxAcceleration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetMaxAcceleration");
		
		UCharacterMovementComponent_GetMaxAcceleration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023251F0
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UCharacterMovementComponent::GetImpartedMovementBaseVelocity()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity");
		
		UCharacterMovementComponent_GetImpartedMovementBaseVelocity_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325230
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetCurrentAcceleration
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UCharacterMovementComponent::GetCurrentAcceleration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCurrentAcceleration");
		
		UCharacterMovementComponent_GetCurrentAcceleration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325260
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetCharacterOwner
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class ACharacter* UCharacterMovementComponent::GetCharacterOwner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetCharacterOwner");
		
		UCharacterMovementComponent_GetCharacterOwner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E95420
	 * 		Name   -> Function Engine.CharacterMovementComponent.GetAnalogInputModifier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCharacterMovementComponent::GetAnalogInputModifier()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.GetAnalogInputModifier");
		
		UCharacterMovementComponent_GetAnalogInputModifier_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325280
	 * 		Name   -> Function Engine.CharacterMovementComponent.DisableMovement
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UCharacterMovementComponent::DisableMovement()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.DisableMovement");
		
		UCharacterMovementComponent_DisableMovement_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023252E0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClientVeryShortAdjustPosition(float TimeStamp, const struct FVector& NewLoc, class UPrimitiveComponent* NewBase, const class FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition");
		
		UCharacterMovementComponent_ClientVeryShortAdjustPosition_Params params {};
		params.TimeStamp = TimeStamp;
		params.NewLoc = NewLoc;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023256F0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClientDrawDebugSphere
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FColor                                      SphereColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClientDrawDebugSphere(const struct FVector& Location, float Radius, const struct FColor& SphereColor, float LifeSpan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientDrawDebugSphere");
		
		UCharacterMovementComponent_ClientDrawDebugSphere_Params params {};
		params.Location = Location;
		params.Radius = Radius;
		params.SphereColor = SphereColor;
		params.LifeSpan = LifeSpan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325970
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ServerMontageTrackPosition                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ServerLoc                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector_NetQuantizeNormal                   ServerRotation                                             (Parm)
	 * 		float                                              ServerVelZ                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         ServerBase                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ServerBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClientAdjustRootMotionPosition(float TimeStamp, float ServerMontageTrackPosition, const struct FVector& ServerLoc, const struct FVector_NetQuantizeNormal& ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, const class FName& ServerBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition");
		
		UCharacterMovementComponent_ClientAdjustRootMotionPosition_Params params {};
		params.TimeStamp = TimeStamp;
		params.ServerMontageTrackPosition = ServerMontageTrackPosition;
		params.ServerLoc = ServerLoc;
		params.ServerRotation = ServerRotation;
		params.ServerVelZ = ServerVelZ;
		params.ServerBase = ServerBase;
		params.ServerBoneName = ServerBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02325F20
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClientAdjustPosition
	 * 		Flags  -> (Net, Native, Event, Public, HasDefaults, NetClient)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewLoc                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewVel                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         NewBase                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        NewBaseBoneName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bHasBase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bBaseRelativePosition                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      ServerMovementMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClientAdjustPosition(float TimeStamp, const struct FVector& NewLoc, const struct FVector& NewVel, class UPrimitiveComponent* NewBase, const class FName& NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, unsigned char ServerMovementMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAdjustPosition");
		
		UCharacterMovementComponent_ClientAdjustPosition_Params params {};
		params.TimeStamp = TimeStamp;
		params.NewLoc = NewLoc;
		params.NewVel = NewVel;
		params.NewBase = NewBase;
		params.NewBaseBoneName = NewBaseBoneName;
		params.bHasBase = bHasBase;
		params.bBaseRelativePosition = bBaseRelativePosition;
		params.ServerMovementMode = ServerMovementMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023263B0
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClientAckGoodMove
	 * 		Flags  -> (Net, Native, Event, Public, NetClient)
	 * Parameters:
	 * 		float                                              TimeStamp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClientAckGoodMove(float TimeStamp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClientAckGoodMove");
		
		UCharacterMovementComponent_ClientAckGoodMove_Params params {};
		params.TimeStamp = TimeStamp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326480
	 * 		Name   -> Function Engine.CharacterMovementComponent.ClearBase
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNotifyActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::ClearBase(bool bNotifyActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.ClearBase");
		
		UCharacterMovementComponent_ClearBase_Params params {};
		params.bNotifyActor = bNotifyActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326570
	 * 		Name   -> Function Engine.CharacterMovementComponent.CapsuleTouched
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  SweepResult                                                (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UCharacterMovementComponent::CapsuleTouched(class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CapsuleTouched");
		
		UCharacterMovementComponent_CapsuleTouched_Params params {};
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.SweepResult = SweepResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326850
	 * 		Name   -> Function Engine.CharacterMovementComponent.CalcVelocity
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Friction                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFluid                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BrakingDeceleration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.CalcVelocity");
		
		UCharacterMovementComponent_CalcVelocity_Params params {};
		params.DeltaTime = DeltaTime;
		params.Friction = Friction;
		params.bFluid = bFluid;
		params.BrakingDeceleration = BrakingDeceleration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326AD0
	 * 		Name   -> Function Engine.CharacterMovementComponent.AddImpulse
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bVelocityChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MassScaleImpulseExponent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOverrideMaxImpulseZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::AddImpulse(const struct FVector& Impulse, bool bVelocityChange, float MassScaleImpulseExponent, bool bOverrideMaxImpulseZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddImpulse");
		
		UCharacterMovementComponent_AddImpulse_Params params {};
		params.Impulse = Impulse;
		params.bVelocityChange = bVelocityChange;
		params.MassScaleImpulseExponent = MassScaleImpulseExponent;
		params.bOverrideMaxImpulseZ = bOverrideMaxImpulseZ;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326D70
	 * 		Name   -> Function Engine.CharacterMovementComponent.AddForce
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Force                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCharacterMovementComponent::AddForce(const struct FVector& Force)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CharacterMovementComponent.AddForce");
		
		UCharacterMovementComponent_AddForce_Params params {};
		params.Force = Force;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCharacterMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCharacterMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CharacterMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FFD0
	 * 		Name   -> Function Engine.CheatManager.WidgetReflector
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::WidgetReflector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.WidgetReflector");
		
		UCheatManager_WidgetReflector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FFF0
	 * 		Name   -> Function Engine.CheatManager.Walk
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::Walk()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Walk");
		
		UCheatManager_Walk_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710010
	 * 		Name   -> Function Engine.CheatManager.ViewSelf
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::ViewSelf()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewSelf");
		
		UCheatManager_ViewSelf_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710030
	 * 		Name   -> Function Engine.CheatManager.ViewPlayer
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 */
	void UCheatManager::ViewPlayer(const class FString& S)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewPlayer");
		
		UCheatManager_ViewPlayer_Params params {};
		params.S = S;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710130
	 * 		Name   -> Function Engine.CheatManager.ViewClass
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class UClass*                                      DesiredClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::ViewClass(class UClass* DesiredClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewClass");
		
		UCheatManager_ViewClass_Params params {};
		params.DesiredClass = DesiredClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710200
	 * 		Name   -> Function Engine.CheatManager.ViewActor
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        ActorName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::ViewActor(const class FName& ActorName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ViewActor");
		
		UCheatManager_ViewActor_Params params {};
		params.ActorName = ActorName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027102D0
	 * 		Name   -> Function Engine.CheatManager.ToggleDebugCamera
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::ToggleDebugCamera()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleDebugCamera");
		
		UCheatManager_ToggleDebugCamera_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027102F0
	 * 		Name   -> Function Engine.CheatManager.ToggleAILogging
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::ToggleAILogging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ToggleAILogging");
		
		UCheatManager_ToggleAILogging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710330
	 * 		Name   -> Function Engine.CheatManager.TestCollisionDistance
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::TestCollisionDistance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.TestCollisionDistance");
		
		UCheatManager_TestCollisionDistance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EEEF00
	 * 		Name   -> Function Engine.CheatManager.Teleport
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::Teleport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Teleport");
		
		UCheatManager_Teleport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710350
	 * 		Name   -> Function Engine.CheatManager.Summon
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      ClassName                                                  (Parm, ZeroConstructor)
	 */
	void UCheatManager::Summon(const class FString& ClassName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Summon");
		
		UCheatManager_Summon_Params params {};
		params.ClassName = ClassName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710450
	 * 		Name   -> Function Engine.CheatManager.StreamLevelOut
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::StreamLevelOut(const class FName& PackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelOut");
		
		UCheatManager_StreamLevelOut_Params params {};
		params.PackageName = PackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710550
	 * 		Name   -> Function Engine.CheatManager.StreamLevelIn
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::StreamLevelIn(const class FName& PackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.StreamLevelIn");
		
		UCheatManager_StreamLevelIn_Params params {};
		params.PackageName = PackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710650
	 * 		Name   -> Function Engine.CheatManager.Slomo
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              T                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::Slomo(float T)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Slomo");
		
		UCheatManager_Slomo_Params params {};
		params.T = T;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710720
	 * 		Name   -> Function Engine.CheatManager.SetWorldOrigin
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UCheatManager::SetWorldOrigin()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetWorldOrigin");
		
		UCheatManager_SetWorldOrigin_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710740
	 * 		Name   -> Function Engine.CheatManager.SetNavDrawDistance
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              DrawDistance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::SetNavDrawDistance(float DrawDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.SetNavDrawDistance");
		
		UCheatManager_SetNavDrawDistance_Params params {};
		params.DrawDistance = DrawDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710800
	 * 		Name   -> Function Engine.CheatManager.ServerToggleAILogging
	 * 		Flags  -> (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
	 */
	void UCheatManager::ServerToggleAILogging()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ServerToggleAILogging");
		
		UCheatManager_ServerToggleAILogging_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710880
	 * 		Name   -> Function Engine.CheatManager.RebuildNavigation
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::RebuildNavigation()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.RebuildNavigation");
		
		UCheatManager_RebuildNavigation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710900
	 * 		Name   -> Function Engine.CheatManager.PlayersOnly
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::PlayersOnly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.PlayersOnly");
		
		UCheatManager_PlayersOnly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710920
	 * 		Name   -> Function Engine.CheatManager.OnlyLoadLevel
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::OnlyLoadLevel(const class FName& PackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.OnlyLoadLevel");
		
		UCheatManager_OnlyLoadLevel_Params params {};
		params.PackageName = PackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710A20
	 * 		Name   -> Function Engine.CheatManager.LogLoc
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::LogLoc()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.LogLoc");
		
		UCheatManager_LogLoc_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710A40
	 * 		Name   -> Function Engine.CheatManager.God
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::God()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.God");
		
		UCheatManager_God_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FAC0
	 * 		Name   -> Function Engine.CheatManager.Ghost
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::Ghost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Ghost");
		
		UCheatManager_Ghost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710A60
	 * 		Name   -> Function Engine.CheatManager.FreezeFrame
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Delay                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::FreezeFrame(float Delay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FreezeFrame");
		
		UCheatManager_FreezeFrame_Params params {};
		params.Delay = Delay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710B30
	 * 		Name   -> Function Engine.CheatManager.Fly
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::Fly()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.Fly");
		
		UCheatManager_Fly_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710B50
	 * 		Name   -> Function Engine.CheatManager.FlushLog
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::FlushLog()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.FlushLog");
		
		UCheatManager_FlushLog_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710BB0
	 * 		Name   -> Function Engine.CheatManager.DumpVoiceMutingState
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DumpVoiceMutingState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpVoiceMutingState");
		
		UCheatManager_DumpVoiceMutingState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710BD0
	 * 		Name   -> Function Engine.CheatManager.DumpOnlineSessionState
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DumpOnlineSessionState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DumpOnlineSessionState");
		
		UCheatManager_DumpOnlineSessionState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710BF0
	 * 		Name   -> Function Engine.CheatManager.DestroyTarget
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DestroyTarget()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyTarget");
		
		UCheatManager_DestroyTarget_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710C10
	 * 		Name   -> Function Engine.CheatManager.DestroyPawns
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class UClass*                                      aClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DestroyPawns(class UClass* aClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyPawns");
		
		UCheatManager_DestroyPawns_Params params {};
		params.aClass = aClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710CE0
	 * 		Name   -> Function Engine.CheatManager.DestroyAll
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class UClass*                                      aClass                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bExactMatch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DestroyAll(class UClass* aClass, bool bExactMatch)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DestroyAll");
		
		UCheatManager_DestroyAll_Params params {};
		params.aClass = aClass;
		params.bExactMatch = bExactMatch;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710E40
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepSize
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DebugCapsuleSweepSize(float HalfHeight, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepSize");
		
		UCheatManager_DebugCapsuleSweepSize_Params params {};
		params.HalfHeight = HalfHeight;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710FD0
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepPawn
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DebugCapsuleSweepPawn()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepPawn");
		
		UCheatManager_DebugCapsuleSweepPawn_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02710FF0
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepComplex
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DebugCapsuleSweepComplex(bool bTraceComplex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepComplex");
		
		UCheatManager_DebugCapsuleSweepComplex_Params params {};
		params.bTraceComplex = bTraceComplex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711100
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepClear
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DebugCapsuleSweepClear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepClear");
		
		UCheatManager_DebugCapsuleSweepClear_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711120
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepChannel
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		ECollisionChannel                                  Channel                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DebugCapsuleSweepChannel(ECollisionChannel Channel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepChannel");
		
		UCheatManager_DebugCapsuleSweepChannel_Params params {};
		params.Channel = Channel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711210
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweepCapture
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DebugCapsuleSweepCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweepCapture");
		
		UCheatManager_DebugCapsuleSweepCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711290
	 * 		Name   -> Function Engine.CheatManager.DebugCapsuleSweep
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UCheatManager::DebugCapsuleSweep()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DebugCapsuleSweep");
		
		UCheatManager_DebugCapsuleSweep_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027112B0
	 * 		Name   -> Function Engine.CheatManager.DamageTarget
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::DamageTarget(float DamageAmount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.DamageTarget");
		
		UCheatManager_DamageTarget_Params params {};
		params.DamageAmount = DamageAmount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711380
	 * 		Name   -> Function Engine.CheatManager.ChangeSize
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              F                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::ChangeSize(float F)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.ChangeSize");
		
		UCheatManager_ChangeSize_Params params {};
		params.F = F;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711450
	 * 		Name   -> Function Engine.CheatManager.BugItStringCreator
	 * 		Flags  -> (Exec, Native, Public, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     ViewLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    ViewRotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      GoString                                                   (Parm, OutParm, ZeroConstructor)
	 * 		class FString                                      LocString                                                  (Parm, OutParm, ZeroConstructor)
	 */
	void UCheatManager::BugItStringCreator(const struct FVector& ViewLocation, const struct FRotator& ViewRotation, class FString* GoString, class FString* LocString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItStringCreator");
		
		UCheatManager_BugItStringCreator_Params params {};
		params.ViewLocation = ViewLocation;
		params.ViewRotation = ViewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (GoString != nullptr)
			*GoString = params.GoString;
		if (LocString != nullptr)
			*LocString = params.LocString;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027116D0
	 * 		Name   -> Function Engine.CheatManager.BugItGo
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCheatManager::BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugItGo");
		
		UCheatManager_BugItGo_Params params {};
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		params.Roll = Roll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711AC0
	 * 		Name   -> Function Engine.CheatManager.BugIt
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		class FString                                      ScreenShotDescription                                      (Parm, ZeroConstructor)
	 */
	void UCheatManager::BugIt(const class FString& ScreenShotDescription)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CheatManager.BugIt");
		
		UCheatManager_BugIt_Params params {};
		params.ScreenShotDescription = ScreenShotDescription;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheatManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheatManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CheatManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEngine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEngine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Engine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameEngine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameEngine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameEngine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F21880
	 * 		Name   -> Function Engine.GameMode.ShouldSpawnAtStartSpot
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AGameMode::ShouldSpawnAtStartSpot(class AController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ShouldSpawnAtStartSpot");
		
		AGameMode_ShouldSpawnAtStartSpot_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A2F0
	 * 		Name   -> Function Engine.GameMode.SetBandwidthLimit
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		float                                              AsyncIOBandwidthLimit                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AGameMode::SetBandwidthLimit(float AsyncIOBandwidthLimit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameMode.SetBandwidthLimit");
		
		AGameMode_SetBandwidthLimit_Params params {};
		params.AsyncIOBandwidthLimit = AsyncIOBandwidthLimit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.GameMode.K2_PostLogin
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class APlayerController*                           NewPlayer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AGameMode::K2_PostLogin(class APlayerController* NewPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameMode.K2_PostLogin");
		
		AGameMode_K2_PostLogin_Params params {};
		params.NewPlayer = NewPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A3F0
	 * 		Name   -> Function Engine.GameMode.GetDefaultPawnClassForController
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 InController                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UClass* AGameMode::GetDefaultPawnClassForController(class AController* InController)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameMode.GetDefaultPawnClassForController");
		
		AGameMode_GetDefaultPawnClassForController_Params params {};
		params.InController = InController;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A4D0
	 * 		Name   -> Function Engine.GameMode.ChoosePlayerStart
	 * 		Flags  -> (Native, Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AController*                                 Player                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AActor* AGameMode::ChoosePlayerStart(class AController* Player)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameMode.ChoosePlayerStart");
		
		AGameMode_ChoosePlayerStart_Params params {};
		params.Player = Player;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CC70
	 * 		Name   -> Function Engine.GameInstance.DebugRemovePlayer
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameInstance::DebugRemovePlayer(int32_t ControllerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugRemovePlayer");
		
		UGameInstance_DebugRemovePlayer_Params params {};
		params.ControllerId = ControllerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CD50
	 * 		Name   -> Function Engine.GameInstance.DebugCreatePlayer
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameInstance::DebugCreatePlayer(int32_t ControllerId)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameInstance.DebugCreatePlayer");
		
		UGameInstance_DebugCreatePlayer_Params params {};
		params.ControllerId = ControllerId;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739950
	 * 		Name   -> Function Engine.GameState.Semaphore_TryGrab
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SemaphoreName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PriorityWeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            MaxToAllocate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AGameState::Semaphore_TryGrab(const class FName& SemaphoreName, class AActor* InObject, float PriorityWeight, int32_t MaxToAllocate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.Semaphore_TryGrab");
		
		AGameState_Semaphore_TryGrab_Params params {};
		params.SemaphoreName = SemaphoreName;
		params.InObject = InObject;
		params.PriorityWeight = PriorityWeight;
		params.MaxToAllocate = MaxToAllocate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739BD0
	 * 		Name   -> Function Engine.GameState.Semaphore_Release
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SemaphoreName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      InObject                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool AGameState::Semaphore_Release(const class FName& SemaphoreName, class AActor* InObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.Semaphore_Release");
		
		AGameState_Semaphore_Release_Params params {};
		params.SemaphoreName = SemaphoreName;
		params.InObject = InObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.GameState.PostProcessOverlapEvent__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APostProcessVolume*                          PostProcessVolume                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsPrimaryPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AGameState::PostProcessOverlapEvent__DelegateSignature(class APostProcessVolume* PostProcessVolume, class APlayerController* Controller, bool bIsPrimaryPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.PostProcessOverlapEvent__DelegateSignature");
		
		AGameState_PostProcessOverlapEvent__DelegateSignature_Params params {};
		params.PostProcessVolume = PostProcessVolume;
		params.Controller = Controller;
		params.bIsPrimaryPlayer = bIsPrimaryPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739D30
	 * 		Name   -> Function Engine.GameState.OnRep_SpectatorClass
	 * 		Flags  -> (Native, Public)
	 */
	void AGameState::OnRep_SpectatorClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_SpectatorClass");
		
		AGameState_OnRep_SpectatorClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739D70
	 * 		Name   -> Function Engine.GameState.OnRep_MatchState
	 * 		Flags  -> (Native, Public)
	 */
	void AGameState::OnRep_MatchState()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_MatchState");
		
		AGameState_OnRep_MatchState_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739D90
	 * 		Name   -> Function Engine.GameState.OnRep_GameModeClass
	 * 		Flags  -> (Native, Public)
	 */
	void AGameState::OnRep_GameModeClass()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.OnRep_GameModeClass");
		
		AGameState_OnRep_GameModeClass_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02739DD0
	 * 		Name   -> Function Engine.GameState.BPNetSpawnActorAtLocation
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      anActorClass                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     AtLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    AtRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      EffectOwnerToIgnore                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxRangeToReplicate                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            dataIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        attachSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOnlySendToEffectOwner                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AGameState::BPNetSpawnActorAtLocation(class UClass* anActorClass, const struct FVector& AtLocation, const struct FRotator& AtRotation, class AActor* EffectOwnerToIgnore, float MaxRangeToReplicate, class USceneComponent* attachToComponent, int32_t dataIndex, const class FName& attachSocketName, bool bOnlySendToEffectOwner)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameState.BPNetSpawnActorAtLocation");
		
		AGameState_BPNetSpawnActorAtLocation_Params params {};
		params.anActorClass = anActorClass;
		params.AtLocation = AtLocation;
		params.AtRotation = AtRotation;
		params.EffectOwnerToIgnore = EffectOwnerToIgnore;
		params.MaxRangeToReplicate = MaxRangeToReplicate;
		params.attachToComponent = attachToComponent;
		params.dataIndex = dataIndex;
		params.attachSocketName = attachSocketName;
		params.bOnlySendToEffectOwner = bOnlySendToEffectOwner;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameState.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameState::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameState");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FAC0
	 * 		Name   -> Function Engine.GameUserSettings.SaveSettings
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UGameUserSettings::SaveSettings()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameUserSettings.SaveSettings");
		
		UGameUserSettings_SaveSettings_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameUserSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameUserSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameUserSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UScriptViewportClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UScriptViewportClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ScriptViewportClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D9F0
	 * 		Name   -> Function Engine.GameViewportClient.SSSwapControllers
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UGameViewportClient::SSSwapControllers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SSSwapControllers");
		
		UGameViewportClient_SSSwapControllers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DA30
	 * 		Name   -> Function Engine.GameViewportClient.ShowTitleSafeArea
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void UGameViewportClient::ShowTitleSafeArea()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.ShowTitleSafeArea");
		
		UGameViewportClient_ShowTitleSafeArea_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DA70
	 * 		Name   -> Function Engine.GameViewportClient.SetConsoleTarget
	 * 		Flags  -> (Exec, Native, Public)
	 * Parameters:
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameViewportClient::SetConsoleTarget(int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameViewportClient.SetConsoleTarget");
		
		UGameViewportClient_SetConsoleTarget_Params params {};
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		UCanvas*                                           canvas
	 */
	void UGameViewportClient::PostRender(UCanvas* canvas)
	{
		// return nullptr;
		return GetVFunction<void(*)(UGameViewportClient*, UCanvas*)>(this, POST_RENDER_INDEX)(this, canvas);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameViewportClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameViewportClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameViewportClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722E50
	 * 		Name   -> Function Engine.MaterialInterface.GetPhysicalMaterial
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UPhysicalMaterial* UMaterialInterface::GetPhysicalMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetPhysicalMaterial");
		
		UMaterialInterface_GetPhysicalMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722E80
	 * 		Name   -> Function Engine.MaterialInterface.GetBaseMaterial
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	class UMaterial* UMaterialInterface::GetBaseMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInterface.GetBaseMaterial");
		
		UMaterialInterface_GetBaseMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328E10
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetVectorParameter
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetVectorParameter(const class FName& ParameterName, const struct FVector& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetVectorParameter");
		
		UParticleSystemComponent_SetVectorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328F80
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetTrailSourceData
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InFirstSocketName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSecondSocketName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETrailWidthMode                                    InWidthMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InWidth                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetTrailSourceData(const class FName& InFirstSocketName, const class FName& InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTrailSourceData");
		
		UParticleSystemComponent_SetTrailSourceData_Params params {};
		params.InFirstSocketName = InFirstSocketName;
		params.InSecondSocketName = InSecondSocketName;
		params.InWidthMode = InWidthMode;
		params.InWidth = InWidth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329250
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetTemplate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             NewTemplate                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetTemplate(class UParticleSystem* NewTemplate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetTemplate");
		
		UParticleSystemComponent_SetTemplate_Params params {};
		params.NewTemplate = NewTemplate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329320
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetMaterialParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetMaterialParameter(const class FName& ParameterName, class UMaterialInterface* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetMaterialParameter");
		
		UParticleSystemComponent_SetMaterialParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329470
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetFloatParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetFloatParameter(const class FName& ParameterName, float Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetFloatParameter");
		
		UParticleSystemComponent_SetFloatParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023295D0
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetEmitterEnable
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        EmitterName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewEnableState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetEmitterEnable(const class FName& EmitterName, bool bNewEnableState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetEmitterEnable");
		
		UParticleSystemComponent_SetEmitterEnable_Params params {};
		params.EmitterName = EmitterName;
		params.bNewEnableState = bNewEnableState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329730
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetColorParameter
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetColorParameter(const class FName& ParameterName, const struct FLinearColor& Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetColorParameter");
		
		UParticleSystemComponent_SetColorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023298A0
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetTangent
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewTangentPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamTargetTangent(int32_t EmitterIndex, const struct FVector& NewTangentPoint, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetTangent");
		
		UParticleSystemComponent_SetBeamTargetTangent_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewTangentPoint = NewTangentPoint;
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329A90
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetStrength
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NewTargetStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamTargetStrength(int32_t EmitterIndex, float NewTargetStrength, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetStrength");
		
		UParticleSystemComponent_SetBeamTargetStrength_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewTargetStrength = NewTargetStrength;
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329C70
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamTargetPoint
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewTargetPoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            TargetIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamTargetPoint(int32_t EmitterIndex, const struct FVector& NewTargetPoint, int32_t TargetIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamTargetPoint");
		
		UParticleSystemComponent_SetBeamTargetPoint_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewTargetPoint = NewTargetPoint;
		params.TargetIndex = TargetIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02329E60
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourceTangent
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewTangentPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamSourceTangent(int32_t EmitterIndex, const struct FVector& NewTangentPoint, int32_t SourceIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceTangent");
		
		UParticleSystemComponent_SetBeamSourceTangent_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewTangentPoint = NewTangentPoint;
		params.SourceIndex = SourceIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A050
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourceStrength
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NewSourceStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamSourceStrength(int32_t EmitterIndex, float NewSourceStrength, int32_t SourceIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourceStrength");
		
		UParticleSystemComponent_SetBeamSourceStrength_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewSourceStrength = NewSourceStrength;
		params.SourceIndex = SourceIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A230
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamSourcePoint
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewSourcePoint                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            SourceIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamSourcePoint(int32_t EmitterIndex, const struct FVector& NewSourcePoint, int32_t SourceIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamSourcePoint");
		
		UParticleSystemComponent_SetBeamSourcePoint_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewSourcePoint = NewSourcePoint;
		params.SourceIndex = SourceIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A420
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetBeamEndPoint
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            EmitterIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NewEndPoint                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetBeamEndPoint(int32_t EmitterIndex, const struct FVector& NewEndPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetBeamEndPoint");
		
		UParticleSystemComponent_SetBeamEndPoint_Params params {};
		params.EmitterIndex = EmitterIndex;
		params.NewEndPoint = NewEndPoint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A590
	 * 		Name   -> Function Engine.ParticleSystemComponent.SetActorParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      Param                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::SetActorParameter(const class FName& ParameterName, class AActor* Param)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.SetActorParameter");
		
		UParticleSystemComponent_SetActorParameter_Params params {};
		params.ParameterName = ParameterName;
		params.Param = Param;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ParticleSystemComponent.OnSystemFinished__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 * Parameters:
	 * 		class UParticleSystemComponent*                    PSystem                                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::OnSystemFinished__DelegateSignature(class UParticleSystemComponent* PSystem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.OnSystemFinished__DelegateSignature");
		
		UParticleSystemComponent_OnSystemFinished__DelegateSignature_Params params {};
		params.PSystem = PSystem;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A6E0
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetVectorParameter
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OutVector                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystemComponent::GetVectorParameter(const class FName& InName, struct FVector* OutVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetVectorParameter");
		
		UParticleSystemComponent_GetVectorParameter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutVector != nullptr)
			*OutVector = params.OutVector;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A830
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetNumActiveParticles
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UParticleSystemComponent::GetNumActiveParticles()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNumActiveParticles");
		
		UParticleSystemComponent_GetNumActiveParticles_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A8B0
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetNamedMaterial
	 * 		Flags  -> (Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInterface* UParticleSystemComponent::GetNamedMaterial(const class FName& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetNamedMaterial");
		
		UParticleSystemComponent_GetNamedMaterial_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232A990
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetMaterialParameter
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          OutMaterial                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystemComponent::GetMaterialParameter(const class FName& InName, class UMaterialInterface** OutMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetMaterialParameter");
		
		UParticleSystemComponent_GetMaterialParameter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutMaterial != nullptr)
			*OutMaterial = params.OutMaterial;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232AAE0
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetFloatParameter
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutFloat                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystemComponent::GetFloatParameter(const class FName& InName, float* OutFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetFloatParameter");
		
		UParticleSystemComponent_GetFloatParameter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutFloat != nullptr)
			*OutFloat = params.OutFloat;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232AC30
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetColorParameter
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                outColor                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystemComponent::GetColorParameter(const class FName& InName, struct FLinearColor* outColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetColorParameter");
		
		UParticleSystemComponent_GetColorParameter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outColor != nullptr)
			*outColor = params.outColor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232AD80
	 * 		Name   -> Function Engine.ParticleSystemComponent.GetActorParameter
	 * 		Flags  -> (Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      OutActor                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystemComponent::GetActorParameter(const class FName& InName, class AActor** OutActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GetActorParameter");
		
		UParticleSystemComponent_GetActorParameter_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActor != nullptr)
			*OutActor = params.OutActor;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232AED0
	 * 		Name   -> Function Engine.ParticleSystemComponent.GenerateParticleEvent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InEventName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InEmitterTime                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InLocation                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InDirection                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InVelocity                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::GenerateParticleEvent(const class FName& InEventName, float InEmitterTime, const struct FVector& InLocation, const struct FVector& InDirection, const struct FVector& InVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.GenerateParticleEvent");
		
		UParticleSystemComponent_GenerateParticleEvent_Params params {};
		params.InEventName = InEventName;
		params.InEmitterTime = InEmitterTime;
		params.InLocation = InLocation;
		params.InDirection = InDirection;
		params.InVelocity = InVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B240
	 * 		Name   -> Function Engine.ParticleSystemComponent.EndTrails
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UParticleSystemComponent::EndTrails()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.EndTrails");
		
		UParticleSystemComponent_EndTrails_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B2B0
	 * 		Name   -> Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          SourceMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* UParticleSystemComponent::CreateNamedDynamicMaterialInstance(const class FName& InName, class UMaterialInterface* SourceMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance");
		
		UParticleSystemComponent_CreateNamedDynamicMaterialInstance_Params params {};
		params.InName = InName;
		params.SourceMaterial = SourceMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B410
	 * 		Name   -> Function Engine.ParticleSystemComponent.BeginTrails
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InFirstSocketName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InSecondSocketName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETrailWidthMode                                    InWidthMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InWidth                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UParticleSystemComponent::BeginTrails(const class FName& InFirstSocketName, const class FName& InSecondSocketName, ETrailWidthMode InWidthMode, float InWidth)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystemComponent.BeginTrails");
		
		UParticleSystemComponent_BeginTrails_Params params {};
		params.InFirstSocketName = InFirstSocketName;
		params.InSecondSocketName = InSecondSocketName;
		params.InWidthMode = InWidthMode;
		params.InWidth = InWidth;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleSystemComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleSystemComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleSystemComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SaveGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Player");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> 
	 * 		Flags  -> ()
	 * Parameters:
	 * 		class ULocalPlayer*                                thiz
	 * 		struct FMinimalViewInfo*                           outViewInfo
	 * 		uint8_t                                            stereoPass
	 */
	void ULocalPlayer::GetViewPoint(class ULocalPlayer* thiz, struct FMinimalViewInfo* outViewInfo, uint8_t stereoPass)
	{
		GetVFunction<void(*)(class ULocalPlayer*, struct FMinimalViewInfo*, uint8_t)>(this, GET_VIEW_POINT_INDEX)(thiz, outViewInfo, stereoPass);
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULocalPlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULocalPlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LocalPlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UOnlineSession.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UOnlineSession::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.OnlineSession");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231FFB0
	 * 		Name   -> Function Engine.DefaultPawn.TurnAtRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::TurnAtRate(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.TurnAtRate");
		
		ADefaultPawn_TurnAtRate_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EE4840
	 * 		Name   -> Function Engine.DefaultPawn.Turn
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::Turn(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.Turn");
		
		ADefaultPawn_Turn_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320080
	 * 		Name   -> Function Engine.DefaultPawn.MoveUp_World
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::MoveUp_World(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveUp_World");
		
		ADefaultPawn_MoveUp_World_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023201B0
	 * 		Name   -> Function Engine.DefaultPawn.MoveRight
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::MoveRight(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveRight");
		
		ADefaultPawn_MoveRight_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320280
	 * 		Name   -> Function Engine.DefaultPawn.MoveForward
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::MoveForward(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.MoveForward");
		
		ADefaultPawn_MoveForward_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320350
	 * 		Name   -> Function Engine.DefaultPawn.LookUpAtRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::LookUpAtRate(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUpAtRate");
		
		ADefaultPawn_LookUpAtRate_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320420
	 * 		Name   -> Function Engine.DefaultPawn.LookUp
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable)
	 * Parameters:
	 * 		float                                              val                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADefaultPawn::LookUp(float val)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DefaultPawn.LookUp");
		
		ADefaultPawn_LookUp_Params params {};
		params.val = val;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADefaultPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADefaultPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DefaultPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpectatorPawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpectatorPawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpectatorPawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319080
	 * 		Name   -> Function Engine.PhysicsVolume.GetVolumeZAtPosition2D
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector2D                                   Position                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float APhysicsVolume::GetVolumeZAtPosition2D(const struct FVector2D& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsVolume.GetVolumeZAtPosition2D");
		
		APhysicsVolume_GetVolumeZAtPosition2D_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APhysicsVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APhysicsVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAISystemBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAISystemBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AISystemBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlueprintGeneratedClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlueprintGeneratedClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlueprintGeneratedClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNetConnection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNetConnection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NetConnection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNetDriver.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNetDriver::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NetDriver");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Model");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterface_AssetUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterface_AssetUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Interface_AssetUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318A40
	 * 		Name   -> Function Engine.AmbientSound.Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void AAmbientSound::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Stop");
		
		AAmbientSound_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318A70
	 * 		Name   -> Function Engine.AmbientSound.Play
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AAmbientSound::Play(float StartTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.Play");
		
		AAmbientSound_Play_Params params {};
		params.StartTime = StartTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318B60
	 * 		Name   -> Function Engine.AmbientSound.FadeOut
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AAmbientSound::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeOut");
		
		AAmbientSound_FadeOut_Params params {};
		params.FadeOutDuration = FadeOutDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318CD0
	 * 		Name   -> Function Engine.AmbientSound.FadeIn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeInDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AAmbientSound::FadeIn(float FadeInDuration, float FadeVolumeLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.FadeIn");
		
		AAmbientSound_FadeIn_Params params {};
		params.FadeInDuration = FadeInDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318E40
	 * 		Name   -> Function Engine.AmbientSound.AdjustVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              AdjustVolumeDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AdjustVolumeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AAmbientSound::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AmbientSound.AdjustVolume");
		
		AAmbientSound_AdjustVolume_Params params {};
		params.AdjustVolumeDuration = AdjustVolumeDuration;
		params.AdjustVolumeLevel = AdjustVolumeLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAmbientSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAmbientSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AmbientSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPendingNetGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPendingNetGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PendingNetGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748630
	 * 		Name   -> Function Engine.World.IsActuallyUsingTrueSkyActor
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UWorld::IsActuallyUsingTrueSkyActor()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.World.IsActuallyUsingTrueSkyActor");
		
		UWorld_IsActuallyUsingTrueSkyActor_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748660
	 * 		Name   -> Function Engine.World.GetWorldSettings
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		bool                                               bCheckStreamingPesistent                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bChecked                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AWorldSettings* UWorld::GetWorldSettings(bool bCheckStreamingPesistent, bool bChecked)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.World.GetWorldSettings");
		
		UWorld_GetWorldSettings_Params params {};
		params.bCheckStreamingPesistent = bCheckStreamingPesistent;
		params.bChecked = bChecked;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027487C0
	 * 		Name   -> Function Engine.World.GetFirstPlayerController
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class APlayerController* UWorld::GetFirstPlayerController()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.World.GetFirstPlayerController");
		
		UWorld_GetFirstPlayerController_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorld.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorld::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.World");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Level");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABrushShape.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABrushShape::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BrushShape");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318FB0
	 * 		Name   -> Function Engine.BlockingVolume.OnInterpToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ABlockingVolume::OnInterpToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BlockingVolume.OnInterpToggle");
		
		ABlockingVolume_OnInterpToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02318FB0
	 * 		Name   -> Function Engine.BlockingVolume.DoToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ABlockingVolume::DoToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BlockingVolume.DoToggle");
		
		ABlockingVolume_DoToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACameraBlockingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACameraBlockingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraBlockingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACullDistanceVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACullDistanceVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CullDistanceVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AFoliageInclusionVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AFoliageInclusionVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FoliageInclusionVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALevelStreamingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALevelStreamingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreamingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALightmassCharacterIndirectDetailVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALightmassCharacterIndirectDetailVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightmassCharacterIndirectDetailVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALightmassImportanceVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALightmassImportanceVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightmassImportanceVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMergeMeshVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMergeMeshVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MergeMeshVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavMeshBoundsVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavMeshBoundsVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavMeshBoundsVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavRelevantInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavRelevantInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavRelevantInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavModifierVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavModifierVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavModifierVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADefaultPhysicsVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADefaultPhysicsVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DefaultPhysicsVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AKillZVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AKillZVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KillZVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APainCausingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APainCausingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PainCausingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterface_PostProcessVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterface_PostProcessVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Interface_PostProcessVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PostProcessVolume.PostprocessVolumeLeftSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsPrimaryPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APostProcessVolume::PostprocessVolumeLeftSignature__DelegateSignature(class APlayerController* Controller, bool bIsPrimaryPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.PostprocessVolumeLeftSignature__DelegateSignature");
		
		APostProcessVolume_PostprocessVolumeLeftSignature__DelegateSignature_Params params {};
		params.Controller = Controller;
		params.bIsPrimaryPlayer = bIsPrimaryPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PostProcessVolume.PostprocessVolumeEnteredSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class APlayerController*                           Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsPrimaryPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APostProcessVolume::PostprocessVolumeEnteredSignature__DelegateSignature(class APlayerController* Controller, bool bIsPrimaryPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PostProcessVolume.PostprocessVolumeEnteredSignature__DelegateSignature");
		
		APostProcessVolume_PostprocessVolumeEnteredSignature__DelegateSignature_Params params {};
		params.Controller = Controller;
		params.bIsPrimaryPlayer = bIsPrimaryPlayer;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APostProcessVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APostProcessVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PostProcessVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpherePostProcessVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpherePostProcessVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpherePostProcessVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APrecomputedVisibilityOverrideVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APrecomputedVisibilityOverrideVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PrecomputedVisibilityOverrideVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APrecomputedVisibilityVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APrecomputedVisibilityVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PrecomputedVisibilityVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319190
	 * 		Name   -> Function Engine.TileStreamingVolume.OnInterpToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ATileStreamingVolume::OnInterpToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TileStreamingVolume.OnInterpToggle");
		
		ATileStreamingVolume_OnInterpToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319270
	 * 		Name   -> Function Engine.TileStreamingVolume.DoToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ATileStreamingVolume::DoToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TileStreamingVolume.DoToggle");
		
		ATileStreamingVolume_DoToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATileStreamingVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATileStreamingVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TileStreamingVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATriggerVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATriggerVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TriggerVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02748400
	 * 		Name   -> Function Engine.CameraActor.GetAutoActivatePlayerIndex
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t ACameraActor::GetAutoActivatePlayerIndex()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CameraActor.GetAutoActivatePlayerIndex");
		
		ACameraActor_GetAutoActivatePlayerIndex_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ACameraActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ACameraActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavAgentInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavAgentInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavAgentInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027463D0
	 * 		Name   -> Function Engine.InputComponent.WasControllerKeyJustReleased
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool UInputComponent::WasControllerKeyJustReleased(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustReleased");
		
		UInputComponent_WasControllerKeyJustReleased_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027463D0
	 * 		Name   -> Function Engine.InputComponent.WasControllerKeyJustPressed
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool UInputComponent::WasControllerKeyJustPressed(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.WasControllerKeyJustPressed");
		
		UInputComponent_WasControllerKeyJustPressed_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027463D0
	 * 		Name   -> Function Engine.InputComponent.IsControllerKeyDown
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	bool UInputComponent::IsControllerKeyDown(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.IsControllerKeyDown");
		
		UInputComponent_IsControllerKeyDown_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InputComponent.InputVectorAxisHandlerDynamicSignature__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     AxisValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::InputVectorAxisHandlerDynamicSignature__DelegateSignature(const struct FVector& AxisValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.InputVectorAxisHandlerDynamicSignature__DelegateSignature");
		
		UInputComponent_InputVectorAxisHandlerDynamicSignature__DelegateSignature_Params params {};
		params.AxisValue = AxisValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InputComponent.InputTouchHandlerDynamicSignature__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		ETouchIndex                                        FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::InputTouchHandlerDynamicSignature__DelegateSignature(ETouchIndex FingerIndex, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.InputTouchHandlerDynamicSignature__DelegateSignature");
		
		UInputComponent_InputTouchHandlerDynamicSignature__DelegateSignature_Params params {};
		params.FingerIndex = FingerIndex;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InputComponent.InputGestureHandlerDynamicSignature__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::InputGestureHandlerDynamicSignature__DelegateSignature(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.InputGestureHandlerDynamicSignature__DelegateSignature");
		
		UInputComponent_InputGestureHandlerDynamicSignature__DelegateSignature_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InputComponent.InputAxisHandlerDynamicSignature__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 * Parameters:
	 * 		float                                              AxisValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::InputAxisHandlerDynamicSignature__DelegateSignature(float AxisValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.InputAxisHandlerDynamicSignature__DelegateSignature");
		
		UInputComponent_InputAxisHandlerDynamicSignature__DelegateSignature_Params params {};
		params.AxisValue = AxisValue;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InputComponent.InputActionHandlerDynamicSignature__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UInputComponent::InputActionHandlerDynamicSignature__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.InputActionHandlerDynamicSignature__DelegateSignature");
		
		UInputComponent_InputActionHandlerDynamicSignature__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746510
	 * 		Name   -> Function Engine.InputComponent.GetTouchState
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            FingerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LocationX                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LocationY                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsCurrentlyPressed                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::GetTouchState(int32_t FingerIndex, float* LocationX, float* LocationY, bool* bIsCurrentlyPressed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetTouchState");
		
		UInputComponent_GetTouchState_Params params {};
		params.FingerIndex = FingerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LocationX != nullptr)
			*LocationX = params.LocationX;
		if (LocationY != nullptr)
			*LocationY = params.LocationY;
		if (bIsCurrentlyPressed != nullptr)
			*bIsCurrentlyPressed = params.bIsCurrentlyPressed;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746710
	 * 		Name   -> Function Engine.InputComponent.GetControllerVectorKeyState
	 * 		Flags  -> (Final, Native, Private, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	struct FVector UInputComponent::GetControllerVectorKeyState(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerVectorKeyState");
		
		UInputComponent_GetControllerVectorKeyState_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746860
	 * 		Name   -> Function Engine.InputComponent.GetControllerMouseDelta
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              DeltaX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::GetControllerMouseDelta(float* DeltaX, float* DeltaY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerMouseDelta");
		
		UInputComponent_GetControllerMouseDelta_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DeltaX != nullptr)
			*DeltaX = params.DeltaX;
		if (DeltaY != nullptr)
			*DeltaY = params.DeltaY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746970
	 * 		Name   -> Function Engine.InputComponent.GetControllerKeyTimeDown
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	float UInputComponent::GetControllerKeyTimeDown(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerKeyTimeDown");
		
		UInputComponent_GetControllerKeyTimeDown_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746AB0
	 * 		Name   -> Function Engine.InputComponent.GetControllerAnalogStickState
	 * 		Flags  -> (Final, Native, Private, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		EControllerAnalogStick                             WhichStick                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StickX                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StickY                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInputComponent::GetControllerAnalogStickState(EControllerAnalogStick WhichStick, float* StickX, float* StickY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogStickState");
		
		UInputComponent_GetControllerAnalogStickState_Params params {};
		params.WhichStick = WhichStick;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (StickX != nullptr)
			*StickX = params.StickX;
		if (StickY != nullptr)
			*StickY = params.StickY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02746970
	 * 		Name   -> Function Engine.InputComponent.GetControllerAnalogKeyState
	 * 		Flags  -> (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FKey                                        Key                                                        (Parm)
	 */
	float UInputComponent::GetControllerAnalogKeyState(const struct FKey& Key)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InputComponent.GetControllerAnalogKeyState");
		
		UInputComponent_GetControllerAnalogKeyState_Params params {};
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0273A5B0
	 * 		Name   -> Function Engine.DebugCameraController.ShowDebugSelectedInfo
	 * 		Flags  -> (Exec, Native, Public)
	 */
	void ADebugCameraController::ShowDebugSelectedInfo()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DebugCameraController.ShowDebugSelectedInfo");
		
		ADebugCameraController_ShowDebugSelectedInfo_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADebugCameraController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADebugCameraController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DebugCameraController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALogVisualizerCameraController.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALogVisualizerCameraController::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LogVisualizerCameraController");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319340
	 * 		Name   -> Function Engine.DecalActor.SetDecalMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          NewDecalMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ADecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.SetDecalMaterial");
		
		ADecalActor_SetDecalMaterial_Params params {};
		params.NewDecalMaterial = NewDecalMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319460
	 * 		Name   -> Function Engine.DecalActor.GetDecalMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UMaterialInterface* ADecalActor::GetDecalMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.GetDecalMaterial");
		
		ADecalActor_GetDecalMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023194A0
	 * 		Name   -> Function Engine.DecalActor.CreateDynamicMaterialInstance
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class UMaterialInstanceDynamic* ADecalActor::CreateDynamicMaterialInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalActor.CreateDynamicMaterialInstance");
		
		ADecalActor_CreateDynamicMaterialInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADecalActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADecalActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DecalActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADocumentationActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADocumentationActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DocumentationActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADynamicCaptureManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADynamicCaptureManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DynamicCaptureManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AEmitterCameraLensEffectBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AEmitterCameraLensEffectBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EmitterCameraLensEffectBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGroundClutterLayerActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGroundClutterLayerActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GroundClutterLayerActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHierarchicalInstancedStaticMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHierarchicalInstancedStaticMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.HierarchicalInstancedStaticMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AHoudiniEmptyActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AHoudiniEmptyActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.HoudiniEmptyActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADebugCameraHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADebugCameraHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DebugCameraHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALogVisualizerHUD.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALogVisualizerHUD::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LogVisualizerHUD");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AAtmosphericFog.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AAtmosphericFog::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AtmosphericFog");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231D9F0
	 * 		Name   -> Function Engine.ExponentialHeightFog.OnRep_bEnabled
	 * 		Flags  -> (Native, Public)
	 */
	void AExponentialHeightFog::OnRep_bEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFog.OnRep_bEnabled");
		
		AExponentialHeightFog_OnRep_bEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AExponentialHeightFog.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AExponentialHeightFog::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ExponentialHeightFog");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAntiDupeTransactionLog.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAntiDupeTransactionLog::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AntiDupeTransactionLog");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALocalSpawnGameMode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALocalSpawnGameMode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LocalSpawnGameMode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGameNetworkManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGameNetworkManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameNetworkManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMatineeActorManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMatineeActorManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MatineeActorManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DA50
	 * 		Name   -> Function Engine.SkyLight.OnRep_bEnabled
	 * 		Flags  -> (Native, Public)
	 */
	void ASkyLight::OnRep_bEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLight.OnRep_bEnabled");
		
		ASkyLight_OnRep_bEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASkyLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASkyLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkyLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWindDirectionalSource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWindDirectionalSource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WindDirectionalSource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DAB0
	 * 		Name   -> Function Engine.InstancedFoliageActor.BPGetInstancedFoliageActorForCurrentLevel
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UWorld*                                      World                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AInstancedFoliageActor* AInstancedFoliageActor::STATIC_BPGetInstancedFoliageActorForCurrentLevel(class UWorld* World)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedFoliageActor.BPGetInstancedFoliageActorForCurrentLevel");
		
		AInstancedFoliageActor_BPGetInstancedFoliageActorForCurrentLevel_Params params {};
		params.World = World;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DB80
	 * 		Name   -> Function Engine.InstancedFoliageActor.BPConvertStaticMeshActorsToFoliage
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AStaticMeshActor*>                    actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AStaticMeshActor*>                    ConvertedActors                                            (Parm, OutParm, ZeroConstructor)
	 */
	void AInstancedFoliageActor::BPConvertStaticMeshActorsToFoliage(TArray<class AStaticMeshActor*> actors, TArray<class AStaticMeshActor*>* ConvertedActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedFoliageActor.BPConvertStaticMeshActorsToFoliage");
		
		AInstancedFoliageActor_BPConvertStaticMeshActorsToFoliage_Params params {};
		params.actors = actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (ConvertedActors != nullptr)
			*ConvertedActors = params.ConvertedActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AInstancedFoliageActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AInstancedFoliageActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InstancedFoliageActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALandscapeGizmoActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALandscapeGizmoActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeGizmoActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALandscapeGizmoActiveActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALandscapeGizmoActiveActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeGizmoActiveActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DCD0
	 * 		Name   -> Function Engine.LandscapeProxy.ChangeLODDistanceFactor
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InLODDistanceFactor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALandscapeProxy::ChangeLODDistanceFactor(float InLODDistanceFactor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LandscapeProxy.ChangeLODDistanceFactor");
		
		ALandscapeProxy_ChangeLODDistanceFactor_Params params {};
		params.InLODDistanceFactor = InLODDistanceFactor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALandscapeProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALandscapeProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALandscape.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALandscape::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Landscape");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALevelBounds.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALevelBounds::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelBounds");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.LevelScriptActor.WorldOriginLocationChanged
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		struct FIntVector                                  OldOriginLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FIntVector                                  NewOriginLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALevelScriptActor::WorldOriginLocationChanged(const struct FIntVector& OldOriginLocation, const struct FIntVector& NewOriginLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.WorldOriginLocationChanged");
		
		ALevelScriptActor_WorldOriginLocationChanged_Params params {};
		params.OldOriginLocation = OldOriginLocation;
		params.NewOriginLocation = NewOriginLocation;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231DDA0
	 * 		Name   -> Function Engine.LevelScriptActor.SetCinematicMode
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bCinematicMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bHidePlayer                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsHUD                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsMovement                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAffectsTurning                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALevelScriptActor::SetCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.SetCinematicMode");
		
		ALevelScriptActor_SetCinematicMode_Params params {};
		params.bCinematicMode = bCinematicMode;
		params.bHidePlayer = bHidePlayer;
		params.bAffectsHUD = bAffectsHUD;
		params.bAffectsMovement = bAffectsMovement;
		params.bAffectsTurning = bAffectsTurning;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F21880
	 * 		Name   -> Function Engine.LevelScriptActor.RemoteEvent
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        EventName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool ALevelScriptActor::RemoteEvent(const class FName& EventName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.RemoteEvent");
		
		ALevelScriptActor_RemoteEvent_Params params {};
		params.EventName = EventName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.LevelScriptActor.OnGameStateReady
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AGameState*                                  GameState                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ALevelScriptActor::OnGameStateReady(class AGameState* GameState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.OnGameStateReady");
		
		ALevelScriptActor_OnGameStateReady_Params params {};
		params.GameState = GameState;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.LevelScriptActor.LevelReset
	 * 		Flags  -> (BlueprintAuthorityOnly, Event, Public, BlueprintCallable, BlueprintEvent)
	 */
	void ALevelScriptActor::LevelReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelScriptActor.LevelReset");
		
		ALevelScriptActor_LevelReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ALevelScriptActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ALevelScriptActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelScriptActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ADirectionalLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ADirectionalLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DirectionalLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E0E0
	 * 		Name   -> Function Engine.PointLight.SetRadius
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APointLight::SetRadius(float NewRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetRadius");
		
		APointLight_SetRadius_Params params {};
		params.NewRadius = NewRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E1D0
	 * 		Name   -> Function Engine.PointLight.SetLightFalloffExponent
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewLightFalloffExponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void APointLight::SetLightFalloffExponent(float NewLightFalloffExponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PointLight.SetLightFalloffExponent");
		
		APointLight_SetLightFalloffExponent_Params params {};
		params.NewLightFalloffExponent = NewLightFalloffExponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APointLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APointLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PointLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738BD0
	 * 		Name   -> Function Engine.SpotLight.SetOuterConeAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewOuterConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ASpotLight::SetOuterConeAngle(float NewOuterConeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetOuterConeAngle");
		
		ASpotLight_SetOuterConeAngle_Params params {};
		params.NewOuterConeAngle = NewOuterConeAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738CC0
	 * 		Name   -> Function Engine.SpotLight.SetInnerConeAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewInnerConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ASpotLight::SetInnerConeAngle(float NewInnerConeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SpotLight.SetInnerConeAngle");
		
		ASpotLight_SetInnerConeAngle_Params params {};
		params.NewInnerConeAngle = NewInnerConeAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASpotLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASpotLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpotLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AGeneratedMeshAreaLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AGeneratedMeshAreaLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GeneratedMeshAreaLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMaterialInstanceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMaterialInstanceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialInstanceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FD0
	 * 		Name   -> Function Engine.MatineeActor.Stop
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AMatineeActor::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Stop");
		
		AMatineeActor_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E2A0
	 * 		Name   -> Function Engine.MatineeActor.SetPosition
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bJump                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceJumpFromBeginningForEvents                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipMatineeUpdate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AMatineeActor::SetPosition(float NewPosition, bool bJump, bool bForceJumpFromBeginningForEvents, bool bSkipMatineeUpdate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetPosition");
		
		AMatineeActor_SetPosition_Params params {};
		params.NewPosition = NewPosition;
		params.bJump = bJump;
		params.bForceJumpFromBeginningForEvents = bForceJumpFromBeginningForEvents;
		params.bSkipMatineeUpdate = bSkipMatineeUpdate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E530
	 * 		Name   -> Function Engine.MatineeActor.SetLoopingState
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewLooping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AMatineeActor::SetLoopingState(bool bNewLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.SetLoopingState");
		
		AMatineeActor_SetLoopingState_Params params {};
		params.bNewLooping = bNewLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02319FB0
	 * 		Name   -> Function Engine.MatineeActor.Reverse
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AMatineeActor::Reverse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Reverse");
		
		AMatineeActor_Reverse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E640
	 * 		Name   -> Function Engine.MatineeActor.Play
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              OverrideSetPosition                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOverridePositionJump                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AMatineeActor::Play(float OverrideSetPosition, bool bOverridePositionJump)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Play");
		
		AMatineeActor_Play_Params params {};
		params.OverrideSetPosition = OverrideSetPosition;
		params.bOverridePositionJump = bOverridePositionJump;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E7A0
	 * 		Name   -> Function Engine.MatineeActor.Pause
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AMatineeActor::Pause()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.Pause");
		
		AMatineeActor_Pause_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.MatineeActor.OnMatineeEvent__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void AMatineeActor::OnMatineeEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.OnMatineeEvent__DelegateSignature");
		
		AMatineeActor_OnMatineeEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E7C0
	 * 		Name   -> Function Engine.MatineeActor.InitClientMatinee
	 * 		Flags  -> (Final, Native, Public)
	 */
	void AMatineeActor::InitClientMatinee()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.InitClientMatinee");
		
		AMatineeActor_InitClientMatinee_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E7E0
	 * 		Name   -> Function Engine.MatineeActor.ChangePlaybackDirection
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void AMatineeActor::ChangePlaybackDirection()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.ChangePlaybackDirection");
		
		AMatineeActor_ChangePlaybackDirection_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0231E840
	 * 		Name   -> Function Engine.MatineeActor.AddActorToGroup
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        GroupName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      TheGroupActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void AMatineeActor::AddActorToGroup(const class FName& GroupName, class AActor* TheGroupActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MatineeActor.AddActorToGroup");
		
		AMatineeActor_AddActorToGroup_Params params {};
		params.GroupName = GroupName;
		params.TheGroupActor = TheGroupActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMatineeActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMatineeActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MatineeActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AMatineeActorCameraAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AMatineeActorCameraAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MatineeActorCameraAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationQueryFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationQueryFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationQueryFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARecastNavMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARecastNavMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RecastNavMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationGraphNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationGraphNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationGraphNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationObjectBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationObjectBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationObjectBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerStart.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerStart::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerStart");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlayerStartPIE.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlayerStartPIE::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerStartPIE");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavPathObserverInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavPathObserverInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavPathObserverInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavigationTestingActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavigationTestingActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationTestingActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkDefinition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkDefinition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkDefinition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkHostInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkHostInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkHostInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.NavLinkProxy.SmartLinkReachedSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		class AActor*                                      MovingActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     DestinationPoint                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void ANavLinkProxy::SmartLinkReachedSignature__DelegateSignature(class AActor* MovingActor, const struct FVector& DestinationPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.SmartLinkReachedSignature__DelegateSignature");
		
		ANavLinkProxy_SmartLinkReachedSignature__DelegateSignature_Params params {};
		params.MovingActor = MovingActor;
		params.DestinationPoint = DestinationPoint;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738A80
	 * 		Name   -> Function Engine.NavLinkProxy.SetSmartLinkEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnabled                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ANavLinkProxy::SetSmartLinkEnabled(bool bEnabled)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.SetSmartLinkEnabled");
		
		ANavLinkProxy_SetSmartLinkEnabled_Params params {};
		params.bEnabled = bEnabled;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F370
	 * 		Name   -> Function Engine.NavLinkProxy.ResumePathFollowing
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Agent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ANavLinkProxy::ResumePathFollowing(class AActor* Agent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.ResumePathFollowing");
		
		ANavLinkProxy_ResumePathFollowing_Params params {};
		params.Agent = Agent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.NavLinkProxy.ReceiveSmartLinkReached
	 * 		Flags  -> (Event, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class AActor*                                      Agent                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Destination                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void ANavLinkProxy::ReceiveSmartLinkReached(class AActor* Agent, const struct FVector& Destination)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.ReceiveSmartLinkReached");
		
		ANavLinkProxy_ReceiveSmartLinkReached_Params params {};
		params.Agent = Agent;
		params.Destination = Destination;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738B60
	 * 		Name   -> Function Engine.NavLinkProxy.IsSmartLinkEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ANavLinkProxy::IsSmartLinkEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.IsSmartLinkEnabled");
		
		ANavLinkProxy_IsSmartLinkEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02738B90
	 * 		Name   -> Function Engine.NavLinkProxy.HasMovingAgents
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ANavLinkProxy::HasMovingAgents()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavLinkProxy.HasMovingAgents");
		
		ANavLinkProxy_HasMovingAgents_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANavLinkProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANavLinkProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ANiagaraActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ANiagaraActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NiagaraActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AParticleEventManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AParticleEventManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleEventManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkeleton.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkeleton::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Skeleton");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkeletalMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkeletalMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkeletalMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AWheeledVehicle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AWheeledVehicle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WheeledVehicle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AReflectionCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AReflectionCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReflectionCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736F30
	 * 		Name   -> Function Engine.BoxReflectionCapture.GetBoxCaptureComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UBoxReflectionCaptureComponent* ABoxReflectionCapture::GetBoxCaptureComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BoxReflectionCapture.GetBoxCaptureComponent");
		
		ABoxReflectionCapture_GetBoxCaptureComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ABoxReflectionCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ABoxReflectionCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BoxReflectionCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APlaneReflectionCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APlaneReflectionCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlaneReflectionCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736EA0
	 * 		Name   -> Function Engine.SphereReflectionCapture.GetSphereCaptureComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class USphereReflectionCaptureComponent* ASphereReflectionCapture::GetSphereCaptureComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SphereReflectionCapture.GetSphereCaptureComponent");
		
		ASphereReflectionCapture_GetSphereCaptureComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASphereReflectionCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASphereReflectionCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SphereReflectionCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARigidBodyBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARigidBodyBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RigidBodyBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APhysicsConstraintActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APhysicsConstraintActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsConstraintActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction APhysicsThruster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* APhysicsThruster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsThruster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736D20
	 * 		Name   -> Function Engine.RadialForceActor.ToggleForce
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ARadialForceActor::ToggleForce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.ToggleForce");
		
		ARadialForceActor_ToggleForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736D80
	 * 		Name   -> Function Engine.RadialForceActor.FireImpulse
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ARadialForceActor::FireImpulse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.FireImpulse");
		
		ARadialForceActor_FireImpulse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736DE0
	 * 		Name   -> Function Engine.RadialForceActor.EnableForce
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ARadialForceActor::EnableForce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.EnableForce");
		
		ARadialForceActor_EnableForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736E40
	 * 		Name   -> Function Engine.RadialForceActor.DisableForce
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void ARadialForceActor::DisableForce()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceActor.DisableForce");
		
		ARadialForceActor_DisableForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ARadialForceActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ARadialForceActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RadialForceActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASceneCapture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASceneCapture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCapture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736C40
	 * 		Name   -> Function Engine.SceneCapture2D.OnInterpToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ASceneCapture2D::OnInterpToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneCapture2D.OnInterpToggle");
		
		ASceneCapture2D_OnInterpToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASceneCapture2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASceneCapture2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCapture2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02736C40
	 * 		Name   -> Function Engine.SceneCaptureCube.OnInterpToggle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ASceneCaptureCube::OnInterpToggle(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureCube.OnInterpToggle");
		
		ASceneCaptureCube_OnInterpToggle_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASceneCaptureCube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASceneCaptureCube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCaptureCube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterface_CollisionDataProvider.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterface_CollisionDataProvider::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Interface_CollisionDataProvider");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FF20
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearZLimit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ELinearConstraintMotion                            ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearZLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearZLimit");
		
		UPhysicsConstraintComponent_SetLinearZLimit_Params params {};
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730090
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearYLimit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ELinearConstraintMotion                            ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearYLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearYLimit");
		
		UPhysicsConstraintComponent_SetLinearYLimit_Params params {};
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730200
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearXLimit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ELinearConstraintMotion                            ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LimitSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearXLimit(ELinearConstraintMotion ConstraintType, float LimitSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearXLimit");
		
		UPhysicsConstraintComponent_SetLinearXLimit_Params params {};
		params.ConstraintType = ConstraintType;
		params.LimitSize = LimitSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730370
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InVelTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearVelocityTarget(const struct FVector& InVelTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget");
		
		UPhysicsConstraintComponent_SetLinearVelocityTarget_Params params {};
		params.InVelTarget = InVelTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730430
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableDriveX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableDriveY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableDriveZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive");
		
		UPhysicsConstraintComponent_SetLinearVelocityDrive_Params params {};
		params.bEnableDriveX = bEnableDriveX;
		params.bEnableDriveY = bEnableDriveY;
		params.bEnableDriveZ = bEnableDriveZ;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730620
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InPosTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearPositionTarget(const struct FVector& InPosTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget");
		
		UPhysicsConstraintComponent_SetLinearPositionTarget_Params params {};
		params.InPosTarget = InPosTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027306E0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableDriveX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableDriveY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableDriveZ                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive");
		
		UPhysicsConstraintComponent_SetLinearPositionDrive_Params params {};
		params.bEnableDriveX = bEnableDriveX;
		params.bEnableDriveY = bEnableDriveY;
		params.bEnableDriveZ = bEnableDriveZ;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027308D0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InSpring                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InForceLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetLinearDriveParams(float InSpring, float InDamping, float InForceLimit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetLinearDriveParams");
		
		UPhysicsConstraintComponent_SetLinearDriveParams_Params params {};
		params.InSpring = InSpring;
		params.InDamping = InDamping;
		params.InForceLimit = InForceLimit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730AA0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetDisableCollision
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bDisableCollision                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetDisableCollision(bool bDisableCollision)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetDisableCollision");
		
		UPhysicsConstraintComponent_SetDisableCollision_Params params {};
		params.bDisableCollision = bDisableCollision;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730B80
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EConstraintFrame                                   Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     RefPosition                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetConstraintReferencePosition(EConstraintFrame Frame, const struct FVector& RefPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition");
		
		UPhysicsConstraintComponent_SetConstraintReferencePosition_Params params {};
		params.Frame = Frame;
		params.RefPosition = RefPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730CD0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EConstraintFrame                                   Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PriAxis                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SecAxis                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetConstraintReferenceOrientation(EConstraintFrame Frame, const struct FVector& PriAxis, const struct FVector& SecAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation");
		
		UPhysicsConstraintComponent_SetConstraintReferenceOrientation_Params params {};
		params.Frame = Frame;
		params.PriAxis = PriAxis;
		params.SecAxis = SecAxis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730E90
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		EConstraintFrame                                   Frame                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  RefFrame                                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetConstraintReferenceFrame(EConstraintFrame Frame, const struct FTransform& RefFrame)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame");
		
		UPhysicsConstraintComponent_SetConstraintReferenceFrame_Params params {};
		params.Frame = Frame;
		params.RefFrame = RefFrame;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02730FE0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component1                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName1                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         Component2                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        BoneName2                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetConstrainedComponents(class UPrimitiveComponent* Component1, const class FName& BoneName1, class UPrimitiveComponent* Component2, const class FName& BoneName2)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetConstrainedComponents");
		
		UPhysicsConstraintComponent_SetConstrainedComponents_Params params {};
		params.Component1 = Component1;
		params.BoneName1 = BoneName1;
		params.Component2 = Component2;
		params.BoneName2 = BoneName2;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731280
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InVelTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularVelocityTarget(const struct FVector& InVelTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget");
		
		UPhysicsConstraintComponent_SetAngularVelocityTarget_Params params {};
		params.InVelTarget = InVelTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731340
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive");
		
		UPhysicsConstraintComponent_SetAngularVelocityDrive_Params params {};
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027314A0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EAngularConstraintMotion                           ConstraintType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TwistLimitAngle                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularTwistLimit(EAngularConstraintMotion ConstraintType, float TwistLimitAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit");
		
		UPhysicsConstraintComponent_SetAngularTwistLimit_Params params {};
		params.ConstraintType = ConstraintType;
		params.TwistLimitAngle = TwistLimitAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731610
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EAngularConstraintMotion                           MotionType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Swing2LimitAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularSwing2Limit(EAngularConstraintMotion MotionType, float Swing2LimitAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit");
		
		UPhysicsConstraintComponent_SetAngularSwing2Limit_Params params {};
		params.MotionType = MotionType;
		params.Swing2LimitAngle = Swing2LimitAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731780
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EAngularConstraintMotion                           MotionType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Swing1LimitAngle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularSwing1Limit(EAngularConstraintMotion MotionType, float Swing1LimitAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit");
		
		UPhysicsConstraintComponent_SetAngularSwing1Limit_Params params {};
		params.MotionType = MotionType;
		params.Swing1LimitAngle = Swing1LimitAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027318F0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    InPosTarget                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularOrientationTarget(const struct FRotator& InPosTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget");
		
		UPhysicsConstraintComponent_SetAngularOrientationTarget_Params params {};
		params.InPosTarget = InPosTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027319C0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnableSwingDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEnableTwistDrive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive");
		
		UPhysicsConstraintComponent_SetAngularOrientationDrive_Params params {};
		params.bEnableSwingDrive = bEnableSwingDrive;
		params.bEnableTwistDrive = bEnableTwistDrive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731B20
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InSpring                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InDamping                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InForceLimit                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::SetAngularDriveParams(float InSpring, float InDamping, float InForceLimit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.SetAngularDriveParams");
		
		UPhysicsConstraintComponent_SetAngularDriveParams_Params params {};
		params.InSpring = InSpring;
		params.InDamping = InDamping;
		params.InForceLimit = InForceLimit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731CF0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.GetConstraintForce
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     OutLinearForce                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OutAngularForce                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::GetConstraintForce(struct FVector* OutLinearForce, struct FVector* OutAngularForce)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.GetConstraintForce");
		
		UPhysicsConstraintComponent_GetConstraintForce_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutLinearForce != nullptr)
			*OutLinearForce = params.OutLinearForce;
		if (OutAngularForce != nullptr)
			*OutAngularForce = params.OutAngularForce;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.ConstraintBrokenSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		int32_t                                            ConstraintIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsConstraintComponent::ConstraintBrokenSignature__DelegateSignature(int32_t ConstraintIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.ConstraintBrokenSignature__DelegateSignature");
		
		UPhysicsConstraintComponent_ConstraintBrokenSignature__DelegateSignature_Params params {};
		params.ConstraintIndex = ConstraintIndex;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02731E30
	 * 		Name   -> Function Engine.PhysicsConstraintComponent.BreakConstraint
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UPhysicsConstraintComponent::BreakConstraint()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsConstraintComponent.BreakConstraint");
		
		UPhysicsConstraintComponent_BreakConstraint_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsConstraintComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsConstraintComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsConstraintComponent");
		return ptr;
	}

	/**
	 * GetBoneWithRotation
	 */
	//FVector USkeletalMeshComponent::GetBoneWorldPos(const int32_t& boneId) const
	//{
	//	if (GET_BONE_MATRIX_OFFSET > 0x00)
	//	{
	//	
	//	   typedef void(*GetBoneMatrixType)(const USkinnedMeshComponent*, FMatrix&, int);
	//		static GetBoneMatrixType GetBoneMatrixPtr = nullptr;
	//		if (!GetBoneMatrixPtr)
	//			GetBoneMatrixPtr = reinterpret_cast<GetBoneMatrixType>((uintptr_t)GetModuleHandle(nullptr) + GET_BONE_MATRIX_OFFSET);
	//	
	//		FMatrix matrix;
	//		GetBoneMatrixPtr(this, matrix, boneId);
	//	
	//		return matrix.WPlane;
	//	}
	//	
	//	FVector worldPos{};
	//	
	//	const TArray<struct FTransform>& componentSpaceTransforms = /* CachedBoneSpaceTransforms */;
	//	int32_t componentToWorldOffset = /* 0x190 || 0x1C0 || 0x1D0 || 0x250 */;
	//	
	//	if (boneId >= componentSpaceTransforms.Count())
	//		return worldPos;
	//	
	//	FMatrix targetBoneMatrix = componentSpaceTransforms[boneId].ToMatrixWithScale();
	//	FMatrix componentToWorldMatrix = (*reinterpret_cast<CG::FTransform*>(reinterpret_cast<uintptr_t>(this) + componentToWorldOffset)).ToMatrixWithScale();
	//	FMatrix newMatrix = targetBoneMatrix * componentToWorldMatrix;
	//	
	//	worldPos = { newMatrix.WPlane.X, newMatrix.WPlane.Y, newMatrix.WPlane.Z };
	//	return worldPos;
	//}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E180
	 * 		Name   -> Function Engine.SkeletalMeshComponent.Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Stop");
		
		USkeletalMeshComponent_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E1C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetupBetweenAnimationBlueprintBlending
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::SetupBetweenAnimationBlueprintBlending()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetupBetweenAnimationBlueprintBlending");
		
		USkeletalMeshComponent_SetupBetweenAnimationBlueprintBlending_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E220
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InPos                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFireNotifies                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetPosition(float InPos, bool bFireNotifies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPosition");
		
		USkeletalMeshComponent_SetPosition_Params params {};
		params.InPos = InPos;
		params.bFireNotifies = bFireNotifies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E3A0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetPlayRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Rate                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetPlayRate(float Rate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPlayRate");
		
		USkeletalMeshComponent_SetPlayRate_Params params {};
		params.Rate = Rate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E470
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetPhysicsBlendWeight(float PhysicsBlendWeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight");
		
		USkeletalMeshComponent_SetPhysicsBlendWeight_Params params {};
		params.PhysicsBlendWeight = PhysicsBlendWeight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E540
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetMorphTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetMorphTarget(const class FName& MorphTargetName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetMorphTarget");
		
		USkeletalMeshComponent_SetMorphTarget_Params params {};
		params.MorphTargetName = MorphTargetName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E6A0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewBlendPhysics                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetEnablePhysicsBlending(bool bNewBlendPhysics)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending");
		
		USkeletalMeshComponent_SetEnablePhysicsBlending_Params params {};
		params.bNewBlendPhysics = bNewBlendPhysics;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5E0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetClothMaxDistanceScale(float Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale");
		
		USkeletalMeshComponent_SetClothMaxDistanceScale_Params params {};
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E780
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAnimInstanceClass
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      NewClass                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAnimInstanceClass(class UClass* NewClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimInstanceClass");
		
		USkeletalMeshComponent_SetAnimInstanceClass_Params params {};
		params.NewClass = NewClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E8A0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAnimationMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EAnimationMode                                     InAnimationMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAnimationMode(EAnimationMode InAnimationMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimationMode");
		
		USkeletalMeshComponent_SetAnimationMode_Params params {};
		params.InAnimationMode = InAnimationMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272E980
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimationAsset*                             NewAnimToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAnimation(class UAnimationAsset* NewAnimToPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAnimation");
		
		USkeletalMeshComponent_SetAnimation_Params params {};
		params.NewAnimToPlay = NewAnimToPlay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272EA80
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewSimulate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAllBodiesSimulatePhysics(bool bNewSimulate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics");
		
		USkeletalMeshComponent_SetAllBodiesSimulatePhysics_Params params {};
		params.bNewSimulate = bNewSimulate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272EB50
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight");
		
		USkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight_Params params {};
		params.PhysicsBlendWeight = PhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272ECB0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNewSimulate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAllBodiesBelowSimulatePhysics(const class FName& InBoneName, bool bNewSimulate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics");
		
		USkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics_Params params {};
		params.InBoneName = InBoneName;
		params.bNewSimulate = bNewSimulate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272EE00
	 * 		Name   -> Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              PhysicsBlendWeight                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::SetAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight");
		
		USkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight_Params params {};
		params.InBoneName = InBoneName;
		params.PhysicsBlendWeight = PhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.ResetClothTeleportMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::ResetClothTeleportMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetClothTeleportMode");
		
		USkeletalMeshComponent_ResetClothTeleportMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272EFD0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::ResetAllBodiesSimulatePhysics()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ResetAllBodiesSimulatePhysics");
		
		USkeletalMeshComponent_ResetAllBodiesSimulatePhysics_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272EFF0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.PlayAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimationAsset*                             NewAnimToPlay                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.PlayAnimation");
		
		USkeletalMeshComponent_PlayAnimation_Params params {};
		params.NewAnimToPlay = NewAnimToPlay;
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F150
	 * 		Name   -> Function Engine.SkeletalMeshComponent.Play
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::Play(bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.Play");
		
		USkeletalMeshComponent_Play_Params params {};
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F250
	 * 		Name   -> Function Engine.SkeletalMeshComponent.IsPlayingMontage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UAnimMontage*                                Montage                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeFromEndToConsiderFinished                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USkeletalMeshComponent::IsPlayingMontage(class UAnimMontage* Montage, float TimeFromEndToConsiderFinished)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlayingMontage");
		
		USkeletalMeshComponent_IsPlayingMontage_Params params {};
		params.Montage = Montage;
		params.TimeFromEndToConsiderFinished = TimeFromEndToConsiderFinished;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F3C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.IsPlayingAnimationMontagesOnSlotName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SlotName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USkeletalMeshComponent::IsPlayingAnimationMontagesOnSlotName(const class FName& SlotName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlayingAnimationMontagesOnSlotName");
		
		USkeletalMeshComponent_IsPlayingAnimationMontagesOnSlotName_Params params {};
		params.SlotName = SlotName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F510
	 * 		Name   -> Function Engine.SkeletalMeshComponent.IsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool USkeletalMeshComponent::IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IsPlaying");
		
		USkeletalMeshComponent_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F560
	 * 		Name   -> Function Engine.SkeletalMeshComponent.IncrementIKLegMute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            LegIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::IncrementIKLegMute(int32_t LegIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.IncrementIKLegMute");
		
		USkeletalMeshComponent_IncrementIKLegMute_Params params {};
		params.LegIndex = LegIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F650
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetTrueBasedPawns
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	TArray<class APawn*> USkeletalMeshComponent::GetTrueBasedPawns()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetTrueBasedPawns");
		
		USkeletalMeshComponent_GetTrueBasedPawns_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F720
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USkeletalMeshComponent::GetPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPosition");
		
		USkeletalMeshComponent_GetPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F770
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetPlayRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USkeletalMeshComponent::GetPlayRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetPlayRate");
		
		USkeletalMeshComponent_GetPlayRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F7C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetMorphTarget
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class FName                                        MorphTargetName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float USkeletalMeshComponent::GetMorphTarget(const class FName& MorphTargetName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetMorphTarget");
		
		USkeletalMeshComponent_GetMorphTarget_Params params {};
		params.MorphTargetName = MorphTargetName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F8A0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetFirstBoneWithChildren
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class FName USkeletalMeshComponent::GetFirstBoneWithChildren()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetFirstBoneWithChildren");
		
		USkeletalMeshComponent_GetFirstBoneWithChildren_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E56A70
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float USkeletalMeshComponent::GetClothMaxDistanceScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale");
		
		USkeletalMeshComponent_GetClothMaxDistanceScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F920
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetAnimInstance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UAnimInstance* USkeletalMeshComponent::GetAnimInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimInstance");
		
		USkeletalMeshComponent_GetAnimInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F940
	 * 		Name   -> Function Engine.SkeletalMeshComponent.GetAnimationMode
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	EAnimationMode USkeletalMeshComponent::GetAnimationMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.GetAnimationMode");
		
		USkeletalMeshComponent_GetAnimationMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::ForceClothNextUpdateTeleportAndReset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleportAndReset");
		
		USkeletalMeshComponent_ForceClothNextUpdateTeleportAndReset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::ForceClothNextUpdateTeleport()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ForceClothNextUpdateTeleport");
		
		USkeletalMeshComponent_ForceClothNextUpdateTeleport_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F960
	 * 		Name   -> Function Engine.SkeletalMeshComponent.FlushMorphTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::FlushMorphTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.FlushMorphTargets");
		
		USkeletalMeshComponent_FlushMorphTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272F980
	 * 		Name   -> Function Engine.SkeletalMeshComponent.DecrementIKLegMute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            LegIndex                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::DecrementIKLegMute(int32_t LegIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.DecrementIKLegMute");
		
		USkeletalMeshComponent_DecrementIKLegMute_Params params {};
		params.LegIndex = LegIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FA70
	 * 		Name   -> Function Engine.SkeletalMeshComponent.ClearMorphTargets
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::ClearMorphTargets()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.ClearMorphTargets");
		
		USkeletalMeshComponent_ClearMorphTargets_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FAA0
	 * 		Name   -> Function Engine.SkeletalMeshComponent.BPValidBoneToUnhide
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            BoneIndex                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool USkeletalMeshComponent::BPValidBoneToUnhide(int32_t BoneIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BPValidBoneToUnhide");
		
		USkeletalMeshComponent_BPValidBoneToUnhide_Params params {};
		params.BoneIndex = BoneIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FB90
	 * 		Name   -> Function Engine.SkeletalMeshComponent.BPTickPose
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::BPTickPose(float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BPTickPose");
		
		USkeletalMeshComponent_BPTickPose_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FC60
	 * 		Name   -> Function Engine.SkeletalMeshComponent.BPSetBoneModifiers
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FBoneModifierNamed>                  NamedBoneModifiers                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void USkeletalMeshComponent::BPSetBoneModifiers(TArray<struct FBoneModifierNamed> NamedBoneModifiers)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BPSetBoneModifiers");
		
		USkeletalMeshComponent_BPSetBoneModifiers_Params params {};
		params.NamedBoneModifiers = NamedBoneModifiers;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FD20
	 * 		Name   -> Function Engine.SkeletalMeshComponent.BPRefreshBoneTransforms
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkeletalMeshComponent::BPRefreshBoneTransforms()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.BPRefreshBoneTransforms");
		
		USkeletalMeshComponent_BPRefreshBoneTransforms_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272FD50
	 * 		Name   -> Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InBoneName                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              AddPhysicsBlendWeight                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSkipCustomPhysicsType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshComponent::AccumulateAllBodiesBelowPhysicsBlendWeight(const class FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight");
		
		USkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight_Params params {};
		params.InBoneName = InBoneName;
		params.AddPhysicsBlendWeight = AddPhysicsBlendWeight;
		params.bSkipCustomPhysicsType = bSkipCustomPhysicsType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkeletalMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkeletalMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkeletalMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMatineeAnimInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMatineeAnimInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MatineeAnimInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023204F0
	 * 		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset
	 * 		Flags  -> (Native, Public)
	 */
	void ASkeletalMeshActor::OnRep_ReplicatedPhysAsset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedPhysAsset");
		
		ASkeletalMeshActor_OnRep_ReplicatedPhysAsset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320550
	 * 		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh
	 * 		Flags  -> (Native, Public)
	 */
	void ASkeletalMeshActor::OnRep_ReplicatedMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMesh");
		
		ASkeletalMeshActor_OnRep_ReplicatedMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023205B0
	 * 		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1
	 * 		Flags  -> (Native, Public)
	 */
	void ASkeletalMeshActor::OnRep_ReplicatedMaterial1()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial1");
		
		ASkeletalMeshActor_OnRep_ReplicatedMaterial1_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320610
	 * 		Name   -> Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0
	 * 		Flags  -> (Native, Public)
	 */
	void ASkeletalMeshActor::OnRep_ReplicatedMaterial0()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshActor.OnRep_ReplicatedMaterial0");
		
		ASkeletalMeshActor_OnRep_ReplicatedMaterial0_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ASkeletalMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ASkeletalMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkeletalMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AStaticMeshActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AStaticMeshActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.StaticMeshActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02320670
	 * 		Name   -> Function Engine.InteractiveFoliageActor.CapsuleTouched
	 * 		Flags  -> (Final, Native, Protected, HasOutParms)
	 * Parameters:
	 * 		class AActor*                                      Other                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         OtherComp                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            OtherBodyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFromSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OverlapInfo                                                (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void AInteractiveFoliageActor::CapsuleTouched(class AActor* Other, class UPrimitiveComponent* OtherComp, int32_t OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InteractiveFoliageActor.CapsuleTouched");
		
		AInteractiveFoliageActor_CapsuleTouched_Params params {};
		params.Other = Other;
		params.OtherComp = OtherComp;
		params.OtherBodyIndex = OtherBodyIndex;
		params.bFromSweep = bFromSweep;
		params.OverlapInfo = OverlapInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AInteractiveFoliageActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AInteractiveFoliageActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InteractiveFoliageActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATargetPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATargetPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TargetPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATextRenderActor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATextRenderActor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextRenderActor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATriggerBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATriggerBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TriggerBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATriggerBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATriggerBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TriggerBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATriggerCapsule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATriggerCapsule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TriggerCapsule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATriggerSphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATriggerSphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TriggerSphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ATrueSkyActorParent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ATrueSkyActorParent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TrueSkyActorParent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction AVectorFieldVolume.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* AVectorFieldVolume::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VectorFieldVolume");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ApplicationLifecycleComponent.ApplicationLifetimeDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UApplicationLifecycleComponent::ApplicationLifetimeDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ApplicationLifecycleComponent.ApplicationLifetimeDelegate__DelegateSignature");
		
		UApplicationLifecycleComponent_ApplicationLifetimeDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UApplicationLifecycleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UApplicationLifecycleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ApplicationLifecycleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272BE20
	 * 		Name   -> Function Engine.NavigationSystem.SimpleMoveToLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Goal                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UNavigationSystem::STATIC_SimpleMoveToLocation(class AController* Controller, const struct FVector& Goal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SimpleMoveToLocation");
		
		UNavigationSystem_SimpleMoveToLocation_Params params {};
		params.Controller = Controller;
		params.Goal = Goal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272BF50
	 * 		Name   -> Function Engine.NavigationSystem.SimpleMoveToActor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AController*                                 Controller                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      Goal                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavigationSystem::STATIC_SimpleMoveToActor(class AController* Controller, class AActor* Goal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.SimpleMoveToActor");
		
		UNavigationSystem_SimpleMoveToActor_Params params {};
		params.Controller = Controller;
		params.Goal = Goal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272C0A0
	 * 		Name   -> Function Engine.NavigationSystem.ProjectPointToNavigationEx
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Extent                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UNavigationSystem::STATIC_ProjectPointToNavigationEx(class UObject* WorldContext, const struct FVector& Point, const struct FVector& Extent, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.ProjectPointToNavigationEx");
		
		UNavigationSystem_ProjectPointToNavigationEx_Params params {};
		params.WorldContext = WorldContext;
		params.Point = Point;
		params.Extent = Extent;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272C390
	 * 		Name   -> Function Engine.NavigationSystem.ProjectPointToNavigation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UNavigationSystem::STATIC_ProjectPointToNavigation(class UObject* WorldContext, const struct FVector& Point, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.ProjectPointToNavigation");
		
		UNavigationSystem_ProjectPointToNavigation_Params params {};
		params.WorldContext = WorldContext;
		params.Point = Point;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.NavigationSystem.OnNavDataRegistered__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavigationSystem::OnNavDataRegistered__DelegateSignature(class ANavigationData* NavData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.OnNavDataRegistered__DelegateSignature");
		
		UNavigationSystem_OnNavDataRegistered__DelegateSignature_Params params {};
		params.NavData = NavData;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272C600
	 * 		Name   -> Function Engine.NavigationSystem.NavigationRaycast
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     RayStart                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     RayEnd                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 Querier                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UNavigationSystem::STATIC_NavigationRaycast(class UObject* WorldContext, const struct FVector& RayStart, const struct FVector& RayEnd, struct FVector* HitLocation, class UClass* FilterClass, class AController* Querier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.NavigationRaycast");
		
		UNavigationSystem_NavigationRaycast_Params params {};
		params.WorldContext = WorldContext;
		params.RayStart = RayStart;
		params.RayEnd = RayEnd;
		params.FilterClass = FilterClass;
		params.Querier = Querier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HitLocation != nullptr)
			*HitLocation = params.HitLocation;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272C950
	 * 		Name   -> Function Engine.NavigationSystem.IsNavigationBeingBuilt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UNavigationSystem::STATIC_IsNavigationBeingBuilt(class UObject* WorldContext)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.IsNavigationBeingBuilt");
		
		UNavigationSystem_IsNavigationBeingBuilt_Params params {};
		params.WorldContext = WorldContext;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272CA70
	 * 		Name   -> Function Engine.NavigationSystem.GetRandomReachablePointInMinMaxRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              MinRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRandomStream                               RandStream                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		struct FVector                                     PathDirection                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DotLimit                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UNavigationSystem::STATIC_GetRandomReachablePointInMinMaxRadius(class UObject* WorldContext, const struct FVector& Origin, float MinRadius, float MaxRadius, const struct FRandomStream& RandStream, const struct FVector& PathDirection, float DotLimit, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomReachablePointInMinMaxRadius");
		
		UNavigationSystem_GetRandomReachablePointInMinMaxRadius_Params params {};
		params.WorldContext = WorldContext;
		params.Origin = Origin;
		params.MinRadius = MinRadius;
		params.MaxRadius = MaxRadius;
		params.RandStream = RandStream;
		params.PathDirection = PathDirection;
		params.DotLimit = DotLimit;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272CF80
	 * 		Name   -> Function Engine.NavigationSystem.GetRandomPointInRadius
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UNavigationSystem::STATIC_GetRandomPointInRadius(class UObject* WorldContext, const struct FVector& Origin, float Radius, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomPointInRadius");
		
		UNavigationSystem_GetRandomPointInRadius_Params params {};
		params.WorldContext = WorldContext;
		params.Origin = Origin;
		params.Radius = Radius;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272D2A0
	 * 		Name   -> Function Engine.NavigationSystem.GetRandomPoint
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UNavigationSystem::STATIC_GetRandomPoint(class UObject* WorldContext, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetRandomPoint");
		
		UNavigationSystem_GetRandomPoint_Params params {};
		params.WorldContext = WorldContext;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272D490
	 * 		Name   -> Function Engine.NavigationSystem.GetPathLength
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              PathLength                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	ENavigationQueryResult UNavigationSystem::STATIC_GetPathLength(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathLength, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetPathLength");
		
		UNavigationSystem_GetPathLength_Params params {};
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PathLength != nullptr)
			*PathLength = params.PathLength;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272D7E0
	 * 		Name   -> Function Engine.NavigationSystem.GetPathCost
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              PathCost                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class ANavigationData*                             NavData                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	ENavigationQueryResult UNavigationSystem::STATIC_GetPathCost(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, float* PathCost, class ANavigationData* NavData, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.GetPathCost");
		
		UNavigationSystem_GetPathCost_Params params {};
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.NavData = NavData;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (PathCost != nullptr)
			*PathCost = params.PathCost;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272DB30
	 * 		Name   -> Function Engine.NavigationSystem.FindPathToLocationSynchronously
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      PathfindingContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UNavigationPath* UNavigationSystem::STATIC_FindPathToLocationSynchronously(class UObject* WorldContext, const struct FVector& PathStart, const struct FVector& PathEnd, class AActor* PathfindingContext, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.FindPathToLocationSynchronously");
		
		UNavigationSystem_FindPathToLocationSynchronously_Params params {};
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.PathEnd = PathEnd;
		params.PathfindingContext = PathfindingContext;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272DE00
	 * 		Name   -> Function Engine.NavigationSystem.FindPathToActorSynchronously
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContext                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PathStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      GoalActor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TetherDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      PathfindingContext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UNavigationPath* UNavigationSystem::STATIC_FindPathToActorSynchronously(class UObject* WorldContext, const struct FVector& PathStart, class AActor* GoalActor, float TetherDistance, class AActor* PathfindingContext, class UClass* FilterClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationSystem.FindPathToActorSynchronously");
		
		UNavigationSystem_FindPathToActorSynchronously_Params params {};
		params.WorldContext = WorldContext;
		params.PathStart = PathStart;
		params.GoalActor = GoalActor;
		params.TetherDistance = TetherDistance;
		params.PathfindingContext = PathfindingContext;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNetworkPredictionInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNetworkPredictionInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NetworkPredictionInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFloatingPawnMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFloatingPawnMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FloatingPawnMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpectatorPawnMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpectatorPawnMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpectatorPawnMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326E50
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetUseAutoGears
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bUseAuto                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetUseAutoGears(bool bUseAuto)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetUseAutoGears");
		
		UWheeledVehicleMovementComponent_SetUseAutoGears_Params params {};
		params.bUseAuto = bUseAuto;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02326F30
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetThrottleInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Throttle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetThrottleInput(float Throttle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetThrottleInput");
		
		UWheeledVehicleMovementComponent_SetThrottleInput_Params params {};
		params.Throttle = Throttle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327030
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetTargetGear
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            GearNum                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetTargetGear(int32_t GearNum, bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetTargetGear");
		
		UWheeledVehicleMovementComponent_SetTargetGear_Params params {};
		params.GearNum = GearNum;
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023271C0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetSteeringInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Steering                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetSteeringInput(float Steering)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetSteeringInput");
		
		UWheeledVehicleMovementComponent_SetSteeringInput_Params params {};
		params.Steering = Steering;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023272C0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetHandbrakeInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewHandbrake                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetHandbrakeInput(bool bNewHandbrake)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetHandbrakeInput");
		
		UWheeledVehicleMovementComponent_SetHandbrakeInput_Params params {};
		params.bNewHandbrake = bNewHandbrake;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023273A0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetGearUp
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewGearUp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetGearUp(bool bNewGearUp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetGearUp");
		
		UWheeledVehicleMovementComponent_SetGearUp_Params params {};
		params.bNewGearUp = bNewGearUp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327480
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.SetGearDown
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewGearDown                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::SetGearDown(bool bNewGearDown)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.SetGearDown");
		
		UWheeledVehicleMovementComponent_SetGearDown_Params params {};
		params.bNewGearDown = bNewGearDown;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327560
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.ServerUpdateState
	 * 		Flags  -> (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
	 * Parameters:
	 * 		float                                              InSteeringInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InThrottleInput                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InBrakeInput                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InHandbrakeInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            CurrentGear                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UWheeledVehicleMovementComponent::ServerUpdateState(float InSteeringInput, float InThrottleInput, float InBrakeInput, float InHandbrakeInput, int32_t CurrentGear)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.ServerUpdateState");
		
		UWheeledVehicleMovementComponent_ServerUpdateState_Params params {};
		params.InSteeringInput = InSteeringInput;
		params.InThrottleInput = InThrottleInput;
		params.InBrakeInput = InBrakeInput;
		params.InHandbrakeInput = InHandbrakeInput;
		params.CurrentGear = CurrentGear;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023278A0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetUseAutoGears
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UWheeledVehicleMovementComponent::GetUseAutoGears()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetUseAutoGears");
		
		UWheeledVehicleMovementComponent_GetUseAutoGears_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023278E0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetThrottleInput
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UWheeledVehicleMovementComponent::GetThrottleInput()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetThrottleInput");
		
		UWheeledVehicleMovementComponent_GetThrottleInput_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327920
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetTargetGear
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UWheeledVehicleMovementComponent::GetTargetGear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetTargetGear");
		
		UWheeledVehicleMovementComponent_GetTargetGear_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327970
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetForwardSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UWheeledVehicleMovementComponent::GetForwardSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetForwardSpeed");
		
		UWheeledVehicleMovementComponent_GetForwardSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023279C0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetEngineRotationSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UWheeledVehicleMovementComponent::GetEngineRotationSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetEngineRotationSpeed");
		
		UWheeledVehicleMovementComponent_GetEngineRotationSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023279F0
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetEngineMaxRotationSpeed
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UWheeledVehicleMovementComponent::GetEngineMaxRotationSpeed()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetEngineMaxRotationSpeed");
		
		UWheeledVehicleMovementComponent_GetEngineMaxRotationSpeed_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327A10
	 * 		Name   -> Function Engine.WheeledVehicleMovementComponent.GetCurrentGear
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UWheeledVehicleMovementComponent::GetCurrentGear()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.WheeledVehicleMovementComponent.GetCurrentGear");
		
		UWheeledVehicleMovementComponent_GetCurrentGear_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWheeledVehicleMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWheeledVehicleMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WheeledVehicleMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWheeledVehicleMovementComponent4W.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWheeledVehicleMovementComponent4W::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WheeledVehicleMovementComponent4W");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327A60
	 * 		Name   -> Function Engine.ProjectileMovementComponent.StopSimulating
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FHitResult                                  HitResult                                                  (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UProjectileMovementComponent::StopSimulating(const struct FHitResult& HitResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.StopSimulating");
		
		UProjectileMovementComponent_StopSimulating_Params params {};
		params.HitResult = HitResult;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327B60
	 * 		Name   -> Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UProjectileMovementComponent::SetVelocityInLocalSpace(const struct FVector& NewVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace");
		
		UProjectileMovementComponent_SetVelocityInLocalSpace_Params params {};
		params.NewVelocity = NewVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UProjectileMovementComponent::OnProjectileStopDelegate__DelegateSignature(const struct FHitResult& ImpactResult)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature");
		
		UProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature_Params params {};
		params.ImpactResult = ImpactResult;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FHitResult                                  ImpactResult                                               (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     ImpactVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UProjectileMovementComponent::OnProjectileBounceDelegate__DelegateSignature(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature");
		
		UProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature_Params params {};
		params.ImpactResult = ImpactResult;
		params.ImpactVelocity = ImpactVelocity;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327C40
	 * 		Name   -> Function Engine.ProjectileMovementComponent.LimitVelocity
	 * 		Flags  -> (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     NewVelocity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UProjectileMovementComponent::LimitVelocity(const struct FVector& NewVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ProjectileMovementComponent.LimitVelocity");
		
		UProjectileMovementComponent_LimitVelocity_Params params {};
		params.NewVelocity = NewVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UProjectileMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UProjectileMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ProjectileMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URotatingMovementComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URotatingMovementComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RotatingMovementComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327D60
	 * 		Name   -> Function Engine.NavRelevantComponent.SetNavigationRelevancy
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bRelevant                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavRelevantComponent::SetNavigationRelevancy(bool bRelevant)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavRelevantComponent.SetNavigationRelevancy");
		
		UNavRelevantComponent_SetNavigationRelevancy_Params params {};
		params.bRelevant = bRelevant;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavRelevantComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavRelevantComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavRelevantComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkCustomInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkCustomInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkCustomInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkCustomComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkCustomComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkCustomComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavModifierComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavModifierComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavModifierComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272BC50
	 * 		Name   -> Function Engine.PawnNoiseEmitterComponent.MakeNoise
	 * 		Flags  -> (BlueprintAuthorityOnly, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      NoiseMaker                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Loudness                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     NoiseLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UPawnNoiseEmitterComponent::MakeNoise(class AActor* NoiseMaker, float Loudness, const struct FVector& NoiseLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PawnNoiseEmitterComponent.MakeNoise");
		
		UPawnNoiseEmitterComponent_MakeNoise_Params params {};
		params.NoiseMaker = NoiseMaker;
		params.Loudness = Loudness;
		params.NoiseLocation = NoiseLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPawnNoiseEmitterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPawnNoiseEmitterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PawnNoiseEmitterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B4F0
	 * 		Name   -> Function Engine.PhysicsHandleComponent.SetTargetRotation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsHandleComponent::SetTargetRotation(const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetRotation");
		
		UPhysicsHandleComponent_SetTargetRotation_Params params {};
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B5D0
	 * 		Name   -> Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    NewRotation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsHandleComponent::SetTargetLocationAndRotation(const struct FVector& NewLocation, const struct FRotator& NewRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation");
		
		UPhysicsHandleComponent_SetTargetLocationAndRotation_Params params {};
		params.NewLocation = NewLocation;
		params.NewRotation = NewRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B780
	 * 		Name   -> Function Engine.PhysicsHandleComponent.SetTargetLocation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsHandleComponent::SetTargetLocation(const struct FVector& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.SetTargetLocation");
		
		UPhysicsHandleComponent_SetTargetLocation_Params params {};
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B860
	 * 		Name   -> Function Engine.PhysicsHandleComponent.ReleaseComponent
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UPhysicsHandleComponent::ReleaseComponent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.ReleaseComponent");
		
		UPhysicsHandleComponent_ReleaseComponent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B880
	 * 		Name   -> Function Engine.PhysicsHandleComponent.GrabComponent
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        InBoneName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     GrabLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bConstrainRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsHandleComponent::GrabComponent(class UPrimitiveComponent* Component, const class FName& InBoneName, const struct FVector& GrabLocation, bool bConstrainRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GrabComponent");
		
		UPhysicsHandleComponent_GrabComponent_Params params {};
		params.Component = Component;
		params.InBoneName = InBoneName;
		params.GrabLocation = GrabLocation;
		params.bConstrainRotation = bConstrainRotation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272BB10
	 * 		Name   -> Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     TargetLocation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    TargetRotation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPhysicsHandleComponent::GetTargetLocationAndRotation(struct FVector* TargetLocation, struct FRotator* TargetRotation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation");
		
		UPhysicsHandleComponent_GetTargetLocationAndRotation_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TargetLocation != nullptr)
			*TargetLocation = params.TargetLocation;
		if (TargetRotation != nullptr)
			*TargetRotation = params.TargetRotation;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsHandleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsHandleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsHandleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.AtmosphericFogComponent.StartPrecompute
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAtmosphericFogComponent::StartPrecompute()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.StartPrecompute");
		
		UAtmosphericFogComponent_StartPrecompute_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A360
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetSunMultiplier
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewSunMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetSunMultiplier(float NewSunMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetSunMultiplier");
		
		UAtmosphericFogComponent_SetSunMultiplier_Params params {};
		params.NewSunMultiplier = NewSunMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728BD0
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetStartDistance
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewStartDistance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetStartDistance(float NewStartDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetStartDistance");
		
		UAtmosphericFogComponent_SetStartDistance_Params params {};
		params.NewStartDistance = NewStartDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A470
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetPrecomputeParams
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DensityHeight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            MaxScatteringOrder                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            InscatterAltitudeSampleNum                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetPrecomputeParams(float DensityHeight, int32_t MaxScatteringOrder, int32_t InscatterAltitudeSampleNum)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetPrecomputeParams");
		
		UAtmosphericFogComponent_SetPrecomputeParams_Params params {};
		params.DensityHeight = DensityHeight;
		params.MaxScatteringOrder = MaxScatteringOrder;
		params.InscatterAltitudeSampleNum = InscatterAltitudeSampleNum;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A630
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetFogTexturesDirectly
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  ScatterTexture0                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture2D*                                  ScatterTexture1                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture2D*                                  LossTexture0                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture2D*                                  LossTexture1                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InInterpolation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetFogTexturesDirectly(class UTexture2D* ScatterTexture0, class UTexture2D* ScatterTexture1, class UTexture2D* LossTexture0, class UTexture2D* LossTexture1, float InInterpolation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogTexturesDirectly");
		
		UAtmosphericFogComponent_SetFogTexturesDirectly_Params params {};
		params.ScatterTexture0 = ScatterTexture0;
		params.ScatterTexture1 = ScatterTexture1;
		params.LossTexture0 = LossTexture0;
		params.LossTexture1 = LossTexture1;
		params.InInterpolation = InInterpolation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A930
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetFogOverTimeIndices
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Texture0                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Texture1                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InInterpolation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetFogOverTimeIndices(int32_t Texture0, int32_t Texture1, float InInterpolation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogOverTimeIndices");
		
		UAtmosphericFogComponent_SetFogOverTimeIndices_Params params {};
		params.Texture0 = Texture0;
		params.Texture1 = Texture1;
		params.InInterpolation = InInterpolation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272AB10
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetFogMultiplier
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewFogMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetFogMultiplier(float NewFogMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetFogMultiplier");
		
		UAtmosphericFogComponent_SetFogMultiplier_Params params {};
		params.NewFogMultiplier = NewFogMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272AC20
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDistanceScale
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDistanceScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDistanceScale(float NewDistanceScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceScale");
		
		UAtmosphericFogComponent_SetDistanceScale_Params params {};
		params.NewDistanceScale = NewDistanceScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272AD30
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDistanceOffset
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDistanceOffset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDistanceOffset(float NewDistanceOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDistanceOffset");
		
		UAtmosphericFogComponent_SetDistanceOffset_Params params {};
		params.NewDistanceOffset = NewDistanceOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272AE40
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDensityOffset
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDensityOffset                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDensityOffset(float NewDensityOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityOffset");
		
		UAtmosphericFogComponent_SetDensityOffset_Params params {};
		params.NewDensityOffset = NewDensityOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728AC0
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDensityMultiplier
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDensityMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDensityMultiplier(float NewDensityMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDensityMultiplier");
		
		UAtmosphericFogComponent_SetDensityMultiplier_Params params {};
		params.NewDensityMultiplier = NewDensityMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272AF50
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDefaultLightColor
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDefaultLightColor(const struct FLinearColor& NewLightColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultLightColor");
		
		UAtmosphericFogComponent_SetDefaultLightColor_Params params {};
		params.NewLightColor = NewLightColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B070
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetDefaultBrightness
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetDefaultBrightness(float NewBrightness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetDefaultBrightness");
		
		UAtmosphericFogComponent_SetDefaultBrightness_Params params {};
		params.NewBrightness = NewBrightness;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B180
	 * 		Name   -> Function Engine.AtmosphericFogComponent.SetAltitudeScale
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewAltitudeScale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::SetAltitudeScale(float NewAltitudeScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.SetAltitudeScale");
		
		UAtmosphericFogComponent_SetAltitudeScale_Params params {};
		params.NewAltitudeScale = NewAltitudeScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B290
	 * 		Name   -> Function Engine.AtmosphericFogComponent.DisableSunDisk
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               NewSunDisk                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::DisableSunDisk(bool NewSunDisk)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableSunDisk");
		
		UAtmosphericFogComponent_DisableSunDisk_Params params {};
		params.NewSunDisk = NewSunDisk;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272B3C0
	 * 		Name   -> Function Engine.AtmosphericFogComponent.DisableGroundScattering
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               NewGroundScattering                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAtmosphericFogComponent::DisableGroundScattering(bool NewGroundScattering)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AtmosphericFogComponent.DisableGroundScattering");
		
		UAtmosphericFogComponent_DisableGroundScattering_Params params {};
		params.NewGroundScattering = NewGroundScattering;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAtmosphericFogComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAtmosphericFogComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AtmosphericFogComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundAttenuation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundAttenuation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundAttenuation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729430
	 * 		Name   -> Function Engine.AudioComponent.Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAudioComponent::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Stop");
		
		UAudioComponent_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729450
	 * 		Name   -> Function Engine.AudioComponent.SetWaveParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USoundWave*                                  InWave                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetWaveParameter(const class FName& InName, class USoundWave* InWave)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetWaveParameter");
		
		UAudioComponent_SetWaveParameter_Params params {};
		params.InName = InName;
		params.InWave = InWave;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027295A0
	 * 		Name   -> Function Engine.AudioComponent.SetVolumeMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewVolumeMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetVolumeMultiplier(float NewVolumeMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetVolumeMultiplier");
		
		UAudioComponent_SetVolumeMultiplier_Params params {};
		params.NewVolumeMultiplier = NewVolumeMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729670
	 * 		Name   -> Function Engine.AudioComponent.SetUISound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInUISound                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetUISound(bool bInUISound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetUISound");
		
		UAudioComponent_SetUISound_Params params {};
		params.bInUISound = bInUISound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729740
	 * 		Name   -> Function Engine.AudioComponent.SetSound
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  NewSound                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetSound(class USoundBase* NewSound)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetSound");
		
		UAudioComponent_SetSound_Params params {};
		params.NewSound = NewSound;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729810
	 * 		Name   -> Function Engine.AudioComponent.SetPitchMultiplier
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewPitchMultiplier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetPitchMultiplier(float NewPitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetPitchMultiplier");
		
		UAudioComponent_SetPitchMultiplier_Params params {};
		params.NewPitchMultiplier = NewPitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027298E0
	 * 		Name   -> Function Engine.AudioComponent.SetIntParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetIntParameter(const class FName& InName, int32_t InInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetIntParameter");
		
		UAudioComponent_SetIntParameter_Params params {};
		params.InName = InName;
		params.InInt = InInt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729A30
	 * 		Name   -> Function Engine.AudioComponent.SetFloatParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetFloatParameter(const class FName& InName, float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetFloatParameter");
		
		UAudioComponent_SetFloatParameter_Params params {};
		params.InName = InName;
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729B90
	 * 		Name   -> Function Engine.AudioComponent.SetBoolParameter
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::SetBoolParameter(const class FName& InName, bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.SetBoolParameter");
		
		UAudioComponent_SetBoolParameter_Params params {};
		params.InName = InName;
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729CF0
	 * 		Name   -> Function Engine.AudioComponent.Play
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::Play(float StartTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.Play");
		
		UAudioComponent_Play_Params params {};
		params.StartTime = StartTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AudioComponent.OnQueueSubtitles__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		TArray<struct FSubtitleCue>                        Subtitles                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		float                                              CueDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::OnQueueSubtitles__DelegateSignature(TArray<struct FSubtitleCue> Subtitles, float CueDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.OnQueueSubtitles__DelegateSignature");
		
		UAudioComponent_OnQueueSubtitles__DelegateSignature_Params params {};
		params.Subtitles = Subtitles;
		params.CueDuration = CueDuration;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AudioComponent.OnAudioFinished__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void UAudioComponent::OnAudioFinished__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.OnAudioFinished__DelegateSignature");
		
		UAudioComponent_OnAudioFinished__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729DD0
	 * 		Name   -> Function Engine.AudioComponent.IsPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	bool UAudioComponent::IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.IsPlaying");
		
		UAudioComponent_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729E00
	 * 		Name   -> Function Engine.AudioComponent.FadeOut
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeOutDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::FadeOut(float FadeOutDuration, float FadeVolumeLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeOut");
		
		UAudioComponent_FadeOut_Params params {};
		params.FadeOutDuration = FadeOutDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729F60
	 * 		Name   -> Function Engine.AudioComponent.FadeIn
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              FadeInDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FadeVolumeLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.FadeIn");
		
		UAudioComponent_FadeIn_Params params {};
		params.FadeInDuration = FadeInDuration;
		params.FadeVolumeLevel = FadeVolumeLevel;
		params.StartTime = StartTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A140
	 * 		Name   -> Function Engine.AudioComponent.AdjustVolume
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              AdjustVolumeDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AdjustVolumeLevel                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAudioComponent::AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustVolume");
		
		UAudioComponent_AdjustVolume_Params params {};
		params.AdjustVolumeDuration = AdjustVolumeDuration;
		params.AdjustVolumeLevel = AdjustVolumeLevel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0272A2A0
	 * 		Name   -> Function Engine.AudioComponent.AdjustAttenuation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FAttenuationSettings                        InAttenuationSettings                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UAudioComponent::AdjustAttenuation(const struct FAttenuationSettings& InAttenuationSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AudioComponent.AdjustAttenuation");
		
		UAudioComponent_AdjustAttenuation_Params params {};
		params.InAttenuationSettings = InAttenuationSettings;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAudioComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAudioComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AudioComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027292E0
	 * 		Name   -> Function Engine.CameraComponent.GetCameraView
	 * 		Flags  -> (RequiredAPI, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FMinimalViewInfo                            DesiredView                                                (Parm, OutParm)
	 */
	void UCameraComponent::GetCameraView(float DeltaTime, struct FMinimalViewInfo* DesiredView)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CameraComponent.GetCameraView");
		
		UCameraComponent_GetCameraView_Params params {};
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DesiredView != nullptr)
			*DesiredView = params.DesiredView;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChildActorComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChildActorComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ChildActorComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729050
	 * 		Name   -> Function Engine.DecalComponent.SetSortOrder
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDecalComponent::SetSortOrder(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetSortOrder");
		
		UDecalComponent_SetSortOrder_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729160
	 * 		Name   -> Function Engine.DecalComponent.SetDecalMaterial
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          NewDecalMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDecalComponent::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.SetDecalMaterial");
		
		UDecalComponent_SetDecalMaterial_Params params {};
		params.NewDecalMaterial = NewDecalMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729270
	 * 		Name   -> Function Engine.DecalComponent.GetDecalMaterial
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class UMaterialInterface* UDecalComponent::GetDecalMaterial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.GetDecalMaterial");
		
		UDecalComponent_GetDecalMaterial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02729290
	 * 		Name   -> Function Engine.DecalComponent.CreateDynamicMaterialInstance
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	class UMaterialInstanceDynamic* UDecalComponent::CreateDynamicMaterialInstance()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CreateDynamicMaterialInstance");
		
		UDecalComponent_CreateDynamicMaterialInstance_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027292C0
	 * 		Name   -> Function Engine.DecalComponent.CheckDestructionFirst
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UDecalComponent::CheckDestructionFirst()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CheckDestructionFirst");
		
		UDecalComponent_CheckDestructionFirst_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027292C0
	 * 		Name   -> Function Engine.DecalComponent.CheckDestruction
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UDecalComponent::CheckDestruction()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DecalComponent.CheckDestruction");
		
		UDecalComponent_CheckDestruction_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDecalComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDecalComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DecalComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728640
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetStartDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetStartDistance(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetStartDistance");
		
		UExponentialHeightFogComponent_SetStartDistance_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728750
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetFogMaxOpacity(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity");
		
		UExponentialHeightFogComponent_SetFogMaxOpacity_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728860
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetFogInscatteringColor(const struct FLinearColor& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor");
		
		UExponentialHeightFogComponent_SetFogInscatteringColor_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027289B0
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetFogHeightFalloff(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff");
		
		UExponentialHeightFogComponent_SetFogHeightFalloff_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728AC0
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetFogDensity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetFogDensity(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetFogDensity");
		
		UExponentialHeightFogComponent_SetFogDensity_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728BD0
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetDirectionalInscatteringStartDistance(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance");
		
		UExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728CE0
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetDirectionalInscatteringExponent(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent");
		
		UExponentialHeightFogComponent_SetDirectionalInscatteringExponent_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728DF0
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetDirectionalInscatteringColor(const struct FLinearColor& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor");
		
		UExponentialHeightFogComponent_SetDirectionalInscatteringColor_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728F40
	 * 		Name   -> Function Engine.ExponentialHeightFogComponent.SetAdditionalStartDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UExponentialHeightFogComponent::SetAdditionalStartDistance(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ExponentialHeightFogComponent.SetAdditionalStartDistance");
		
		UExponentialHeightFogComponent_SetAdditionalStartDistance_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExponentialHeightFogComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExponentialHeightFogComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ExponentialHeightFogComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightComponentBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightComponentBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightComponentBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727880
	 * 		Name   -> Function Engine.LightComponent.SetShadowDistanceFade
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewFadeFraction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetShadowDistanceFade(float NewFadeFraction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetShadowDistanceFade");
		
		ULightComponent_SetShadowDistanceFade_Params params {};
		params.NewFadeFraction = NewFadeFraction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727970
	 * 		Name   -> Function Engine.LightComponent.SetLightFunctionScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     NewLightFunctionScale                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetLightFunctionScale(const struct FVector& NewLightFunctionScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionScale");
		
		ULightComponent_SetLightFunctionScale_Params params {};
		params.NewLightFunctionScale = NewLightFunctionScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727AC0
	 * 		Name   -> Function Engine.LightComponent.SetLightFunctionMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          NewLightFunctionMaterial                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionMaterial");
		
		ULightComponent_SetLightFunctionMaterial_Params params {};
		params.NewLightFunctionMaterial = NewLightFunctionMaterial;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727B90
	 * 		Name   -> Function Engine.LightComponent.SetLightFunctionFadeDistance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewLightFunctionFadeDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightFunctionFadeDistance");
		
		ULightComponent_SetLightFunctionFadeDistance_Params params {};
		params.NewLightFunctionFadeDistance = NewLightFunctionFadeDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727C60
	 * 		Name   -> Function Engine.LightComponent.SetLightColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetLightColor");
		
		ULightComponent_SetLightColor_Params params {};
		params.NewLightColor = NewLightColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727D70
	 * 		Name   -> Function Engine.LightComponent.SetIntensity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetIntensity(float NewIntensity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIntensity");
		
		ULightComponent_SetIntensity_Params params {};
		params.NewIntensity = NewIntensity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727E80
	 * 		Name   -> Function Engine.LightComponent.SetIESTexture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTextureLightProfile*                        newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetIESTexture(class UTextureLightProfile* newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetIESTexture");
		
		ULightComponent_SetIESTexture_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727FB0
	 * 		Name   -> Function Engine.LightComponent.SetEnableLightShaftBloom
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetEnableLightShaftBloom(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetEnableLightShaftBloom");
		
		ULightComponent_SetEnableLightShaftBloom_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728080
	 * 		Name   -> Function Engine.LightComponent.SetCastShadows
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetCastShadows(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetCastShadows");
		
		ULightComponent_SetCastShadows_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728150
	 * 		Name   -> Function Engine.LightComponent.SetBloomTint
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetBloomTint(const struct FColor& newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomTint");
		
		ULightComponent_SetBloomTint_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728260
	 * 		Name   -> Function Engine.LightComponent.SetBloomThreshold
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetBloomThreshold(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomThreshold");
		
		ULightComponent_SetBloomThreshold_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728380
	 * 		Name   -> Function Engine.LightComponent.SetBloomScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetBloomScale(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetBloomScale");
		
		ULightComponent_SetBloomScale_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027284A0
	 * 		Name   -> Function Engine.LightComponent.SetAffectTranslucentLighting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetAffectTranslucentLighting(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectTranslucentLighting");
		
		ULightComponent_SetAffectTranslucentLighting_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02728570
	 * 		Name   -> Function Engine.LightComponent.SetAffectDynamicIndirectLighting
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULightComponent::SetAffectDynamicIndirectLighting(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LightComponent.SetAffectDynamicIndirectLighting");
		
		ULightComponent_SetAffectDynamicIndirectLighting_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726F00
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetShadowDistanceFadeoutFraction(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction");
		
		UDirectionalLightComponent_SetShadowDistanceFadeoutFraction_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727010
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetOcclusionMaskDarkness(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness");
		
		UDirectionalLightComponent_SetOcclusionMaskDarkness_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727130
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetLightShaftOverrideDirection(const struct FVector& newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection");
		
		UDirectionalLightComponent_SetLightShaftOverrideDirection_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727260
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetEnableLightShaftOcclusion(bool bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion");
		
		UDirectionalLightComponent_SetEnableLightShaftOcclusion_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727330
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetDynamicShadowDistanceStationaryLight(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight");
		
		UDirectionalLightComponent_SetDynamicShadowDistanceStationaryLight_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727440
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetDynamicShadowDistanceMovableLight(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight");
		
		UDirectionalLightComponent_SetDynamicShadowDistanceMovableLight_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727550
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetDynamicShadowCascades(int32_t newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetDynamicShadowCascades");
		
		UDirectionalLightComponent_SetDynamicShadowCascades_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727660
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetCascadeTransitionFraction(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction");
		
		UDirectionalLightComponent_SetCascadeTransitionFraction_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02727770
	 * 		Name   -> Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              newValue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDirectionalLightComponent::SetCascadeDistributionExponent(float newValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent");
		
		UDirectionalLightComponent_SetCascadeDistributionExponent_Params params {};
		params.newValue = newValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDirectionalLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDirectionalLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DirectionalLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726C20
	 * 		Name   -> Function Engine.PointLightComponent.SetSourceRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              bNewValue                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPointLightComponent::SetSourceRadius(float bNewValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetSourceRadius");
		
		UPointLightComponent_SetSourceRadius_Params params {};
		params.bNewValue = bNewValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726D40
	 * 		Name   -> Function Engine.PointLightComponent.SetLightFalloffExponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewLightFalloffExponent                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPointLightComponent::SetLightFalloffExponent(float NewLightFalloffExponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetLightFalloffExponent");
		
		UPointLightComponent_SetLightFalloffExponent_Params params {};
		params.NewLightFalloffExponent = NewLightFalloffExponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726E10
	 * 		Name   -> Function Engine.PointLightComponent.SetAttenuationRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewRadius                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPointLightComponent::SetAttenuationRadius(float NewRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PointLightComponent.SetAttenuationRadius");
		
		UPointLightComponent_SetAttenuationRadius_Params params {};
		params.NewRadius = NewRadius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPointLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPointLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PointLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726A40
	 * 		Name   -> Function Engine.SpotLightComponent.SetOuterConeAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewOuterConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USpotLightComponent::SetOuterConeAngle(float NewOuterConeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetOuterConeAngle");
		
		USpotLightComponent_SetOuterConeAngle_Params params {};
		params.NewOuterConeAngle = NewOuterConeAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726B30
	 * 		Name   -> Function Engine.SpotLightComponent.SetInnerConeAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewInnerConeAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USpotLightComponent::SetInnerConeAngle(float NewInnerConeAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SpotLightComponent.SetInnerConeAngle");
		
		USpotLightComponent_SetInnerConeAngle_Params params {};
		params.NewInnerConeAngle = NewInnerConeAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpotLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpotLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpotLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726470
	 * 		Name   -> Function Engine.SkyLightComponent.SetOcclusionTint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      InTint                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void USkyLightComponent::SetOcclusionTint(const struct FColor& InTint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetOcclusionTint");
		
		USkyLightComponent_SetOcclusionTint_Params params {};
		params.InTint = InTint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726580
	 * 		Name   -> Function Engine.SkyLightComponent.SetMinOcclusion
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InMinOcclusion                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkyLightComponent::SetMinOcclusion(float InMinOcclusion)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetMinOcclusion");
		
		USkyLightComponent_SetMinOcclusion_Params params {};
		params.InMinOcclusion = InMinOcclusion;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027266A0
	 * 		Name   -> Function Engine.SkyLightComponent.SetLightColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewLightColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkyLightComponent::SetLightColor(const struct FLinearColor& NewLightColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetLightColor");
		
		USkyLightComponent_SetLightColor_Params params {};
		params.NewLightColor = NewLightColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027267D0
	 * 		Name   -> Function Engine.SkyLightComponent.SetIntensity
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkyLightComponent::SetIntensity(float NewIntensity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetIntensity");
		
		USkyLightComponent_SetIntensity_Params params {};
		params.NewIntensity = NewIntensity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027268F0
	 * 		Name   -> Function Engine.SkyLightComponent.SetCubemap
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTextureCube*                                NewCubemap                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkyLightComponent::SetCubemap(class UTextureCube* NewCubemap)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.SetCubemap");
		
		USkyLightComponent_SetCubemap_Params params {};
		params.NewCubemap = NewCubemap;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726A20
	 * 		Name   -> Function Engine.SkyLightComponent.RecaptureSky
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USkyLightComponent::RecaptureSky()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkyLightComponent.RecaptureSky");
		
		USkyLightComponent_RecaptureSky_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkyLightComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkyLightComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkyLightComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationGraphNodeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationGraphNodeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationGraphNodeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsThrusterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsThrusterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsThrusterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPostProcessComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPostProcessComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PostProcessComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726280
	 * 		Name   -> Function Engine.ArrowComponent.SetArrowColor_New
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FLinearColor                                NewColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UArrowComponent::SetArrowColor_New(const struct FLinearColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor_New");
		
		UArrowComponent_SetArrowColor_New_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726350
	 * 		Name   -> Function Engine.ArrowComponent.SetArrowColor_DEPRECATED
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      NewColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UArrowComponent::SetArrowColor_DEPRECATED(const struct FColor& NewColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ArrowComponent.SetArrowColor_DEPRECATED");
		
		UArrowComponent_SetArrowColor_DEPRECATED_Params params {};
		params.NewColor = NewColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UArrowComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UArrowComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ArrowComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725BF0
	 * 		Name   -> Function Engine.BillboardComponent.SetUV
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            NewU                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewUL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewV                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewVL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UBillboardComponent::SetUV(int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetUV");
		
		UBillboardComponent_SetUV_Params params {};
		params.NewU = NewU;
		params.NewUL = NewUL;
		params.NewV = NewV;
		params.NewVL = NewVL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725E50
	 * 		Name   -> Function Engine.BillboardComponent.SetSpriteAndUV
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  NewSprite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewU                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewUL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewV                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NewVL                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UBillboardComponent::SetSpriteAndUV(class UTexture2D* NewSprite, int32_t NewU, int32_t NewUL, int32_t NewV, int32_t NewVL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSpriteAndUV");
		
		UBillboardComponent_SetSpriteAndUV_Params params {};
		params.NewSprite = NewSprite;
		params.NewU = NewU;
		params.NewUL = NewUL;
		params.NewV = NewV;
		params.NewVL = NewVL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02726140
	 * 		Name   -> Function Engine.BillboardComponent.SetSprite
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture2D*                                  NewSprite                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UBillboardComponent::SetSprite(class UTexture2D* NewSprite)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BillboardComponent.SetSprite");
		
		UBillboardComponent_SetSprite_Params params {};
		params.NewSprite = NewSprite;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBillboardComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBillboardComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BillboardComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725BC0
	 * 		Name   -> Function Engine.BrushComponent.GetBoxBrushXYZ
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 */
	struct FVector UBrushComponent::GetBoxBrushXYZ()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BrushComponent.GetBoxBrushXYZ");
		
		UBrushComponent_GetBoxBrushXYZ_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBrushComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBrushComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BrushComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrawFrustumComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrawFrustumComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DrawFrustumComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeGizmoRenderComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeGizmoRenderComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeGizmoRenderComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeHeightfieldCollisionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeHeightfieldCollisionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeHeightfieldCollisionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeMeshCollisionComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeMeshCollisionComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeMeshCollisionComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeSplinesComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeSplinesComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeSplinesComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULineBatchComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULineBatchComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LineBatchComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725840
	 * 		Name   -> Function Engine.MaterialBillboardComponent.AddElement
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UCurveFloat*                                 DistanceToOpacityCurve                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSizeIsInScreenSpace                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseSizeX                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseSizeY                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UCurveFloat*                                 DistanceToSizeCurve                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialBillboardComponent::AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialBillboardComponent.AddElement");
		
		UMaterialBillboardComponent_AddElement_Params params {};
		params.Material = Material;
		params.DistanceToOpacityCurve = DistanceToOpacityCurve;
		params.bSizeIsInScreenSpace = bSizeIsInScreenSpace;
		params.BaseSizeX = BaseSizeX;
		params.BaseSizeY = BaseSizeY;
		params.DistanceToSizeCurve = DistanceToSizeCurve;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialBillboardComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialBillboardComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialBillboardComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027251A0
	 * 		Name   -> Function Engine.DestructibleComponent.SetDestructibleMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UDestructibleMesh*                           NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDestructibleComponent::SetDestructibleMesh(class UDestructibleMesh* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.SetDestructibleMesh");
		
		UDestructibleComponent_SetDestructibleMesh_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027252A0
	 * 		Name   -> Function Engine.DestructibleComponent.GetDestructibleMesh
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class UDestructibleMesh* UDestructibleComponent::GetDestructibleMesh()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.GetDestructibleMesh");
		
		UDestructibleComponent_GetDestructibleMesh_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.DestructibleComponent.ComponentFractureSignature__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate, HasOutParms, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     HitPoint                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UDestructibleComponent::ComponentFractureSignature__DelegateSignature(const struct FVector& HitPoint, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.ComponentFractureSignature__DelegateSignature");
		
		UDestructibleComponent_ComponentFractureSignature__DelegateSignature_Params params {};
		params.HitPoint = HitPoint;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027252D0
	 * 		Name   -> Function Engine.DestructibleComponent.ApplyRadiusDamage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HurtOrigin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFullDamage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDestructibleComponent::ApplyRadiusDamage(float BaseDamage, const struct FVector& HurtOrigin, float DamageRadius, float ImpulseStrength, bool bFullDamage)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.ApplyRadiusDamage");
		
		UDestructibleComponent_ApplyRadiusDamage_Params params {};
		params.BaseDamage = BaseDamage;
		params.HurtOrigin = HurtOrigin;
		params.DamageRadius = DamageRadius;
		params.ImpulseStrength = ImpulseStrength;
		params.bFullDamage = bFullDamage;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725600
	 * 		Name   -> Function Engine.DestructibleComponent.ApplyDamage
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitLocation                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ImpulseDir                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              ImpulseStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDestructibleComponent::ApplyDamage(float DamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float ImpulseStrength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DestructibleComponent.ApplyDamage");
		
		UDestructibleComponent_ApplyDamage_Params params {};
		params.DamageAmount = DamageAmount;
		params.HitLocation = HitLocation;
		params.ImpulseDir = ImpulseDir;
		params.ImpulseStrength = ImpulseStrength;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDestructibleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDestructibleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DestructibleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724240
	 * 		Name   -> Function Engine.PoseableMeshComponent.SetBoneTransformByName
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPoseableMeshComponent::SetBoneTransformByName(const class FName& BoneName, const struct FTransform& InTransform, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneTransformByName");
		
		UPoseableMeshComponent_SetBoneTransformByName_Params params {};
		params.BoneName = BoneName;
		params.InTransform = InTransform;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724420
	 * 		Name   -> Function Engine.PoseableMeshComponent.SetBoneScaleByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InScale3D                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPoseableMeshComponent::SetBoneScaleByName(const class FName& BoneName, const struct FVector& InScale3D, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneScaleByName");
		
		UPoseableMeshComponent_SetBoneScaleByName_Params params {};
		params.BoneName = BoneName;
		params.InScale3D = InScale3D;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724640
	 * 		Name   -> Function Engine.PoseableMeshComponent.SetBoneRotationByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InRotation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPoseableMeshComponent::SetBoneRotationByName(const class FName& BoneName, const struct FRotator& InRotation, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneRotationByName");
		
		UPoseableMeshComponent_SetBoneRotationByName_Params params {};
		params.BoneName = BoneName;
		params.InRotation = InRotation;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724850
	 * 		Name   -> Function Engine.PoseableMeshComponent.SetBoneLocationByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPoseableMeshComponent::SetBoneLocationByName(const class FName& BoneName, const struct FVector& InLocation, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.SetBoneLocationByName");
		
		UPoseableMeshComponent_SetBoneLocationByName_Params params {};
		params.BoneName = BoneName;
		params.InLocation = InLocation;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724A70
	 * 		Name   -> Function Engine.PoseableMeshComponent.ResetBoneTransformByName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPoseableMeshComponent::ResetBoneTransformByName(const class FName& BoneName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.ResetBoneTransformByName");
		
		UPoseableMeshComponent_ResetBoneTransformByName_Params params {};
		params.BoneName = BoneName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724B40
	 * 		Name   -> Function Engine.PoseableMeshComponent.GetBoneTransformByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UPoseableMeshComponent::GetBoneTransformByName(const class FName& BoneName, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneTransformByName");
		
		UPoseableMeshComponent_GetBoneTransformByName_Params params {};
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724CC0
	 * 		Name   -> Function Engine.PoseableMeshComponent.GetBoneScaleByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UPoseableMeshComponent::GetBoneScaleByName(const class FName& BoneName, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneScaleByName");
		
		UPoseableMeshComponent_GetBoneScaleByName_Params params {};
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724E60
	 * 		Name   -> Function Engine.PoseableMeshComponent.GetBoneRotationByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UPoseableMeshComponent::GetBoneRotationByName(const class FName& BoneName, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneRotationByName");
		
		UPoseableMeshComponent_GetBoneRotationByName_Params params {};
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02725000
	 * 		Name   -> Function Engine.PoseableMeshComponent.GetBoneLocationByName
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        BoneName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBoneSpaces                                        BoneSpace                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UPoseableMeshComponent::GetBoneLocationByName(const class FName& BoneName, EBoneSpaces BoneSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PoseableMeshComponent.GetBoneLocationByName");
		
		UPoseableMeshComponent_GetBoneLocationByName_Params params {};
		params.BoneName = BoneName;
		params.BoneSpace = BoneSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPoseableMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPoseableMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PoseableMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723F40
	 * 		Name   -> Function Engine.StaticMeshComponent.SetStaticMesh
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UStaticMesh*                                 NewMesh                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UStaticMeshComponent::SetStaticMesh(class UStaticMesh* NewMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.SetStaticMesh");
		
		UStaticMeshComponent_SetStaticMesh_Params params {};
		params.NewMesh = NewMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724020
	 * 		Name   -> Function Engine.StaticMeshComponent.OnRep_StaticMesh
	 * 		Flags  -> (Final, Native, Public)
	 * Parameters:
	 * 		class UStaticMesh*                                 OldStaticMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UStaticMeshComponent::OnRep_StaticMesh(class UStaticMesh* OldStaticMesh)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.OnRep_StaticMesh");
		
		UStaticMeshComponent_OnRep_StaticMesh_Params params {};
		params.OldStaticMesh = OldStaticMesh;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02724100
	 * 		Name   -> Function Engine.StaticMeshComponent.GetLocalBounds
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Min                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Max                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UStaticMeshComponent::GetLocalBounds(struct FVector* Min, struct FVector* Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.StaticMeshComponent.GetLocalBounds");
		
		UStaticMeshComponent_GetLocalBounds_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Min != nullptr)
			*Min = params.Min;
		if (Max != nullptr)
			*Max = params.Max;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStaticMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStaticMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.StaticMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlPointMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlPointMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ControlPointMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGroundClutterComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGroundClutterComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GroundClutterComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722EB0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  NewInstanceTransform                                       (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UInstancedStaticMeshComponent::UpdateInstanceTransform(int32_t InstanceIndex, const struct FTransform& NewInstanceTransform, bool bWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform");
		
		UInstancedStaticMeshComponent_UpdateInstanceTransform_Params params {};
		params.InstanceIndex = InstanceIndex;
		params.NewInstanceTransform = NewInstanceTransform;
		params.bWorldSpace = bWorldSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723080
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.ShowInstance
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            originalIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::ShowInstance(int32_t originalIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ShowInstance");
		
		UInstancedStaticMeshComponent_ShowInstance_Params params {};
		params.originalIndex = originalIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723150
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.SetCullDistances
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            StartCullDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            EndCullDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::SetCullDistances(int32_t StartCullDistance, int32_t EndCullDistance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.SetCullDistances");
		
		UInstancedStaticMeshComponent_SetCullDistances_Params params {};
		params.StartCullDistance = StartCullDistance;
		params.EndCullDistance = EndCullDistance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027232E0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.RemoveInstance
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitDirection                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	bool UInstancedStaticMeshComponent::RemoveInstance(int32_t InstanceIndex, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.RemoveInstance");
		
		UInstancedStaticMeshComponent_RemoveInstance_Params params {};
		params.InstanceIndex = InstanceIndex;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723430
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.MulticastShowInstances
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		TArray<int32_t>                                    Indices                                                    (ConstParm, Parm, ZeroConstructor)
	 * 		bool                                               bMarkRenderStateDirty                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::MulticastShowInstances(TArray<int32_t> Indices, bool bMarkRenderStateDirty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.MulticastShowInstances");
		
		UInstancedStaticMeshComponent_MulticastShowInstances_Params params {};
		params.Indices = Indices;
		params.bMarkRenderStateDirty = bMarkRenderStateDirty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027235D0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.MulticastShowInstance
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public)
	 * Parameters:
	 * 		int32_t                                            originalIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::MulticastShowInstance(int32_t originalIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.MulticastShowInstance");
		
		UInstancedStaticMeshComponent_MulticastShowInstance_Params params {};
		params.originalIndex = originalIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027236A0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.MulticastHideInstance
	 * 		Flags  -> (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
	 * Parameters:
	 * 		int32_t                                            originalIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitDirection                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::MulticastHideInstance(int32_t originalIndex, const struct FVector& HitDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.MulticastHideInstance");
		
		UInstancedStaticMeshComponent_MulticastHideInstance_Params params {};
		params.originalIndex = originalIndex;
		params.HitDirection = HitDirection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723810
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.GetPositionOfInstance
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UInstancedStaticMeshComponent::GetPositionOfInstance(int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetPositionOfInstance");
		
		UInstancedStaticMeshComponent_GetPositionOfInstance_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723900
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            InstanceIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  OutInstanceTransform                                       (Parm, OutParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bWorldSpace                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UInstancedStaticMeshComponent::GetInstanceTransform(int32_t InstanceIndex, struct FTransform* OutInstanceTransform, bool bWorldSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceTransform");
		
		UInstancedStaticMeshComponent_GetInstanceTransform_Params params {};
		params.InstanceIndex = InstanceIndex;
		params.bWorldSpace = bWorldSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutInstanceTransform != nullptr)
			*OutInstanceTransform = params.OutInstanceTransform;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723AD0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.GetInstanceCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UInstancedStaticMeshComponent::GetInstanceCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.GetInstanceCount");
		
		UInstancedStaticMeshComponent_GetInstanceCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723AF0
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.DealDirectDamage
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           ForPC                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DamageAmount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            HitBodyIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UInstancedStaticMeshComponent::DealDirectDamage(class APlayerController* ForPC, float DamageAmount, class UClass* DamageTypeClass, int32_t HitBodyIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.DealDirectDamage");
		
		UInstancedStaticMeshComponent_DealDirectDamage_Params params {};
		params.ForPC = ForPC;
		params.DamageAmount = DamageAmount;
		params.DamageTypeClass = DamageTypeClass;
		params.HitBodyIndex = HitBodyIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723D50
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.ClearInstances
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UInstancedStaticMeshComponent::ClearInstances()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.ClearInstances");
		
		UInstancedStaticMeshComponent_ClearInstances_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723D70
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  WorldTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	int32_t UInstancedStaticMeshComponent::AddInstanceWorldSpace(const struct FTransform& WorldTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace");
		
		UInstancedStaticMeshComponent_AddInstanceWorldSpace_Params params {};
		params.WorldTransform = WorldTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02723E70
	 * 		Name   -> Function Engine.InstancedStaticMeshComponent.AddInstance
	 * 		Flags  -> (Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FTransform                                  InstanceTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	int32_t UInstancedStaticMeshComponent::AddInstance(const struct FTransform& InstanceTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InstancedStaticMeshComponent.AddInstance");
		
		UInstancedStaticMeshComponent_AddInstance_Params params {};
		params.InstanceTransform = InstanceTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInstancedStaticMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInstancedStaticMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InstancedStaticMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHierarchicalInstancedStaticMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHierarchicalInstancedStaticMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.HierarchicalInstancedStaticMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInteractiveFoliageComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInteractiveFoliageComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InteractiveFoliageComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327E50
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartTangent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     StartTangent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartTangent(const struct FVector& StartTangent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartTangent");
		
		USplineMeshComponent_SetStartTangent_Params params {};
		params.StartTangent = StartTangent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02327F50
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   StartScale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartScale(const struct FVector2D& StartScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartScale");
		
		USplineMeshComponent_SetStartScale_Params params {};
		params.StartScale = StartScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328050
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              StartRoll                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartRoll(float StartRoll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartRoll");
		
		USplineMeshComponent_SetStartRoll_Params params {};
		params.StartRoll = StartRoll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328160
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     StartPos                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartPosition(const struct FVector& StartPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartPosition");
		
		USplineMeshComponent_SetStartPosition_Params params {};
		params.StartPos = StartPos;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328260
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   StartOffset                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartOffset(const struct FVector2D& StartOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartOffset");
		
		USplineMeshComponent_SetStartOffset_Params params {};
		params.StartOffset = StartOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328360
	 * 		Name   -> Function Engine.SplineMeshComponent.SetStartAndEnd
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     StartPos                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     StartTangent                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     EndPos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     EndTangent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetStartAndEnd(const struct FVector& StartPos, const struct FVector& StartTangent, const struct FVector& EndPos, const struct FVector& EndTangent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetStartAndEnd");
		
		USplineMeshComponent_SetStartAndEnd_Params params {};
		params.StartPos = StartPos;
		params.StartTangent = StartTangent;
		params.EndPos = EndPos;
		params.EndTangent = EndTangent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328630
	 * 		Name   -> Function Engine.SplineMeshComponent.SetEndTangent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     EndTangent                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetEndTangent(const struct FVector& EndTangent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndTangent");
		
		USplineMeshComponent_SetEndTangent_Params params {};
		params.EndTangent = EndTangent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328730
	 * 		Name   -> Function Engine.SplineMeshComponent.SetEndScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   EndScale                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetEndScale(const struct FVector2D& EndScale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndScale");
		
		USplineMeshComponent_SetEndScale_Params params {};
		params.EndScale = EndScale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328830
	 * 		Name   -> Function Engine.SplineMeshComponent.SetEndRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              EndRoll                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetEndRoll(float EndRoll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndRoll");
		
		USplineMeshComponent_SetEndRoll_Params params {};
		params.EndRoll = EndRoll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328940
	 * 		Name   -> Function Engine.SplineMeshComponent.SetEndPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     EndPos                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetEndPosition(const struct FVector& EndPos)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndPosition");
		
		USplineMeshComponent_SetEndPosition_Params params {};
		params.EndPos = EndPos;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328A40
	 * 		Name   -> Function Engine.SplineMeshComponent.SetEndOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   EndOffset                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineMeshComponent::SetEndOffset(const struct FVector2D& EndOffset)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.SetEndOffset");
		
		USplineMeshComponent_SetEndOffset_Params params {};
		params.EndOffset = EndOffset;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328B40
	 * 		Name   -> Function Engine.SplineMeshComponent.GetStartTangent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USplineMeshComponent::GetStartTangent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartTangent");
		
		USplineMeshComponent_GetStartTangent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328B70
	 * 		Name   -> Function Engine.SplineMeshComponent.GetStartScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D USplineMeshComponent::GetStartScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartScale");
		
		USplineMeshComponent_GetStartScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328BA0
	 * 		Name   -> Function Engine.SplineMeshComponent.GetStartRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USplineMeshComponent::GetStartRoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartRoll");
		
		USplineMeshComponent_GetStartRoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00F2FA60
	 * 		Name   -> Function Engine.SplineMeshComponent.GetStartPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USplineMeshComponent::GetStartPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartPosition");
		
		USplineMeshComponent_GetStartPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328BC0
	 * 		Name   -> Function Engine.SplineMeshComponent.GetStartOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D USplineMeshComponent::GetStartOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetStartOffset");
		
		USplineMeshComponent_GetStartOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328BF0
	 * 		Name   -> Function Engine.SplineMeshComponent.GetEndTangent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USplineMeshComponent::GetEndTangent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndTangent");
		
		USplineMeshComponent_GetEndTangent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328C20
	 * 		Name   -> Function Engine.SplineMeshComponent.GetEndScale
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D USplineMeshComponent::GetEndScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndScale");
		
		USplineMeshComponent_GetEndScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328C50
	 * 		Name   -> Function Engine.SplineMeshComponent.GetEndRoll
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USplineMeshComponent::GetEndRoll()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndRoll");
		
		USplineMeshComponent_GetEndRoll_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328C70
	 * 		Name   -> Function Engine.SplineMeshComponent.GetEndPosition
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector USplineMeshComponent::GetEndPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndPosition");
		
		USplineMeshComponent_GetEndPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328CA0
	 * 		Name   -> Function Engine.SplineMeshComponent.GetEndOffset
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector2D USplineMeshComponent::GetEndOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineMeshComponent.GetEndOffset");
		
		USplineMeshComponent_GetEndOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USplineMeshComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USplineMeshComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SplineMeshComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UModelComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UModelComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ModelComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavMeshRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavMeshRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavMeshRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavTestRenderingComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavTestRenderingComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavTestRenderingComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNiagaraComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNiagaraComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NiagaraComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlendableInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlendableInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlendableInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02328CD0
	 * 		Name   -> Function Engine.ParticleSystem.ContainsEmitterType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      TypeData                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UParticleSystem::ContainsEmitterType(class UClass* TypeData)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ParticleSystem.ContainsEmitterType");
		
		UParticleSystem_ContainsEmitterType_Params params {};
		params.TypeData = TypeData;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleSystem.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleSystem::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleSystem");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UShapeComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UShapeComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ShapeComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722C40
	 * 		Name   -> Function Engine.BoxComponent.SetBoxExtent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InBoxExtent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UBoxComponent::SetBoxExtent(const struct FVector& InBoxExtent, bool bUpdateOverlaps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.SetBoxExtent");
		
		UBoxComponent_SetBoxExtent_Params params {};
		params.InBoxExtent = InBoxExtent;
		params.bUpdateOverlaps = bUpdateOverlaps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722DB0
	 * 		Name   -> Function Engine.BoxComponent.GetUnscaledBoxExtent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UBoxComponent::GetUnscaledBoxExtent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetUnscaledBoxExtent");
		
		UBoxComponent_GetUnscaledBoxExtent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722DE0
	 * 		Name   -> Function Engine.BoxComponent.GetScaledBoxExtent
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UBoxComponent::GetScaledBoxExtent()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.BoxComponent.GetScaledBoxExtent");
		
		UBoxComponent_GetScaledBoxExtent_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoxComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoxComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BoxComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722470
	 * 		Name   -> Function Engine.CapsuleComponent.SetCapsuleSize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InRadius                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InHalfHeight                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCapsuleComponent::SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleSize");
		
		UCapsuleComponent_SetCapsuleSize_Params params {};
		params.InRadius = InRadius;
		params.InHalfHeight = InHalfHeight;
		params.bUpdateOverlaps = bUpdateOverlaps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722650
	 * 		Name   -> Function Engine.CapsuleComponent.SetCapsuleRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCapsuleComponent::SetCapsuleRadius(float Radius, bool bUpdateOverlaps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleRadius");
		
		UCapsuleComponent_SetCapsuleRadius_Params params {};
		params.Radius = Radius;
		params.bUpdateOverlaps = bUpdateOverlaps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027227B0
	 * 		Name   -> Function Engine.CapsuleComponent.SetCapsuleHalfHeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCapsuleComponent::SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.SetCapsuleHalfHeight");
		
		UCapsuleComponent_SetCapsuleHalfHeight_Params params {};
		params.HalfHeight = HalfHeight;
		params.bUpdateOverlaps = bUpdateOverlaps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722910
	 * 		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              outRadius                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutHalfHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCapsuleComponent::GetUnscaledCapsuleSize(float* outRadius, float* OutHalfHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleSize");
		
		UCapsuleComponent_GetUnscaledCapsuleSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outRadius != nullptr)
			*outRadius = params.outRadius;
		if (OutHalfHeight != nullptr)
			*OutHalfHeight = params.OutHalfHeight;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722A50
	 * 		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCapsuleComponent::GetUnscaledCapsuleRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius");
		
		UCapsuleComponent_GetUnscaledCapsuleRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027223A0
	 * 		Name   -> Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCapsuleComponent::GetUnscaledCapsuleHalfHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight");
		
		UCapsuleComponent_GetUnscaledCapsuleHalfHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027223C0
	 * 		Name   -> Function Engine.CapsuleComponent.GetShapeScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCapsuleComponent::GetShapeScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetShapeScale");
		
		UCapsuleComponent_GetShapeScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722A70
	 * 		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              outRadius                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutHalfHeight                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCapsuleComponent::GetScaledCapsuleSize(float* outRadius, float* OutHalfHeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleSize");
		
		UCapsuleComponent_GetScaledCapsuleSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (outRadius != nullptr)
			*outRadius = params.outRadius;
		if (OutHalfHeight != nullptr)
			*OutHalfHeight = params.OutHalfHeight;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722BE0
	 * 		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCapsuleComponent::GetScaledCapsuleRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleRadius");
		
		UCapsuleComponent_GetScaledCapsuleRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722410
	 * 		Name   -> Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UCapsuleComponent::GetScaledCapsuleHalfHeight()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight");
		
		UCapsuleComponent_GetScaledCapsuleHalfHeight_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCapsuleComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCapsuleComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CapsuleComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722240
	 * 		Name   -> Function Engine.SphereComponent.SetSphereRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InSphereRadius                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUpdateOverlaps                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USphereComponent::SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.SetSphereRadius");
		
		USphereComponent_SetSphereRadius_Params params {};
		params.InSphereRadius = InSphereRadius;
		params.bUpdateOverlaps = bUpdateOverlaps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027223A0
	 * 		Name   -> Function Engine.SphereComponent.GetUnscaledSphereRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USphereComponent::GetUnscaledSphereRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetUnscaledSphereRadius");
		
		USphereComponent_GetUnscaledSphereRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027223C0
	 * 		Name   -> Function Engine.SphereComponent.GetShapeScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USphereComponent::GetShapeScale()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetShapeScale");
		
		USphereComponent_GetShapeScale_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722410
	 * 		Name   -> Function Engine.SphereComponent.GetScaledSphereRadius
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USphereComponent::GetScaledSphereRadius()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SphereComponent.GetScaledSphereRadius");
		
		USphereComponent_GetScaledSphereRadius_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USphereComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USphereComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SphereComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDrawSphereComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDrawSphereComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DrawSphereComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721650
	 * 		Name   -> Function Engine.TextRenderComponent.SetYScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetYScale(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetYScale");
		
		UTextRenderComponent_SetYScale_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721760
	 * 		Name   -> Function Engine.TextRenderComponent.SetXScale
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetXScale(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetXScale");
		
		UTextRenderComponent_SetXScale_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721870
	 * 		Name   -> Function Engine.TextRenderComponent.SetWorldSize
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetWorldSize(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetWorldSize");
		
		UTextRenderComponent_SetWorldSize_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721980
	 * 		Name   -> Function Engine.TextRenderComponent.SetVerticalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EVerticalTextAligment                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetVerticalAlignment(EVerticalTextAligment Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetVerticalAlignment");
		
		UTextRenderComponent_SetVerticalAlignment_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721A80
	 * 		Name   -> Function Engine.TextRenderComponent.SetTextRenderColor
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetTextRenderColor(const struct FColor& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextRenderColor");
		
		UTextRenderComponent_SetTextRenderColor_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721B80
	 * 		Name   -> Function Engine.TextRenderComponent.SetTextMaterial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetTextMaterial(class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetTextMaterial");
		
		UTextRenderComponent_SetTextMaterial_Params params {};
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721C90
	 * 		Name   -> Function Engine.TextRenderComponent.SetText
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor)
	 */
	void UTextRenderComponent::SetText(const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetText");
		
		UTextRenderComponent_SetText_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721DE0
	 * 		Name   -> Function Engine.TextRenderComponent.SetHorizSpacingAdjust
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetHorizSpacingAdjust(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizSpacingAdjust");
		
		UTextRenderComponent_SetHorizSpacingAdjust_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721EF0
	 * 		Name   -> Function Engine.TextRenderComponent.SetHorizontalAlignment
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EHorizTextAligment                                 Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetHorizontalAlignment(EHorizTextAligment Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetHorizontalAlignment");
		
		UTextRenderComponent_SetHorizontalAlignment_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721FF0
	 * 		Name   -> Function Engine.TextRenderComponent.SetFont
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTextRenderComponent::SetFont(class UFont* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.SetFont");
		
		UTextRenderComponent_SetFont_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027220C0
	 * 		Name   -> Function Engine.TextRenderComponent.GetTextWorldSize
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UTextRenderComponent::GetTextWorldSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextWorldSize");
		
		UTextRenderComponent_GetTextWorldSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02722180
	 * 		Name   -> Function Engine.TextRenderComponent.GetTextLocalSize
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 */
	struct FVector UTextRenderComponent::GetTextLocalSize()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TextRenderComponent.GetTextLocalSize");
		
		UTextRenderComponent_GetTextLocalSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextRenderComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextRenderComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextRenderComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721540
	 * 		Name   -> Function Engine.VectorFieldComponent.SetIntensity
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewIntensity                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UVectorFieldComponent::SetIntensity(float NewIntensity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.VectorFieldComponent.SetIntensity");
		
		UVectorFieldComponent_SetIntensity_Params params {};
		params.NewIntensity = NewIntensity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVectorFieldComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVectorFieldComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VectorFieldComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027212F0
	 * 		Name   -> Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EObjectTypeQuery                                   ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void URadialForceComponent::RemoveObjectTypeToAffect(EObjectTypeQuery ObjectType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.RemoveObjectTypeToAffect");
		
		URadialForceComponent_RemoveObjectTypeToAffect_Params params {};
		params.ObjectType = ObjectType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721410
	 * 		Name   -> Function Engine.RadialForceComponent.FireImpulse
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void URadialForceComponent::FireImpulse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.FireImpulse");
		
		URadialForceComponent_FireImpulse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02721430
	 * 		Name   -> Function Engine.RadialForceComponent.AddObjectTypeToAffect
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		EObjectTypeQuery                                   ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void URadialForceComponent::AddObjectTypeToAffect(EObjectTypeQuery ObjectType)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.RadialForceComponent.AddObjectTypeToAffect");
		
		URadialForceComponent_AddObjectTypeToAffect_Params params {};
		params.ObjectType = ObjectType;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URadialForceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URadialForceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RadialForceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027211A0
	 * 		Name   -> Function Engine.ReflectionCaptureComponent.SetBrightness
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewBrightness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UReflectionCaptureComponent::SetBrightness(float NewBrightness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.SetBrightness");
		
		UReflectionCaptureComponent_SetBrightness_Params params {};
		params.NewBrightness = NewBrightness;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027212A0
	 * 		Name   -> Function Engine.ReflectionCaptureComponent.ForceUpdateReflectionCapture
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UReflectionCaptureComponent::ForceUpdateReflectionCapture()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.ReflectionCaptureComponent.ForceUpdateReflectionCapture");
		
		UReflectionCaptureComponent_ForceUpdateReflectionCapture_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReflectionCaptureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReflectionCaptureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReflectionCaptureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoxReflectionCaptureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoxReflectionCaptureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BoxReflectionCaptureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlaneReflectionCaptureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlaneReflectionCaptureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlaneReflectionCaptureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USphereReflectionCaptureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USphereReflectionCaptureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SphereReflectionCaptureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720FE0
	 * 		Name   -> Function Engine.SceneCaptureComponent.HideComponent
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         InComponent                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	void USceneCaptureComponent::HideComponent(class UPrimitiveComponent* InComponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideComponent");
		
		USceneCaptureComponent_HideComponent_Params params {};
		params.InComponent = InComponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027210D0
	 * 		Name   -> Function Engine.SceneCaptureComponent.HideActorComponents
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      InActor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USceneCaptureComponent::HideActorComponents(class AActor* InActor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SceneCaptureComponent.HideActorComponents");
		
		USceneCaptureComponent_HideActorComponents_Params params {};
		params.InActor = InActor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneCaptureComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneCaptureComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCaptureComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneCaptureComponent2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneCaptureComponent2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCaptureComponent2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USceneCaptureComponentCube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USceneCaptureComponentCube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SceneCaptureComponentCube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B680
	 * 		Name   -> Function Engine.SplineComponent.SetWorldSplinePointsAndType
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		ESplinePointType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::SetWorldSplinePointsAndType(TArray<struct FVector> Points, ESplinePointType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldSplinePointsAndType");
		
		USplineComponent_SetWorldSplinePointsAndType_Params params {};
		params.Points = Points;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B7D0
	 * 		Name   -> Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InLocation                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::SetWorldLocationAtSplinePoint(int32_t PointIndex, const struct FVector& InLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetWorldLocationAtSplinePoint");
		
		USplineComponent_SetWorldLocationAtSplinePoint_Params params {};
		params.PointIndex = PointIndex;
		params.InLocation = InLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232B920
	 * 		Name   -> Function Engine.SplineComponent.SetTangentAtSplinePoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InTangent                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		ESplineCoordinateSpace                             CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::SetTangentAtSplinePoint(int32_t PointIndex, const struct FVector& InTangent, ESplineCoordinateSpace CoordinateSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetTangentAtSplinePoint");
		
		USplineComponent_SetTangentAtSplinePoint_Params params {};
		params.PointIndex = PointIndex;
		params.InTangent = InTangent;
		params.CoordinateSpace = CoordinateSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232BAF0
	 * 		Name   -> Function Engine.SplineComponent.SetSplineWorldPoints
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void USplineComponent::SetSplineWorldPoints(TArray<struct FVector> Points)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineWorldPoints");
		
		USplineComponent_SetSplineWorldPoints_Params params {};
		params.Points = Points;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232BBB0
	 * 		Name   -> Function Engine.SplineComponent.SetSplinePointTypeAllPoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ESplinePointType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::SetSplinePointTypeAllPoints(ESplinePointType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointTypeAllPoints");
		
		USplineComponent_SetSplinePointTypeAllPoints_Params params {};
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232BCA0
	 * 		Name   -> Function Engine.SplineComponent.SetSplinePointType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ESplinePointType                                   Type                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::SetSplinePointType(int32_t PointIndex, ESplinePointType Type)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplinePointType");
		
		USplineComponent_SetSplinePointType_Params params {};
		params.PointIndex = PointIndex;
		params.Type = Type;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232BE50
	 * 		Name   -> Function Engine.SplineComponent.SetSplineLocalPoints
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void USplineComponent::SetSplineLocalPoints(TArray<struct FVector> Points)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.SetSplineLocalPoints");
		
		USplineComponent_SetSplineLocalPoints_Params params {};
		params.Points = Points;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232BF10
	 * 		Name   -> Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldTangentAtDistanceAlongSpline(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline");
		
		USplineComponent_GetWorldTangentAtDistanceAlongSpline_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C000
	 * 		Name   -> Function Engine.SplineComponent.GetWorldRotationAtTime
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator USplineComponent::GetWorldRotationAtTime(float Time, bool bUseConstantVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtTime");
		
		USplineComponent_GetWorldRotationAtTime_Params params {};
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C170
	 * 		Name   -> Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator USplineComponent::GetWorldRotationAtDistanceAlongSpline(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline");
		
		USplineComponent_GetWorldRotationAtDistanceAlongSpline_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C2F0
	 * 		Name   -> Function Engine.SplineComponent.GetWorldLocationAtTime
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldLocationAtTime(float Time, bool bUseConstantVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtTime");
		
		USplineComponent_GetWorldLocationAtTime_Params params {};
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C4A0
	 * 		Name   -> Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldLocationAtSplinePoint(int32_t PointIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtSplinePoint");
		
		USplineComponent_GetWorldLocationAtSplinePoint_Params params {};
		params.PointIndex = PointIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C590
	 * 		Name   -> Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldLocationAtDistanceAlongSpline(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline");
		
		USplineComponent_GetWorldLocationAtDistanceAlongSpline_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C680
	 * 		Name   -> Function Engine.SplineComponent.GetWorldDirectionAtTime
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUseConstantVelocity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtTime");
		
		USplineComponent_GetWorldDirectionAtTime_Params params {};
		params.Time = Time;
		params.bUseConstantVelocity = bUseConstantVelocity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C830
	 * 		Name   -> Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::GetWorldDirectionAtDistanceAlongSpline(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline");
		
		USplineComponent_GetWorldDirectionAtDistanceAlongSpline_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232C920
	 * 		Name   -> Function Engine.SplineComponent.GetSplinePointType
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	ESplinePointType USplineComponent::GetSplinePointType(int32_t PointIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplinePointType");
		
		USplineComponent_GetSplinePointType_Params params {};
		params.PointIndex = PointIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CA50
	 * 		Name   -> Function Engine.SplineComponent.GetSplineLength
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float USplineComponent::GetSplineLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetSplineLength");
		
		USplineComponent_GetSplineLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CAA0
	 * 		Name   -> Function Engine.SplineComponent.GetNumSplinePoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t USplineComponent::GetNumSplinePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetNumSplinePoints");
		
		USplineComponent_GetNumSplinePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CAC0
	 * 		Name   -> Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LocalLocation                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LocalTangent                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::GetLocalLocationAndTangentAtSplinePoint(int32_t PointIndex, struct FVector* LocalLocation, struct FVector* LocalTangent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint");
		
		USplineComponent_GetLocalLocationAndTangentAtSplinePoint_Params params {};
		params.PointIndex = PointIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LocalLocation != nullptr)
			*LocalLocation = params.LocalLocation;
		if (LocalTangent != nullptr)
			*LocalTangent = params.LocalTangent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CC80
	 * 		Name   -> Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              Distance                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float USplineComponent::GetInputKeyAtDistanceAlongSpline(float Distance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline");
		
		USplineComponent_GetInputKeyAtDistanceAlongSpline_Params params {};
		params.Distance = Distance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CDB0
	 * 		Name   -> Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		int32_t                                            PointIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float USplineComponent::GetDistanceAlongSplineAtSplinePoint(int32_t PointIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint");
		
		USplineComponent_GetDistanceAlongSplineAtSplinePoint_Params params {};
		params.PointIndex = PointIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232CEC0
	 * 		Name   -> Function Engine.SplineComponent.FindLocationClosestToWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		ESplineCoordinateSpace                             CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindLocationClosestToWorldLocation");
		
		USplineComponent_FindLocationClosestToWorldLocation_Params params {};
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D040
	 * 		Name   -> Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	float USplineComponent::FindInputKeyClosestToWorldLocation(const struct FVector& WorldLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation");
		
		USplineComponent_FindInputKeyClosestToWorldLocation_Params params {};
		params.WorldLocation = WorldLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D110
	 * 		Name   -> Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		ESplineCoordinateSpace                             CoordinateSpace                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector USplineComponent::FindDirectionClosestToWorldLocation(const struct FVector& WorldLocation, ESplineCoordinateSpace CoordinateSpace)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.FindDirectionClosestToWorldLocation");
		
		USplineComponent_FindDirectionClosestToWorldLocation_Params params {};
		params.WorldLocation = WorldLocation;
		params.CoordinateSpace = CoordinateSpace;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D290
	 * 		Name   -> Function Engine.SplineComponent.ClearSplinePoints
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void USplineComponent::ClearSplinePoints()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.ClearSplinePoints");
		
		USplineComponent_ClearSplinePoints_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D2B0
	 * 		Name   -> Function Engine.SplineComponent.AddSplineWorldPoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::AddSplineWorldPoint(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineWorldPoint");
		
		USplineComponent_AddSplineWorldPoint_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232D370
	 * 		Name   -> Function Engine.SplineComponent.AddSplineLocalPoint
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void USplineComponent::AddSplineLocalPoint(const struct FVector& Position)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SplineComponent.AddSplineLocalPoint");
		
		USplineComponent_AddSplineLocalPoint_Params params {};
		params.Position = Position;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USplineComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USplineComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SplineComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USpringArmComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USpringArmComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SpringArmComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWindDirectionalSourceComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWindDirectionalSourceComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WindDirectionalSourceComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720780
	 * 		Name   -> Function Engine.TimelineComponent.Stop
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UTimelineComponent::Stop()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Stop");
		
		UTimelineComponent_Stop_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027207A0
	 * 		Name   -> Function Engine.TimelineComponent.SetTimelineLengthMode
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ETimelineLengthMode                                NewLengthMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetTimelineLengthMode(ETimelineLengthMode NewLengthMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLengthMode");
		
		UTimelineComponent_SetTimelineLengthMode_Params params {};
		params.NewLengthMode = NewLengthMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720860
	 * 		Name   -> Function Engine.TimelineComponent.SetTimelineLength
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewLength                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetTimelineLength(float NewLength)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetTimelineLength");
		
		UTimelineComponent_SetTimelineLength_Params params {};
		params.NewLength = NewLength;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720960
	 * 		Name   -> Function Engine.TimelineComponent.SetPlayRate
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewRate                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetPlayRate(float NewRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlayRate");
		
		UTimelineComponent_SetPlayRate_Params params {};
		params.NewRate = NewRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720A30
	 * 		Name   -> Function Engine.TimelineComponent.SetPlaybackPosition
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewPosition                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFireEvents                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetPlaybackPosition(float NewPosition, bool bFireEvents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetPlaybackPosition");
		
		UTimelineComponent_SetPlaybackPosition_Params params {};
		params.NewPosition = NewPosition;
		params.bFireEvents = bFireEvents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720B90
	 * 		Name   -> Function Engine.TimelineComponent.SetNewTime
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewTime                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetNewTime(float NewTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetNewTime");
		
		UTimelineComponent_SetNewTime_Params params {};
		params.NewTime = NewTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720C80
	 * 		Name   -> Function Engine.TimelineComponent.SetLooping
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bNewLooping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::SetLooping(bool bNewLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.SetLooping");
		
		UTimelineComponent_SetLooping_Params params {};
		params.bNewLooping = bNewLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720D60
	 * 		Name   -> Function Engine.TimelineComponent.ReverseFromEnd
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UTimelineComponent::ReverseFromEnd()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.ReverseFromEnd");
		
		UTimelineComponent_ReverseFromEnd_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720DD0
	 * 		Name   -> Function Engine.TimelineComponent.Reverse
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UTimelineComponent::Reverse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Reverse");
		
		UTimelineComponent_Reverse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720E10
	 * 		Name   -> Function Engine.TimelineComponent.PlayFromStart
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UTimelineComponent::PlayFromStart()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.PlayFromStart");
		
		UTimelineComponent_PlayFromStart_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720E60
	 * 		Name   -> Function Engine.TimelineComponent.Play
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 */
	void UTimelineComponent::Play()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.Play");
		
		UTimelineComponent_Play_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.TimelineComponent.OnTimelineVector__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		struct FVector                                     Output                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::OnTimelineVector__DelegateSignature(const struct FVector& Output)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnTimelineVector__DelegateSignature");
		
		UTimelineComponent_OnTimelineVector__DelegateSignature_Params params {};
		params.Output = Output;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.TimelineComponent.OnTimelineLinearColor__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasDefaults)
	 * Parameters:
	 * 		struct FLinearColor                                Output                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::OnTimelineLinearColor__DelegateSignature(const struct FLinearColor& Output)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnTimelineLinearColor__DelegateSignature");
		
		UTimelineComponent_OnTimelineLinearColor__DelegateSignature_Params params {};
		params.Output = Output;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.TimelineComponent.OnTimelineFloat__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 * Parameters:
	 * 		float                                              Output                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UTimelineComponent::OnTimelineFloat__DelegateSignature(float Output)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnTimelineFloat__DelegateSignature");
		
		UTimelineComponent_OnTimelineFloat__DelegateSignature_Params params {};
		params.Output = Output;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.TimelineComponent.OnTimelineEvent__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UTimelineComponent::OnTimelineEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnTimelineEvent__DelegateSignature");
		
		UTimelineComponent_OnTimelineEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.TimelineComponent.OnRep_Timeline
	 * 		Flags  -> (Final, Native, Public)
	 */
	void UTimelineComponent::OnRep_Timeline()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.OnRep_Timeline");
		
		UTimelineComponent_OnRep_Timeline_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720EA0
	 * 		Name   -> Function Engine.TimelineComponent.IsReversing
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTimelineComponent::IsReversing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsReversing");
		
		UTimelineComponent_IsReversing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720ED0
	 * 		Name   -> Function Engine.TimelineComponent.IsPlaying
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTimelineComponent::IsPlaying()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsPlaying");
		
		UTimelineComponent_IsPlaying_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720F00
	 * 		Name   -> Function Engine.TimelineComponent.IsLooping
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UTimelineComponent::IsLooping()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.IsLooping");
		
		UTimelineComponent_IsLooping_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720F30
	 * 		Name   -> Function Engine.TimelineComponent.GetTimelineLength
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UTimelineComponent::GetTimelineLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetTimelineLength");
		
		UTimelineComponent_GetTimelineLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720FA0
	 * 		Name   -> Function Engine.TimelineComponent.GetPlayRate
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UTimelineComponent::GetPlayRate()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlayRate");
		
		UTimelineComponent_GetPlayRate_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720FC0
	 * 		Name   -> Function Engine.TimelineComponent.GetPlaybackPosition
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UTimelineComponent::GetPlaybackPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TimelineComponent.GetPlaybackPosition");
		
		UTimelineComponent_GetPlaybackPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTimelineComponent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTimelineComponent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TimelineComponent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimSequenceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimSequenceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimSequenceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompositeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompositeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompositeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimComposite.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimComposite::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimComposite");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimSequence.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimSequence::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimSequence");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimMontage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimMontage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimMontage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlendSpaceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlendSpaceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlendSpaceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlendSpace.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlendSpace::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlendSpace");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimOffsetBlendSpace.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimOffsetBlendSpace::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AimOffsetBlendSpace");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlendSpace1D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlendSpace1D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlendSpace1D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAimOffsetBlendSpace1D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAimOffsetBlendSpace1D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AimOffsetBlendSpace1D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_Automatic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_Automatic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_Automatic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_BitwiseCompressOnly.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_BitwiseCompressOnly::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_BitwiseCompressOnly");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_LeastDestructive.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_LeastDestructive::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_LeastDestructive");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_RemoveEverySecondKey.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_RemoveEverySecondKey::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_RemoveEverySecondKey");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_RemoveLinearKeys.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_RemoveLinearKeys::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_RemoveLinearKeys");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_PerTrackCompression.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_PerTrackCompression::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_PerTrackCompression");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_RemoveTrivialKeys.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_RemoveTrivialKeys::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_RemoveTrivialKeys");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimCompress_RevertToRaw.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimCompress_RevertToRaw::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimCompress_RevertToRaw");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FD20
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.StopAnim
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	void UAnimSingleNodeInstance::StopAnim()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.StopAnim");
		
		UAnimSingleNodeInstance_StopAnim_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FD40
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetVertexAnimation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UVertexAnimation*                            NewVertexAnim                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetVertexAnimation(class UVertexAnimation* NewVertexAnim, bool bIsLooping, float InPlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetVertexAnimation");
		
		UAnimSingleNodeInstance_SetVertexAnimation_Params params {};
		params.NewVertexAnim = NewVertexAnim;
		params.bIsLooping = bIsLooping;
		params.InPlayRate = InPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0232FF80
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetReverse
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bInReverse                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetReverse(bool bInReverse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetReverse");
		
		UAnimSingleNodeInstance_SetReverse_Params params {};
		params.bInReverse = bInReverse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330080
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetPosition
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InPosition                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFireNotifies                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bReallyFireNotifies                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetPosition(float InPosition, bool bFireNotifies, bool bReallyFireNotifies)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPosition");
		
		UAnimSingleNodeInstance_SetPosition_Params params {};
		params.InPosition = InPosition;
		params.bFireNotifies = bFireNotifies;
		params.bReallyFireNotifies = bReallyFireNotifies;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330270
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetPlayRate
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetPlayRate(float InPlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlayRate");
		
		UAnimSingleNodeInstance_SetPlayRate_Params params {};
		params.InPlayRate = InPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023303A0
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetPlaying
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsPlaying                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetPlaying(bool bIsPlaying)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetPlaying");
		
		UAnimSingleNodeInstance_SetPlaying_Params params {};
		params.bIsPlaying = bIsPlaying;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330470
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetLooping
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetLooping(bool bIsLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetLooping");
		
		UAnimSingleNodeInstance_SetLooping_Params params {};
		params.bIsLooping = bIsLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330540
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     InBlendInput                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetBlendSpaceInput(const struct FVector& InBlendInput)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput");
		
		UAnimSingleNodeInstance_SetBlendSpaceInput_Params params {};
		params.InBlendInput = InBlendInput;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330610
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.SetAnimationAsset
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UAnimationAsset*                             NewAsset                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.SetAnimationAsset");
		
		UAnimSingleNodeInstance_SetAnimationAsset_Params params {};
		params.NewAsset = NewAsset;
		params.bIsLooping = bIsLooping;
		params.InPlayRate = InPlayRate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.PostEvaluateAnimEvent__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UAnimSingleNodeInstance::PostEvaluateAnimEvent__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PostEvaluateAnimEvent__DelegateSignature");
		
		UAnimSingleNodeInstance_PostEvaluateAnimEvent__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330800
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.PlayAnim
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bIsLooping                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InPlayRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InStartPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UAnimSingleNodeInstance::PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.PlayAnim");
		
		UAnimSingleNodeInstance_PlayAnim_Params params {};
		params.bIsLooping = bIsLooping;
		params.InPlayRate = InPlayRate;
		params.InStartPosition = InStartPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023309E0
	 * 		Name   -> Function Engine.AnimSingleNodeInstance.GetLength
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UAnimSingleNodeInstance::GetLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AnimSingleNodeInstance.GetLength");
		
		UAnimSingleNodeInstance_GetLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimSingleNodeInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimSingleNodeInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimSingleNodeInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330A70
	 * 		Name   -> Function Engine.VehicleAnimInstance.GetVehicle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	class AWheeledVehicle* UVehicleAnimInstance::GetVehicle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.VehicleAnimInstance.GetVehicle");
		
		UVehicleAnimInstance_GetVehicle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleAnimInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleAnimInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VehicleAnimInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_TimedParticleEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_TimedParticleEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimNotifyState_TimedParticleEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimNotifyState_Trail.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimNotifyState_Trail::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimNotifyState_Trail");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimSet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimSet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimSet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimStateMachineTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimStateMachineTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimStateMachineTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAssetImportData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAssetImportData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AssetImportData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAssetUserData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAssetUserData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AssetUserData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAudioSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAudioSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AudioSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAutomationTestSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAutomationTestSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AutomationTestSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720250
	 * 		Name   -> Function Engine.AvoidanceManager.RegisterMovementComponent
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UCharacterMovementComponent*                 MovementComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		float                                              AvoidanceWeight                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UAvoidanceManager::RegisterMovementComponent(class UCharacterMovementComponent* MovementComp, float AvoidanceWeight)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.RegisterMovementComponent");
		
		UAvoidanceManager_RegisterMovementComponent_Params params {};
		params.MovementComp = MovementComp;
		params.AvoidanceWeight = AvoidanceWeight;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027203A0
	 * 		Name   -> Function Engine.AvoidanceManager.GetObjectCount
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UAvoidanceManager::GetObjectCount()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetObjectCount");
		
		UAvoidanceManager_GetObjectCount_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027203D0
	 * 		Name   -> Function Engine.AvoidanceManager.GetNewAvoidanceUID
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	int32_t UAvoidanceManager::GetNewAvoidanceUID()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetNewAvoidanceUID");
		
		UAvoidanceManager_GetNewAvoidanceUID_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720400
	 * 		Name   -> Function Engine.AvoidanceManager.GetAvoidanceVelocityIgnoringUID
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FNavAvoidanceData                           AvoidanceData                                              (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            IgnoreThisUID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UAvoidanceManager::GetAvoidanceVelocityIgnoringUID(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime, int32_t IgnoreThisUID)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocityIgnoringUID");
		
		UAvoidanceManager_GetAvoidanceVelocityIgnoringUID_Params params {};
		params.AvoidanceData = AvoidanceData;
		params.DeltaTime = DeltaTime;
		params.IgnoreThisUID = IgnoreThisUID;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02720610
	 * 		Name   -> Function Engine.AvoidanceManager.GetAvoidanceVelocity
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FNavAvoidanceData                           AvoidanceData                                              (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UAvoidanceManager::GetAvoidanceVelocity(const struct FNavAvoidanceData& AvoidanceData, float DeltaTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.AvoidanceManager.GetAvoidanceVelocity");
		
		UAvoidanceManager_GetAvoidanceVelocity_Params params {};
		params.AvoidanceData = AvoidanceData;
		params.DeltaTime = DeltaTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAvoidanceManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAvoidanceManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AvoidanceManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBadObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBadObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BadObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlueprintCore.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlueprintCore::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BlueprintCore");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraphNode.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraphNode::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraphNode");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraphPin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraphPin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraphPin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBlueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBlueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Blueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimBlueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimBlueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimBlueprint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelScriptBlueprint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelScriptBlueprint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelScriptBlueprint");
		return ptr;
	}

	/**
	 * RowMap is [TMap<FName, uint8_t*>] after `References` field
	 * If `References` not there then it's after `RowStruct` field
	 * Just replace it with `UnknownData_[0x50]`
	 */
	/*std::vector<FName> UDataTable::GetRowNames() const
	{
		std::vector<FName> ret;
		
		for (int32_t i = 0; i < RowMap.Data.Count(); ++i)
		{
			CG::TPair<CG::FName, unsigned char*> itemRow = RowMap.Data[i].Value;
			ret.push_back(itemRow.First);
		}
		
		return ret;
	}*/

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DataTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330E80
	 * 		Name   -> Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UDataTable*                                  Table                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTableRowBase                               OutRow                                                     (Parm, OutParm)
	 */
	bool UDataTableFunctionLibrary::STATIC_GetDataTableRowFromName(class UDataTable* Table, const class FName& RowName, struct FTableRowBase* OutRow)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName");
		
		UDataTableFunctionLibrary_GetDataTableRowFromName_Params params {};
		params.Table = Table;
		params.RowName = RowName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRow != nullptr)
			*OutRow = params.OutRow;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02330BD0
	 * 		Name   -> Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UCurveTable*                                 CurveTable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        RowName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InXY                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEvaluateCurveTableResult                          OutResult                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutXY                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UDataTableFunctionLibrary::STATIC_EvaluateCurveTableRow(class UCurveTable* CurveTable, const class FName& RowName, float InXY, EEvaluateCurveTableResult* OutResult, float* OutXY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow");
		
		UDataTableFunctionLibrary_EvaluateCurveTableRow_Params params {};
		params.CurveTable = CurveTable;
		params.RowName = RowName;
		params.InXY = InXY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutResult != nullptr)
			*OutResult = params.OutResult;
		if (OutXY != nullptr)
			*OutXY = params.OutXY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDataTableFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDataTableFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DataTableFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDebugDrawService.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDebugDrawService::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DebugDrawService");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDialogueTypes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDialogueTypes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DialogueTypes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027162F0
	 * 		Name   -> Function Engine.GameplayStatics.UnloadStreamLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 */
	void UGameplayStatics::STATIC_UnloadStreamLevel(class UObject* WorldContextObject, const class FName& LevelName, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.UnloadStreamLevel");
		
		UGameplayStatics_UnloadStreamLevel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027164F0
	 * 		Name   -> Function Engine.GameplayStatics.SpawnEmitterAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDontSpawnOutOfView                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAllowSpawnLoopingFX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OverrideSecondsBeforeInactive                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* attachToComponent, const class FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bAutoDestroy, bool bDontSpawnOutOfView, bool bAllowSpawnLoopingFX, float OverrideSecondsBeforeInactive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAttached");
		
		UGameplayStatics_SpawnEmitterAttached_Params params {};
		params.EmitterTemplate = EmitterTemplate;
		params.attachToComponent = attachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.bAutoDestroy = bAutoDestroy;
		params.bDontSpawnOutOfView = bDontSpawnOutOfView;
		params.bAllowSpawnLoopingFX = bAllowSpawnLoopingFX;
		params.OverrideSecondsBeforeInactive = OverrideSecondsBeforeInactive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02716AE0
	 * 		Name   -> Function Engine.GameplayStatics.SpawnEmitterAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UParticleSystem*                             EmitterTemplate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAutoDestroy                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDontSpawnOutOfView                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DontSpawnOutOfViewCheckRadius                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAllowSpawnLoopingFX                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OverrideSecondsBeforeInactive                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UParticleSystemComponent* UGameplayStatics::STATIC_SpawnEmitterAtLocation(class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, const struct FVector& Location, const struct FRotator& Rotation, bool bAutoDestroy, bool bDontSpawnOutOfView, float DontSpawnOutOfViewCheckRadius, bool bAllowSpawnLoopingFX, float OverrideSecondsBeforeInactive)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnEmitterAtLocation");
		
		UGameplayStatics_SpawnEmitterAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.EmitterTemplate = EmitterTemplate;
		params.Location = Location;
		params.Rotation = Rotation;
		params.bAutoDestroy = bAutoDestroy;
		params.bDontSpawnOutOfView = bDontSpawnOutOfView;
		params.DontSpawnOutOfViewCheckRadius = DontSpawnOutOfViewCheckRadius;
		params.bAllowSpawnLoopingFX = bAllowSpawnLoopingFX;
		params.OverrideSecondsBeforeInactive = OverrideSecondsBeforeInactive;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717020
	 * 		Name   -> Function Engine.GameplayStatics.SpawnDecalAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     DecalSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAttached(class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, class USceneComponent* attachToComponent, const class FName& AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, float LifeSpan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAttached");
		
		UGameplayStatics_SpawnDecalAttached_Params params {};
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.attachToComponent = attachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LocationType = LocationType;
		params.LifeSpan = LifeSpan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027174D0
	 * 		Name   -> Function Engine.GameplayStatics.SpawnDecalAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          DecalMaterial                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     DecalSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LifeSpan                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UDecalComponent* UGameplayStatics::STATIC_SpawnDecalAtLocation(class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, const struct FVector& DecalSize, const struct FVector& Location, const struct FRotator& Rotation, float LifeSpan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SpawnDecalAtLocation");
		
		UGameplayStatics_SpawnDecalAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.DecalMaterial = DecalMaterial;
		params.DecalSize = DecalSize;
		params.Location = Location;
		params.Rotation = Rotation;
		params.LifeSpan = LifeSpan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717900
	 * 		Name   -> Function Engine.GameplayStatics.SetWorldOriginLocation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FIntVector                                  NewLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_SetWorldOriginLocation(class UObject* WorldContextObject, const struct FIntVector& NewLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetWorldOriginLocation");
		
		UGameplayStatics_SetWorldOriginLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.NewLocation = NewLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F370
	 * 		Name   -> Function Engine.GameplayStatics.SetSoundMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        SoundModeName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_SetSoundMode(const class FName& SoundModeName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetSoundMode");
		
		UGameplayStatics_SetSoundMode_Params params {};
		params.SoundModeName = SoundModeName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717AA0
	 * 		Name   -> Function Engine.GameplayStatics.SetGlobalTimeDilation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TimeDilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_SetGlobalTimeDilation(class UObject* WorldContextObject, float TimeDilation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGlobalTimeDilation");
		
		UGameplayStatics_SetGlobalTimeDilation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TimeDilation = TimeDilation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717BF0
	 * 		Name   -> Function Engine.GameplayStatics.SetGamePaused
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPaused                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_SetGamePaused(class UObject* WorldContextObject, bool bPaused)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetGamePaused");
		
		UGameplayStatics_SetGamePaused_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.bPaused = bPaused;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717D40
	 * 		Name   -> Function Engine.GameplayStatics.SetBaseSoundMix
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundMix*                                   InSoundMix                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_SetBaseSoundMix(class USoundMix* InSoundMix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SetBaseSoundMix");
		
		UGameplayStatics_SetBaseSoundMix_Params params {};
		params.InSoundMix = InSoundMix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02717E50
	 * 		Name   -> Function Engine.GameplayStatics.SaveGameToSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USaveGame*                                   SaveGameObject                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_SaveGameToSlot(class USaveGame* SaveGameObject, const class FString& SlotName, int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.SaveGameToSlot");
		
		UGameplayStatics_SaveGameToSlot_Params params {};
		params.SaveGameObject = SaveGameObject;
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02718060
	 * 		Name   -> Function Engine.GameplayStatics.PushSoundMixModifier
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundMix*                                   InSoundMixModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_PushSoundMixModifier(class USoundMix* InSoundMixModifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PushSoundMixModifier");
		
		UGameplayStatics_PushSoundMixModifier_Params params {};
		params.InSoundMixModifier = InSoundMixModifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02718170
	 * 		Name   -> Function Engine.GameplayStatics.PopSoundMixModifier
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class USoundMix*                                   InSoundMixModifier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_PopSoundMixModifier(class USoundMix* InSoundMixModifier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PopSoundMixModifier");
		
		UGameplayStatics_PopSoundMixModifier_Params params {};
		params.InSoundMixModifier = InSoundMixModifier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02718280
	 * 		Name   -> Function Engine.GameplayStatics.PlayWorldCameraShake
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      Shake                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Epicenter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InnerRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OuterRadius                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Falloff                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOrientShakeTowardsEpicenter                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ScaleMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_PlayWorldCameraShake(class UObject* WorldContextObject, class UClass* Shake, const struct FVector& Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter, float ScaleMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayWorldCameraShake");
		
		UGameplayStatics_PlayWorldCameraShake_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Shake = Shake;
		params.Epicenter = Epicenter;
		params.InnerRadius = InnerRadius;
		params.OuterRadius = OuterRadius;
		params.Falloff = Falloff;
		params.bOrientShakeTowardsEpicenter = bOrientShakeTowardsEpicenter;
		params.ScaleMultiplier = ScaleMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02718710
	 * 		Name   -> Function Engine.GameplayStatics.PlaySoundAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bStopWhenAttachedToDestroyed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bAlwaysPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class UAudioComponent* UGameplayStatics::STATIC_PlaySoundAttached(class USoundBase* Sound, class USceneComponent* attachToComponent, const class FName& AttachPointName, const struct FVector& Location, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAlwaysPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAttached");
		
		UGameplayStatics_PlaySoundAttached_Params params {};
		params.Sound = Sound;
		params.attachToComponent = attachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.LocationType = LocationType;
		params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.bAlwaysPlay = bAlwaysPlay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02718D50
	 * 		Name   -> Function Engine.GameplayStatics.PlaySoundAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USoundBase*                                  Sound                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bAlwaysPlay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void UGameplayStatics::STATIC_PlaySoundAtLocation(class UObject* WorldContextObject, class USoundBase* Sound, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAlwaysPlay)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySoundAtLocation");
		
		UGameplayStatics_PlaySoundAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Sound = Sound;
		params.Location = Location;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		params.bAlwaysPlay = bAlwaysPlay;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027191E0
	 * 		Name   -> Function Engine.GameplayStatics.PlaySound
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USoundCue*                                   InSoundCue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class USceneComponent*                             AttachComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        AttachName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFollow                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_PlaySound(class UObject* WorldContextObject, class USoundCue* InSoundCue, class USceneComponent* AttachComponent, const class FName& AttachName, bool bFollow, float VolumeMultiplier, float PitchMultiplier)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlaySound");
		
		UGameplayStatics_PlaySound_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InSoundCue = InSoundCue;
		params.AttachComponent = AttachComponent;
		params.AttachName = AttachName;
		params.bFollow = bFollow;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027195E0
	 * 		Name   -> Function Engine.GameplayStatics.PlayDialogueAttached
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class USceneComponent*                             attachToComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class FName                                        AttachPointName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		EAttachLocation                                    LocationType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bStopWhenAttachedToDestroyed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class UAudioComponent* UGameplayStatics::STATIC_PlayDialogueAttached(class UDialogueWave* Dialogue, const struct FDialogueContext& Context, class USceneComponent* attachToComponent, const class FName& AttachPointName, const struct FVector& Location, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAttached");
		
		UGameplayStatics_PlayDialogueAttached_Params params {};
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.attachToComponent = attachToComponent;
		params.AttachPointName = AttachPointName;
		params.Location = Location;
		params.LocationType = LocationType;
		params.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02719C00
	 * 		Name   -> Function Engine.GameplayStatics.PlayDialogueAtLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UDialogueWave*                               Dialogue                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDialogueContext                            Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              VolumeMultiplier                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              PitchMultiplier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              StartTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class USoundAttenuation*                           AttenuationSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void UGameplayStatics::STATIC_PlayDialogueAtLocation(class UObject* WorldContextObject, class UDialogueWave* Dialogue, const struct FDialogueContext& Context, const struct FVector& Location, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.PlayDialogueAtLocation");
		
		UGameplayStatics_PlayDialogueAtLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Dialogue = Dialogue;
		params.Context = Context;
		params.Location = Location;
		params.VolumeMultiplier = VolumeMultiplier;
		params.PitchMultiplier = PitchMultiplier;
		params.StartTime = StartTime;
		params.AttenuationSettings = AttenuationSettings;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271A090
	 * 		Name   -> Function Engine.GameplayStatics.OpenLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bAbsolute                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class FString                                      Options                                                    (Parm, ZeroConstructor, AdvancedDisplay)
	 */
	void UGameplayStatics::STATIC_OpenLevel(class UObject* WorldContextObject, const class FName& LevelName, bool bAbsolute, const class FString& Options)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.OpenLevel");
		
		UGameplayStatics_OpenLevel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.bAbsolute = bAbsolute;
		params.Options = Options;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271A360
	 * 		Name   -> Function Engine.GameplayStatics.LoadStreamLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        LevelName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bMakeVisibleAfterLoad                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bShouldBlockOnLoad                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 */
	void UGameplayStatics::STATIC_LoadStreamLevel(class UObject* WorldContextObject, const class FName& LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadStreamLevel");
		
		UGameplayStatics_LoadStreamLevel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LevelName = LevelName;
		params.bMakeVisibleAfterLoad = bMakeVisibleAfterLoad;
		params.bShouldBlockOnLoad = bShouldBlockOnLoad;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271A670
	 * 		Name   -> Function Engine.GameplayStatics.LoadGameFromSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class USaveGame* UGameplayStatics::STATIC_LoadGameFromSlot(const class FString& SlotName, int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.LoadGameFromSlot");
		
		UGameplayStatics_LoadGameFromSlot_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271A810
	 * 		Name   -> Function Engine.GameplayStatics.IsGameWorld
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_IsGameWorld(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGameWorld");
		
		UGameplayStatics_IsGameWorld_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271A930
	 * 		Name   -> Function Engine.GameplayStatics.IsGamePaused
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_IsGamePaused(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.IsGamePaused");
		
		UGameplayStatics_IsGamePaused_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AA30
	 * 		Name   -> Function Engine.GameplayStatics.GetWorldOriginLocation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FIntVector UGameplayStatics::STATIC_GetWorldOriginLocation(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldOriginLocation");
		
		UGameplayStatics_GetWorldOriginLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AB50
	 * 		Name   -> Function Engine.GameplayStatics.GetWorldDeltaSeconds
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UGameplayStatics::STATIC_GetWorldDeltaSeconds(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetWorldDeltaSeconds");
		
		UGameplayStatics_GetWorldDeltaSeconds_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AC40
	 * 		Name   -> Function Engine.GameplayStatics.GetSurfaceType
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	EPhysicalSurface UGameplayStatics::STATIC_GetSurfaceType(const struct FHitResult& Hit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetSurfaceType");
		
		UGameplayStatics_GetSurfaceType_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AD00
	 * 		Name   -> Function Engine.GameplayStatics.GetStreamingLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PackageName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class ULevelStreaming* UGameplayStatics::STATIC_GetStreamingLevel(class UObject* WorldContextObject, const class FName& PackageName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetStreamingLevel");
		
		UGameplayStatics_GetStreamingLevel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PackageName = PackageName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AE50
	 * 		Name   -> Function Engine.GameplayStatics.GetRealTimeSeconds
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UGameplayStatics::STATIC_GetRealTimeSeconds(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetRealTimeSeconds");
		
		UGameplayStatics_GetRealTimeSeconds_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271AF50
	 * 		Name   -> Function Engine.GameplayStatics.GetPlayerPawn
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class APawn* UGameplayStatics::STATIC_GetPlayerPawn(class UObject* WorldContextObject, int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerPawn");
		
		UGameplayStatics_GetPlayerPawn_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B0E0
	 * 		Name   -> Function Engine.GameplayStatics.GetPlayerController
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class APlayerController* UGameplayStatics::STATIC_GetPlayerController(class UObject* WorldContextObject, int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerController");
		
		UGameplayStatics_GetPlayerController_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B230
	 * 		Name   -> Function Engine.GameplayStatics.GetPlayerCharacter
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class ACharacter* UGameplayStatics::STATIC_GetPlayerCharacter(class UObject* WorldContextObject, int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCharacter");
		
		UGameplayStatics_GetPlayerCharacter_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B3B0
	 * 		Name   -> Function Engine.GameplayStatics.GetPlayerCameraManager
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            PlayerIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class APlayerCameraManager* UGameplayStatics::STATIC_GetPlayerCameraManager(class UObject* WorldContextObject, int32_t PlayerIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlayerCameraManager");
		
		UGameplayStatics_GetPlayerCameraManager_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlayerIndex = PlayerIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B530
	 * 		Name   -> Function Engine.GameplayStatics.GetPlatformName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	class FString UGameplayStatics::STATIC_GetPlatformName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetPlatformName");
		
		UGameplayStatics_GetPlatformName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B600
	 * 		Name   -> Function Engine.GameplayStatics.GetObjectClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UClass* UGameplayStatics::STATIC_GetObjectClass(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetObjectClass");
		
		UGameplayStatics_GetObjectClass_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B6E0
	 * 		Name   -> Function Engine.GameplayStatics.GetGlobalTimeDilation
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UGameplayStatics::STATIC_GetGlobalTimeDilation(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGlobalTimeDilation");
		
		UGameplayStatics_GetGlobalTimeDilation_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B810
	 * 		Name   -> Function Engine.GameplayStatics.GetGameState
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AGameState* UGameplayStatics::STATIC_GetGameState(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameState");
		
		UGameplayStatics_GetGameState_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271B910
	 * 		Name   -> Function Engine.GameplayStatics.GetGameMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AGameMode* UGameplayStatics::STATIC_GetGameMode(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameMode");
		
		UGameplayStatics_GetGameMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271BA10
	 * 		Name   -> Function Engine.GameplayStatics.GetGameInstance
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UGameInstance* UGameplayStatics::STATIC_GetGameInstance(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetGameInstance");
		
		UGameplayStatics_GetGameInstance_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271BB10
	 * 		Name   -> Function Engine.GameplayStatics.GetAudioTimeSeconds
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UGameplayStatics::STATIC_GetAudioTimeSeconds(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAudioTimeSeconds");
		
		UGameplayStatics_GetAudioTimeSeconds_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271BC10
	 * 		Name   -> Function Engine.GameplayStatics.GetAllActorsWithInterface
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      Interface                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	void UGameplayStatics::STATIC_GetAllActorsWithInterface(class UObject* WorldContextObject, class UClass* Interface, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsWithInterface");
		
		UGameplayStatics_GetAllActorsWithInterface_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Interface = Interface;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271BDD0
	 * 		Name   -> Function Engine.GameplayStatics.GetAllActorsOfClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	void UGameplayStatics::STATIC_GetAllActorsOfClass(class UObject* WorldContextObject, class UClass* ActorClass, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAllActorsOfClass");
		
		UGameplayStatics_GetAllActorsOfClass_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271BF90
	 * 		Name   -> Function Engine.GameplayStatics.GetActorArrayBounds
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AActor*>                              actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bOnlyCollidingComponents                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Center                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_GetActorArrayBounds(TArray<class AActor*> actors, bool bOnlyCollidingComponents, struct FVector* Center, struct FVector* BoxExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayBounds");
		
		UGameplayStatics_GetActorArrayBounds_Params params {};
		params.actors = actors;
		params.bOnlyCollidingComponents = bOnlyCollidingComponents;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Center != nullptr)
			*Center = params.Center;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C1C0
	 * 		Name   -> Function Engine.GameplayStatics.GetActorArrayAverageLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AActor*>                              actors                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	struct FVector UGameplayStatics::STATIC_GetActorArrayAverageLocation(TArray<class AActor*> actors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetActorArrayAverageLocation");
		
		UGameplayStatics_GetActorArrayAverageLocation_Params params {};
		params.actors = actors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C290
	 * 		Name   -> Function Engine.GameplayStatics.GetAccurateRealTime
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Seconds                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              PartialSeconds                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_GetAccurateRealTime(class UObject* WorldContextObject, int32_t* Seconds, float* PartialSeconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.GetAccurateRealTime");
		
		UGameplayStatics_GetAccurateRealTime_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Seconds != nullptr)
			*Seconds = params.Seconds;
		if (PartialSeconds != nullptr)
			*PartialSeconds = params.PartialSeconds;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C440
	 * 		Name   -> Function Engine.GameplayStatics.FinishSpawningActor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	class AActor* UGameplayStatics::STATIC_FinishSpawningActor(class AActor* Actor, const struct FTransform& SpawnTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.FinishSpawningActor");
		
		UGameplayStatics_FinishSpawningActor_Params params {};
		params.Actor = Actor;
		params.SpawnTransform = SpawnTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C5D0
	 * 		Name   -> Function Engine.GameplayStatics.EnableLiveStreaming
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               Enable                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_EnableLiveStreaming(bool Enable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.EnableLiveStreaming");
		
		UGameplayStatics_EnableLiveStreaming_Params params {};
		params.Enable = Enable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C690
	 * 		Name   -> Function Engine.GameplayStatics.DoesSaveGameExist
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_DoesSaveGameExist(const class FString& SlotName, int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DoesSaveGameExist");
		
		UGameplayStatics_DoesSaveGameExist_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271C890
	 * 		Name   -> Function Engine.GameplayStatics.DeleteGameInSlot
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      SlotName                                                   (Parm, ZeroConstructor)
	 * 		int32_t                                            UserIndex                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_DeleteGameInSlot(const class FString& SlotName, int32_t UserIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeleteGameInSlot");
		
		UGameplayStatics_DeleteGameInSlot_Params params {};
		params.SlotName = SlotName;
		params.UserIndex = UserIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CA90
	 * 		Name   -> Function Engine.GameplayStatics.DeactivateReverbEffect
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        TagName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_DeactivateReverbEffect(const class FName& TagName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.DeactivateReverbEffect");
		
		UGameplayStatics_DeactivateReverbEffect_Params params {};
		params.TagName = TagName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CB80
	 * 		Name   -> Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UBlueprint*                                  SaveGameBlueprint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObjectFromBlueprint(class UBlueprint* SaveGameBlueprint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint");
		
		UGameplayStatics_CreateSaveGameObjectFromBlueprint_Params params {};
		params.SaveGameBlueprint = SaveGameBlueprint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CC50
	 * 		Name   -> Function Engine.GameplayStatics.CreateSaveGameObject
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      SaveGameClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class USaveGame* UGameplayStatics::STATIC_CreateSaveGameObject(class UClass* SaveGameClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreateSaveGameObject");
		
		UGameplayStatics_CreateSaveGameObject_Params params {};
		params.SaveGameClass = SaveGameClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CD20
	 * 		Name   -> Function Engine.GameplayStatics.CreatePlayer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ControllerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSpawnPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class APlayerController* UGameplayStatics::STATIC_CreatePlayer(class UObject* WorldContextObject, int32_t ControllerId, bool bSpawnPawn)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.CreatePlayer");
		
		UGameplayStatics_CreatePlayer_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ControllerId = ControllerId;
		params.bSpawnPawn = bSpawnPawn;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CF00
	 * 		Name   -> Function Engine.GameplayStatics.ClearSoundMixModifiers
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UGameplayStatics::STATIC_ClearSoundMixModifiers()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ClearSoundMixModifiers");
		
		UGameplayStatics_ClearSoundMixModifiers_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271CF60
	 * 		Name   -> Function Engine.GameplayStatics.BreakHitResult_OLD
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Normal                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ImpactPoint                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ImpactNormal                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPhysicalMaterial*                           PhysMat                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      HitActor                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        HitBoneName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            HitItem                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_BreakHitResult_OLD(const struct FHitResult& Hit, struct FVector* Location, struct FVector* Normal, struct FVector* ImpactPoint, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, int32_t* HitItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult_OLD");
		
		UGameplayStatics_BreakHitResult_OLD_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Normal != nullptr)
			*Normal = params.Normal;
		if (ImpactPoint != nullptr)
			*ImpactPoint = params.ImpactPoint;
		if (ImpactNormal != nullptr)
			*ImpactNormal = params.ImpactNormal;
		if (PhysMat != nullptr)
			*PhysMat = params.PhysMat;
		if (HitActor != nullptr)
			*HitActor = params.HitActor;
		if (HitComponent != nullptr)
			*HitComponent = params.HitComponent;
		if (HitBoneName != nullptr)
			*HitBoneName = params.HitBoneName;
		if (HitItem != nullptr)
			*HitItem = params.HitItem;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271D460
	 * 		Name   -> Function Engine.GameplayStatics.BreakHitResult
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Normal                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ImpactPoint                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     ImpactNormal                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPhysicalMaterial*                           PhysMat                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      HitActor                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UPrimitiveComponent*                         HitComponent                                               (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		class FName                                        HitBoneName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            HitItem                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               BlockingHit                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_BreakHitResult(const struct FHitResult& Hit, struct FVector* Location, struct FVector* Normal, struct FVector* ImpactPoint, struct FVector* ImpactNormal, class UPhysicalMaterial** PhysMat, class AActor** HitActor, class UPrimitiveComponent** HitComponent, class FName* HitBoneName, int32_t* HitItem, bool* BlockingHit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BreakHitResult");
		
		UGameplayStatics_BreakHitResult_Params params {};
		params.Hit = Hit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Normal != nullptr)
			*Normal = params.Normal;
		if (ImpactPoint != nullptr)
			*ImpactPoint = params.ImpactPoint;
		if (ImpactNormal != nullptr)
			*ImpactNormal = params.ImpactNormal;
		if (PhysMat != nullptr)
			*PhysMat = params.PhysMat;
		if (HitActor != nullptr)
			*HitActor = params.HitActor;
		if (HitComponent != nullptr)
			*HitComponent = params.HitComponent;
		if (HitBoneName != nullptr)
			*HitBoneName = params.HitBoneName;
		if (HitItem != nullptr)
			*HitItem = params.HitItem;
		if (BlockingHit != nullptr)
			*BlockingHit = params.BlockingHit;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271D9D0
	 * 		Name   -> Function Engine.GameplayStatics.BPPointPlaneProject
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneBase                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneNorm                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FVector UGameplayStatics::STATIC_BPPointPlaneProject(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNorm)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BPPointPlaneProject");
		
		UGameplayStatics_BPPointPlaneProject_Params params {};
		params.Point = Point;
		params.PlaneBase = PlaneBase;
		params.PlaneNorm = PlaneNorm;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271DC20
	 * 		Name   -> Function Engine.GameplayStatics.BPPointPlaneDist
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneBase                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneNorm                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	float UGameplayStatics::STATIC_BPPointPlaneDist(const struct FVector& Point, const struct FVector& PlaneBase, const struct FVector& PlaneNorm)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BPPointPlaneDist");
		
		UGameplayStatics_BPPointPlaneDist_Params params {};
		params.Point = Point;
		params.PlaneBase = PlaneBase;
		params.PlaneNorm = PlaneNorm;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271DE00
	 * 		Name   -> Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TossVelocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     StartLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     EndLocation                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LaunchSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OverrideGravityZ                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ESuggestProjVelocityTraceOption                    TraceOption                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              CollisionRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bFavorHighArc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDrawDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_BlueprintSuggestProjectileVelocity(class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity");
		
		UGameplayStatics_BlueprintSuggestProjectileVelocity_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.StartLocation = StartLocation;
		params.EndLocation = EndLocation;
		params.LaunchSpeed = LaunchSpeed;
		params.OverrideGravityZ = OverrideGravityZ;
		params.TraceOption = TraceOption;
		params.CollisionRadius = CollisionRadius;
		params.bFavorHighArc = bFavorHighArc;
		params.bDrawDebug = bDrawDebug;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (TossVelocity != nullptr)
			*TossVelocity = params.TossVelocity;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271E3C0
	 * 		Name   -> Function Engine.GameplayStatics.BeginSpawningActorFromClass
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClass                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNoCollisionFail                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromClass(class UObject* WorldContextObject, class UClass* ActorClass, const struct FTransform& SpawnTransform, bool bNoCollisionFail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromClass");
		
		UGameplayStatics_BeginSpawningActorFromClass_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.ActorClass = ActorClass;
		params.SpawnTransform = SpawnTransform;
		params.bNoCollisionFail = bNoCollisionFail;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271E610
	 * 		Name   -> Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UBlueprint*                                  Blueprint                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  SpawnTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bNoCollisionFail                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class AActor* UGameplayStatics::STATIC_BeginSpawningActorFromBlueprint(class UObject* WorldContextObject, class UBlueprint* Blueprint, const struct FTransform& SpawnTransform, bool bNoCollisionFail)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint");
		
		UGameplayStatics_BeginSpawningActorFromBlueprint_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Blueprint = Blueprint;
		params.SpawnTransform = SpawnTransform;
		params.bNoCollisionFail = bNoCollisionFail;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271E860
	 * 		Name   -> Function Engine.GameplayStatics.AreAnyListenersWithinRange
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaximumRange                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_AreAnyListenersWithinRange(const struct FVector& Location, float MaximumRange)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.AreAnyListenersWithinRange");
		
		UGameplayStatics_AreAnyListenersWithinRange_Params params {};
		params.Location = Location;
		params.MaximumRange = MaximumRange;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271E9E0
	 * 		Name   -> Function Engine.GameplayStatics.ApplyRadialDamageIgnoreDamageActors
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              IgnoreDamageActors                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoFullDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_ApplyRadialDamageIgnoreDamageActors(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, TArray<class AActor*> IgnoreDamageActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamageIgnoreDamageActors");
		
		UGameplayStatics_ApplyRadialDamageIgnoreDamageActors_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BaseDamage = BaseDamage;
		params.Origin = Origin;
		params.DamageRadius = DamageRadius;
		params.DamageTypeClass = DamageTypeClass;
		params.IgnoreActors = IgnoreActors;
		params.IgnoreDamageActors = IgnoreDamageActors;
		params.DamageCauser = DamageCauser;
		params.InstigatedByController = InstigatedByController;
		params.bDoFullDamage = bDoFullDamage;
		params.DamagePreventionChannel = DamagePreventionChannel;
		params.Impulse = Impulse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271F070
	 * 		Name   -> Function Engine.GameplayStatics.ApplyRadialDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DamageRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              IgnoreActors                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 InstigatedByController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoFullDamage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  DamagePreventionChannel                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UGameplayStatics::STATIC_ApplyRadialDamage(class UObject* WorldContextObject, float BaseDamage, const struct FVector& Origin, float DamageRadius, class UClass* DamageTypeClass, TArray<class AActor*> IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, ECollisionChannel DamagePreventionChannel, float Impulse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyRadialDamage");
		
		UGameplayStatics_ApplyRadialDamage_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BaseDamage = BaseDamage;
		params.Origin = Origin;
		params.DamageRadius = DamageRadius;
		params.DamageTypeClass = DamageTypeClass;
		params.IgnoreActors = IgnoreActors;
		params.DamageCauser = DamageCauser;
		params.InstigatedByController = InstigatedByController;
		params.bDoFullDamage = bDoFullDamage;
		params.DamagePreventionChannel = DamagePreventionChannel;
		params.Impulse = Impulse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271F680
	 * 		Name   -> Function Engine.GameplayStatics.ApplyPointDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HitFromDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  HitInfo                                                    (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bForceCollisionCheck                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  ForceCollisionCheckTraceChannel                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const struct FVector& HitFromDirection, const struct FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass, float Impulse, bool bForceCollisionCheck, ECollisionChannel ForceCollisionCheckTraceChannel)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyPointDamage");
		
		UGameplayStatics_ApplyPointDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.HitFromDirection = HitFromDirection;
		params.HitInfo = HitInfo;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		params.Impulse = Impulse;
		params.bForceCollisionCheck = bForceCollisionCheck;
		params.ForceCollisionCheckTraceChannel = ForceCollisionCheckTraceChannel;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271FC00
	 * 		Name   -> Function Engine.GameplayStatics.ApplyDamage
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class AActor*                                      DamagedActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BaseDamage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AController*                                 EventInstigator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class AActor*                                      DamageCauser                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      DamageTypeClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Impulse                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UGameplayStatics::STATIC_ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, class UClass* DamageTypeClass, float Impulse)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ApplyDamage");
		
		UGameplayStatics_ApplyDamage_Params params {};
		params.DamagedActor = DamagedActor;
		params.BaseDamage = BaseDamage;
		params.EventInstigator = EventInstigator;
		params.DamageCauser = DamageCauser;
		params.DamageTypeClass = DamageTypeClass;
		params.Impulse = Impulse;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0271FF60
	 * 		Name   -> Function Engine.GameplayStatics.ActivateReverbEffect
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UReverbEffect*                               ReverbEffect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        TagName                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Priority                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              Volume                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              FadeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void UGameplayStatics::STATIC_ActivateReverbEffect(class UReverbEffect* ReverbEffect, const class FName& TagName, float Priority, float Volume, float FadeTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.GameplayStatics.ActivateReverbEffect");
		
		UGameplayStatics_ActivateReverbEffect_Params params {};
		params.ReverbEffect = ReverbEffect;
		params.TagName = TagName;
		params.Priority = Priority;
		params.Volume = Volume;
		params.FadeTime = FadeTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UGameplayStatics.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UGameplayStatics::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.GameplayStatics");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715A30
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.ResetOrientationAndPosition
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UHeadMountedDisplayFunctionLibrary::STATIC_ResetOrientationAndPosition(float Yaw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.ResetOrientationAndPosition");
		
		UHeadMountedDisplayFunctionLibrary_ResetOrientationAndPosition_Params params {};
		params.Yaw = Yaw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715B40
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.IsInLowPersistenceMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UHeadMountedDisplayFunctionLibrary::STATIC_IsInLowPersistenceMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.IsInLowPersistenceMode");
		
		UHeadMountedDisplayFunctionLibrary_IsInLowPersistenceMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715BC0
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.IsHeadMountedDisplayEnabled
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UHeadMountedDisplayFunctionLibrary::STATIC_IsHeadMountedDisplayEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.IsHeadMountedDisplayEnabled");
		
		UHeadMountedDisplayFunctionLibrary_IsHeadMountedDisplayEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715C30
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.HasValidTrackingPosition
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UHeadMountedDisplayFunctionLibrary::STATIC_HasValidTrackingPosition()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.HasValidTrackingPosition");
		
		UHeadMountedDisplayFunctionLibrary_HasValidTrackingPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715CB0
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.GetScreenPercentage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	float UHeadMountedDisplayFunctionLibrary::STATIC_GetScreenPercentage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.GetScreenPercentage");
		
		UHeadMountedDisplayFunctionLibrary_GetScreenPercentage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715D10
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.GetPositionalTrackingCameraParameters
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     CameraOrigin                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    CameraRotation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HFOV                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              VFOV                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              CameraDistance                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              NearPlane                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              FarPlane                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UHeadMountedDisplayFunctionLibrary::STATIC_GetPositionalTrackingCameraParameters(struct FVector* CameraOrigin, struct FRotator* CameraRotation, float* HFOV, float* VFOV, float* CameraDistance, float* NearPlane, float* FarPlane)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.GetPositionalTrackingCameraParameters");
		
		UHeadMountedDisplayFunctionLibrary_GetPositionalTrackingCameraParameters_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (CameraOrigin != nullptr)
			*CameraOrigin = params.CameraOrigin;
		if (CameraRotation != nullptr)
			*CameraRotation = params.CameraRotation;
		if (HFOV != nullptr)
			*HFOV = params.HFOV;
		if (VFOV != nullptr)
			*VFOV = params.VFOV;
		if (CameraDistance != nullptr)
			*CameraDistance = params.CameraDistance;
		if (NearPlane != nullptr)
			*NearPlane = params.NearPlane;
		if (FarPlane != nullptr)
			*FarPlane = params.FarPlane;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027160A0
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.GetOrientationAndPosition
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    DeviceRotation                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     DevicePosition                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UHeadMountedDisplayFunctionLibrary::STATIC_GetOrientationAndPosition(struct FRotator* DeviceRotation, struct FVector* DevicePosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.GetOrientationAndPosition");
		
		UHeadMountedDisplayFunctionLibrary_GetOrientationAndPosition_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (DeviceRotation != nullptr)
			*DeviceRotation = params.DeviceRotation;
		if (DevicePosition != nullptr)
			*DevicePosition = params.DevicePosition;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027161D0
	 * 		Name   -> Function Engine.HeadMountedDisplayFunctionLibrary.EnableLowPersistenceMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bEnable                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UHeadMountedDisplayFunctionLibrary::STATIC_EnableLowPersistenceMode(bool bEnable)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.HeadMountedDisplayFunctionLibrary.EnableLowPersistenceMode");
		
		UHeadMountedDisplayFunctionLibrary_EnableLowPersistenceMode_Params params {};
		params.bEnable = bEnable;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UHeadMountedDisplayFunctionLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UHeadMountedDisplayFunctionLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.HeadMountedDisplayFunctionLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333420
	 * 		Name   -> Function Engine.KismetArrayLibrary.SetArrayPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<int32_t>                                    Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void UKismetArrayLibrary::STATIC_SetArrayPropertyByName(class UObject* Object, const class FName& PropertyName, TArray<int32_t> Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.SetArrayPropertyByName");
		
		UKismetArrayLibrary_SetArrayPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331040
	 * 		Name   -> Function Engine.KismetArrayLibrary.FilterArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class AActor*>                              TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      FilterClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              FilteredArray                                              (Parm, OutParm, ZeroConstructor)
	 */
	void UKismetArrayLibrary::STATIC_FilterArray(TArray<class AActor*> TargetArray, class UClass* FilterClass, TArray<class AActor*>* FilteredArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.FilterArray");
		
		UKismetArrayLibrary_FilterArray_Params params {};
		params.TargetArray = TargetArray;
		params.FilterClass = FilterClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (FilteredArray != nullptr)
			*FilteredArray = params.FilteredArray;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331720
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Shuffle
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Shuffle(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Shuffle");
		
		UKismetArrayLibrary_Array_Shuffle_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332B50
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Set
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Item                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSizeToFit                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Set(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t index, int32_t Item, bool bSizeToFit)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Set");
		
		UKismetArrayLibrary_Array_Set_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.index = index;
		params.Item = Item;
		params.bSizeToFit = bSizeToFit;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332380
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Resize
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Resize(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t Size)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Resize");
		
		UKismetArrayLibrary_Array_Resize_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.Size = Size;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331FA0
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_RemoveItem
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Item                                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	bool UKismetArrayLibrary::STATIC_Array_RemoveItem(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_RemoveItem");
		
		UKismetArrayLibrary_Array_RemoveItem_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.Item = Item;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331DB0
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Remove
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            IndexToRemove                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Remove(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t IndexToRemove)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Remove");
		
		UKismetArrayLibrary_Array_Remove_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.IndexToRemove = IndexToRemove;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332540
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Length
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetArrayLibrary::STATIC_Array_Length(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Length");
		
		UKismetArrayLibrary_Array_Length_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332690
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_LastIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetArrayLibrary::STATIC_Array_LastIndex(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_LastIndex");
		
		UKismetArrayLibrary_Array_LastIndex_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333610
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_IsValidIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexToTest                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetArrayLibrary::STATIC_Array_IsValidIndex(TArray<int32_t> TargetArray, int32_t IndexToTest)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_IsValidIndex");
		
		UKismetArrayLibrary_Array_IsValidIndex_Params params {};
		params.TargetArray = TargetArray;
		params.IndexToTest = IndexToTest;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331AA0
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Insert
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            newItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Insert(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t newItem, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Insert");
		
		UKismetArrayLibrary_Array_Insert_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.newItem = newItem;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023327E0
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Get
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Item                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Get(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t index, int32_t* Item)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Get");
		
		UKismetArrayLibrary_Array_Get_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Item != nullptr)
			*Item = params.Item;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332EF0
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Find
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ItemToFind                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetArrayLibrary::STATIC_Array_Find(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t ItemToFind)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Find");
		
		UKismetArrayLibrary_Array_Find_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.ItemToFind = ItemToFind;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333180
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Contains
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            ItemToFind                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	bool UKismetArrayLibrary::STATIC_Array_Contains(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t ItemToFind)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Contains");
		
		UKismetArrayLibrary_Array_Contains_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.ItemToFind = ItemToFind;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02332230
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Clear
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Clear(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Clear");
		
		UKismetArrayLibrary_Array_Clear_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331870
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Append
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              TargetArrayProperty                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<int32_t>                                    SourceArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              SourceArrayProperty                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetArrayLibrary::STATIC_Array_Append(TArray<int32_t> TargetArray, class UArrayProperty* TargetArrayProperty, TArray<int32_t> SourceArray, class UArrayProperty* SourceArrayProperty)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Append");
		
		UKismetArrayLibrary_Array_Append_Params params {};
		params.TargetArray = TargetArray;
		params.TargetArrayProperty = TargetArrayProperty;
		params.SourceArray = SourceArray;
		params.SourceArrayProperty = SourceArrayProperty;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331490
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_AddUnique
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            newItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetArrayLibrary::STATIC_Array_AddUnique(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t newItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_AddUnique");
		
		UKismetArrayLibrary_Array_AddUnique_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.newItem = newItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02331200
	 * 		Name   -> Function Engine.KismetArrayLibrary.Array_Add
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<int32_t>                                    TargetArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UArrayProperty*                              ArrayProperty                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            newItem                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetArrayLibrary::STATIC_Array_Add(TArray<int32_t> TargetArray, class UArrayProperty* ArrayProperty, int32_t newItem)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetArrayLibrary.Array_Add");
		
		UKismetArrayLibrary_Array_Add_Params params {};
		params.TargetArray = TargetArray;
		params.ArrayProperty = ArrayProperty;
		params.newItem = newItem;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetArrayLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetArrayLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetArrayLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333760
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_PointerEvent_IsTouchEvent(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent");
		
		UKismetInputLibrary_PointerEvent_IsTouchEvent_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333820
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FKey                                        MouseButton                                                (Parm)
	 */
	bool UKismetInputLibrary::STATIC_PointerEvent_IsMouseButtonDown(const struct FPointerEvent& Input, const struct FKey& MouseButton)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown");
		
		UKismetInputLibrary_PointerEvent_IsMouseButtonDown_Params params {};
		params.Input = Input;
		params.MouseButton = MouseButton;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023339D0
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	float UKismetInputLibrary::STATIC_PointerEvent_GetWheelDelta(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta");
		
		UKismetInputLibrary_PointerEvent_GetWheelDelta_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333A90
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	int32_t UKismetInputLibrary::STATIC_PointerEvent_GetUserIndex(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex");
		
		UKismetInputLibrary_PointerEvent_GetUserIndex_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333B50
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	int32_t UKismetInputLibrary::STATIC_PointerEvent_GetTouchpadIndex(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex");
		
		UKismetInputLibrary_PointerEvent_GetTouchpadIndex_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333C10
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetScreenSpacePosition(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition");
		
		UKismetInputLibrary_PointerEvent_GetScreenSpacePosition_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333CD0
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	int32_t UKismetInputLibrary::STATIC_PointerEvent_GetPointerIndex(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex");
		
		UKismetInputLibrary_PointerEvent_GetPointerIndex_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333D90
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetLastScreenSpacePosition(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition");
		
		UKismetInputLibrary_PointerEvent_GetLastScreenSpacePosition_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333E50
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetGestureDelta(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta");
		
		UKismetInputLibrary_PointerEvent_GetGestureDelta_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02333F10
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FKey UKismetInputLibrary::STATIC_PointerEvent_GetEffectingButton(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton");
		
		UKismetInputLibrary_PointerEvent_GetEffectingButton_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334010
	 * 		Name   -> Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FPointerEvent                               Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FVector2D UKismetInputLibrary::STATIC_PointerEvent_GetCursorDelta(const struct FPointerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta");
		
		UKismetInputLibrary_PointerEvent_GetCursorDelta_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023340D0
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsShiftDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsShiftDown");
		
		UKismetInputLibrary_InputEvent_IsShiftDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334190
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsRightShiftDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown");
		
		UKismetInputLibrary_InputEvent_IsRightShiftDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334250
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsRightControlDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown");
		
		UKismetInputLibrary_InputEvent_IsRightControlDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334310
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsRightCommandDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown");
		
		UKismetInputLibrary_InputEvent_IsRightCommandDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023343D0
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsRightAltDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown");
		
		UKismetInputLibrary_InputEvent_IsRightAltDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334490
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsRepeat
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsRepeat(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsRepeat");
		
		UKismetInputLibrary_InputEvent_IsRepeat_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334550
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftShiftDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown");
		
		UKismetInputLibrary_InputEvent_IsLeftShiftDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334610
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftControlDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown");
		
		UKismetInputLibrary_InputEvent_IsLeftControlDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023346D0
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftCommandDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown");
		
		UKismetInputLibrary_InputEvent_IsLeftCommandDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334790
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsLeftAltDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown");
		
		UKismetInputLibrary_InputEvent_IsLeftAltDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334850
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsControlDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsControlDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsControlDown");
		
		UKismetInputLibrary_InputEvent_IsControlDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334910
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsCommandDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsCommandDown");
		
		UKismetInputLibrary_InputEvent_IsCommandDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023349D0
	 * 		Name   -> Function Engine.KismetInputLibrary.InputEvent_IsAltDown
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FInputEvent                                 Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetInputLibrary::STATIC_InputEvent_IsAltDown(const struct FInputEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.InputEvent_IsAltDown");
		
		UKismetInputLibrary_InputEvent_IsAltDown_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334A90
	 * 		Name   -> Function Engine.KismetInputLibrary.GetKey
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		struct FKeyboardEvent                              Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FKey UKismetInputLibrary::STATIC_GetKey(const struct FKeyboardEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.GetKey");
		
		UKismetInputLibrary_GetKey_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334B90
	 * 		Name   -> Function Engine.KismetInputLibrary.EqualEqual_KeyKey
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FKey                                        A                                                          (Parm)
	 * 		struct FKey                                        B                                                          (Parm)
	 */
	bool UKismetInputLibrary::STATIC_EqualEqual_KeyKey(const struct FKey& A, const struct FKey& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.EqualEqual_KeyKey");
		
		UKismetInputLibrary_EqualEqual_KeyKey_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334DA0
	 * 		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetUserIndex
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	int32_t UKismetInputLibrary::STATIC_ControllerEvent_GetUserIndex(const struct FControllerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetUserIndex");
		
		UKismetInputLibrary_ControllerEvent_GetUserIndex_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334A90
	 * 		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetEffectingButton
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FKey UKismetInputLibrary::STATIC_ControllerEvent_GetEffectingButton(const struct FControllerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetEffectingButton");
		
		UKismetInputLibrary_ControllerEvent_GetEffectingButton_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334E60
	 * 		Name   -> Function Engine.KismetInputLibrary.ControllerEvent_GetAnalogValue
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FControllerEvent                            Input                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	float UKismetInputLibrary::STATIC_ControllerEvent_GetAnalogValue(const struct FControllerEvent& Input)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.ControllerEvent_GetAnalogValue");
		
		UKismetInputLibrary_ControllerEvent_GetAnalogValue_Params params {};
		params.Input = Input;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334F20
	 * 		Name   -> Function Engine.KismetInputLibrary.CalibrateTilt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UKismetInputLibrary::STATIC_CalibrateTilt()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetInputLibrary.CalibrateTilt");
		
		UKismetInputLibrary_CalibrateTilt_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetInputLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetInputLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetInputLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02334F70
	 * 		Name   -> Function Engine.KismetMaterialLibrary.SetVectorParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                ParameterValue                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetMaterialLibrary::STATIC_SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const class FName& ParameterName, const struct FLinearColor& ParameterValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetVectorParameterValue");
		
		UKismetMaterialLibrary_SetVectorParameterValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023351C0
	 * 		Name   -> Function Engine.KismetMaterialLibrary.SetScalarParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ParameterValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMaterialLibrary::STATIC_SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const class FName& ParameterName, float ParameterValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.SetScalarParameterValue");
		
		UKismetMaterialLibrary_SetScalarParameterValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		params.ParameterValue = ParameterValue;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335420
	 * 		Name   -> Function Engine.KismetMaterialLibrary.ResetMaterialParameterCollectionInstance
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMaterialLibrary::STATIC_ResetMaterialParameterCollectionInstance(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.ResetMaterialParameterCollectionInstance");
		
		UKismetMaterialLibrary_ResetMaterialParameterCollectionInstance_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335570
	 * 		Name   -> Function Engine.KismetMaterialLibrary.GetVectorParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMaterialLibrary::STATIC_GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const class FName& ParameterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetVectorParameterValue");
		
		UKismetMaterialLibrary_GetVectorParameterValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335750
	 * 		Name   -> Function Engine.KismetMaterialLibrary.GetScalarParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialParameterCollection*                Collection                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMaterialLibrary::STATIC_GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, const class FName& ParameterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.GetScalarParameterValue");
		
		UKismetMaterialLibrary_GetScalarParameterValue_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Collection = Collection;
		params.ParameterName = ParameterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335930
	 * 		Name   -> Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Parent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UMaterialInstanceDynamic* UKismetMaterialLibrary::STATIC_CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance");
		
		UKismetMaterialLibrary_CreateDynamicMaterialInstance_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Parent = Parent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetMaterialLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetMaterialLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetMaterialLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335AB0
	 * 		Name   -> Function Engine.KismetMathLibrary.Xor_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Xor_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Xor_IntInt");
		
		UKismetMathLibrary_Xor_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335C00
	 * 		Name   -> Function Engine.KismetMathLibrary.WrapAngle
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              degrees                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_WrapAngle(float degrees)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.WrapAngle");
		
		UKismetMathLibrary_WrapAngle_Params params {};
		params.degrees = degrees;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335CF0
	 * 		Name   -> Function Engine.KismetMathLibrary.VSizeSquared2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_VSizeSquared2D(const struct FVector2D& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared2D");
		
		UKismetMathLibrary_VSizeSquared2D_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335DC0
	 * 		Name   -> Function Engine.KismetMathLibrary.VSizeSquared
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_VSizeSquared(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSizeSquared");
		
		UKismetMathLibrary_VSizeSquared_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335EA0
	 * 		Name   -> Function Engine.KismetMathLibrary.VSize2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_VSize2D(const struct FVector2D& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize2D");
		
		UKismetMathLibrary_VSize2D_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02335F70
	 * 		Name   -> Function Engine.KismetMathLibrary.VSize
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_VSize(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VSize");
		
		UKismetMathLibrary_VSize_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02336050
	 * 		Name   -> Function Engine.KismetMathLibrary.VLerp
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VLerp(const struct FVector& A, const struct FVector& B, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VLerp");
		
		UKismetMathLibrary_VLerp_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02336280
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_SnapWithinDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SnapWithinDist                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_SnapWithinDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float SnapWithinDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_SnapWithinDist");
		
		UKismetMathLibrary_VInterpTo_SnapWithinDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.SnapWithinDist = SnapWithinDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023366F0
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_SnapPastDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SnapPastDist                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_SnapPastDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float SnapPastDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_SnapPastDist");
		
		UKismetMathLibrary_VInterpTo_SnapPastDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.SnapPastDist = SnapPastDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02336B90
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_Constant_SnapWithinDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SnapWithinDist                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant_SnapWithinDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float SnapWithinDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant_SnapWithinDist");
		
		UKismetMathLibrary_VInterpTo_Constant_SnapWithinDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.SnapWithinDist = SnapWithinDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02337030
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_Constant_SnapPastDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SnapPastDist                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant_SnapPastDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float SnapPastDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant_SnapPastDist");
		
		UKismetMathLibrary_VInterpTo_Constant_SnapPastDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.SnapPastDist = SnapPastDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023374F0
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_Constant_ClampDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ClampDist                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant_ClampDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float ClampDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant_ClampDist");
		
		UKismetMathLibrary_VInterpTo_Constant_ClampDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.ClampDist = ClampDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02337800
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_Constant
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_Constant(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_Constant");
		
		UKismetMathLibrary_VInterpTo_Constant_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02337B80
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo_ClampDist
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ClampDist                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo_ClampDist(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed, float ClampDist)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo_ClampDist");
		
		UKismetMathLibrary_VInterpTo_ClampDist_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		params.ClampDist = ClampDist;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02337E90
	 * 		Name   -> Function Engine.KismetMathLibrary.VInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VInterpTo(const struct FVector& current, const struct FVector& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VInterpTo");
		
		UKismetMathLibrary_VInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338240
	 * 		Name   -> Function Engine.KismetMathLibrary.VEase
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEasingFunc                                        EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_VEase(const struct FVector& A, const struct FVector& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32_t Steps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.VEase");
		
		UKismetMathLibrary_VEase_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023385E0
	 * 		Name   -> Function Engine.KismetMathLibrary.UtcNow
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_UtcNow()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.UtcNow");
		
		UKismetMathLibrary_UtcNow_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338680
	 * 		Name   -> Function Engine.KismetMathLibrary.TransformLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_TransformLocation(const struct FTransform& T, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformLocation");
		
		UKismetMathLibrary_TransformLocation_Params params {};
		params.T = T;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023387F0
	 * 		Name   -> Function Engine.KismetMathLibrary.TransformDirection
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_TransformDirection(const struct FTransform& T, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TransformDirection");
		
		UKismetMathLibrary_TransformDirection_Params params {};
		params.T = T;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338960
	 * 		Name   -> Function Engine.KismetMathLibrary.Today
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_Today()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Today");
		
		UKismetMathLibrary_Today_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338A10
	 * 		Name   -> Function Engine.KismetMathLibrary.TLerp
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_TLerp(const struct FTransform& A, const struct FTransform& B, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TLerp");
		
		UKismetMathLibrary_TLerp_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338BF0
	 * 		Name   -> Function Engine.KismetMathLibrary.TInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  current                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  Target                                                     (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_TInterpTo(const struct FTransform& current, const struct FTransform& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TInterpTo");
		
		UKismetMathLibrary_TInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E9EED0
	 * 		Name   -> Function Engine.KismetMathLibrary.TimespanZeroValue
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_TimespanZeroValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanZeroValue");
		
		UKismetMathLibrary_TimespanZeroValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02338EA0
	 * 		Name   -> Function Engine.KismetMathLibrary.TimespanRatio
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_TimespanRatio(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanRatio");
		
		UKismetMathLibrary_TimespanRatio_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339010
	 * 		Name   -> Function Engine.KismetMathLibrary.TimespanMinValue
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_TimespanMinValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMinValue");
		
		UKismetMathLibrary_TimespanMinValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339040
	 * 		Name   -> Function Engine.KismetMathLibrary.TimespanMaxValue
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_TimespanMaxValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TimespanMaxValue");
		
		UKismetMathLibrary_TimespanMaxValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339070
	 * 		Name   -> Function Engine.KismetMathLibrary.TEase
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEasingFunc                                        EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_TEase(const struct FTransform& A, const struct FTransform& B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32_t Steps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.TEase");
		
		UKismetMathLibrary_TEase_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339400
	 * 		Name   -> Function Engine.KismetMathLibrary.Tan
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Tan(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Tan");
		
		UKismetMathLibrary_Tan_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023394D0
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Subtract_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorVector");
		
		UKismetMathLibrary_Subtract_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339640
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_VectorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Subtract_VectorFloat(const struct FVector& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_VectorFloat");
		
		UKismetMathLibrary_Subtract_VectorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023397B0
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D");
		
		UKismetMathLibrary_Subtract_Vector2DVector2D_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339900
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Subtract_Vector2DFloat(const struct FVector2D& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_Vector2DFloat");
		
		UKismetMathLibrary_Subtract_Vector2DFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339A60
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_Subtract_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_TimespanTimespan");
		
		UKismetMathLibrary_Subtract_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339BA0
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Subtract_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_IntInt");
		
		UKismetMathLibrary_Subtract_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339CF0
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Subtract_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_FloatFloat");
		
		UKismetMathLibrary_Subtract_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339E40
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_DoubleFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Subtract_DoubleFloat(double A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DoubleFloat");
		
		UKismetMathLibrary_Subtract_DoubleFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339FA0
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Subtract_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DoubleDouble");
		
		UKismetMathLibrary_Subtract_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02339A60
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_Subtract_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan");
		
		UKismetMathLibrary_Subtract_DateTimeTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A100
	 * 		Name   -> Function Engine.KismetMathLibrary.Subtract_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Subtract_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Subtract_ByteByte");
		
		UKismetMathLibrary_Subtract_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A250
	 * 		Name   -> Function Engine.KismetMathLibrary.Square
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Square(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Square");
		
		UKismetMathLibrary_Square_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A320
	 * 		Name   -> Function Engine.KismetMathLibrary.Sqrt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Sqrt(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sqrt");
		
		UKismetMathLibrary_Sqrt_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A410
	 * 		Name   -> Function Engine.KismetMathLibrary.Sin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Sin(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Sin");
		
		UKismetMathLibrary_Sin_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A4E0
	 * 		Name   -> Function Engine.KismetMathLibrary.SignOfInteger
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_SignOfInteger(int32_t A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfInteger");
		
		UKismetMathLibrary_SignOfInteger_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A5D0
	 * 		Name   -> Function Engine.KismetMathLibrary.SignOfFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_SignOfFloat(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SignOfFloat");
		
		UKismetMathLibrary_SignOfFloat_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A6E0
	 * 		Name   -> Function Engine.KismetMathLibrary.SetRandomStreamSeed
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            NewSeed                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_SetRandomStreamSeed(struct FRandomStream* Stream, int32_t NewSeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SetRandomStreamSeed");
		
		UKismetMathLibrary_SetRandomStreamSeed_Params params {};
		params.NewSeed = NewSeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Stream != nullptr)
			*Stream = params.Stream;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A820
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_SelectVector(const struct FVector& A, const struct FVector& B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectVector");
		
		UKismetMathLibrary_SelectVector_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233AA30
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_SelectTransform(const struct FTransform& A, const struct FTransform& B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectTransform");
		
		UKismetMathLibrary_SelectTransform_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233AC00
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetMathLibrary::STATIC_SelectString(const class FString& A, const class FString& B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectString");
		
		UKismetMathLibrary_SelectString_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233A820
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_SelectRotator(const struct FRotator& A, const struct FRotator& B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectRotator");
		
		UKismetMathLibrary_SelectRotator_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233AED0
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectObject
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSelectA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UObject* UKismetMathLibrary::STATIC_SelectObject(class UObject* A, class UObject* B, bool bSelectA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectObject");
		
		UKismetMathLibrary_SelectObject_Params params {};
		params.A = A;
		params.B = B;
		params.bSelectA = bSelectA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B0A0
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_SelectInt(int32_t A, int32_t B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectInt");
		
		UKismetMathLibrary_SelectInt_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B270
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_SelectFloat(float A, float B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectFloat");
		
		UKismetMathLibrary_SelectFloat_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B460
	 * 		Name   -> Function Engine.KismetMathLibrary.SelectColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPickA                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_SelectColor(const struct FLinearColor& A, const struct FLinearColor& B, bool bPickA)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SelectColor");
		
		UKismetMathLibrary_SelectColor_Params params {};
		params.A = A;
		params.B = B;
		params.bPickA = bPickA;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B660
	 * 		Name   -> Function Engine.KismetMathLibrary.SeedRandomStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void UKismetMathLibrary::STATIC_SeedRandomStream(struct FRandomStream* Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.SeedRandomStream");
		
		UKismetMathLibrary_SeedRandomStream_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Stream != nullptr)
			*Stream = params.Stream;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B720
	 * 		Name   -> Function Engine.KismetMathLibrary.Round
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Round(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Round");
		
		UKismetMathLibrary_Round_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B800
	 * 		Name   -> Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Angle                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RotatorFromAxisAndAngle(const struct FVector& Axis, float Angle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle");
		
		UKismetMathLibrary_RotatorFromAxisAndAngle_Params params {};
		params.Axis = Axis;
		params.Angle = Angle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233B970
	 * 		Name   -> Function Engine.KismetMathLibrary.RotateAngleAxis
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     InVect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AngleDeg                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Axis                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_RotateAngleAxis(const struct FVector& InVect, float AngleDeg, const struct FVector& Axis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RotateAngleAxis");
		
		UKismetMathLibrary_RotateAngleAxis_Params params {};
		params.InVect = InVect;
		params.AngleDeg = AngleDeg;
		params.Axis = Axis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233BB90
	 * 		Name   -> Function Engine.KismetMathLibrary.RLerp
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bShortestPath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RLerp(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RLerp");
		
		UKismetMathLibrary_RLerp_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.bShortestPath = bShortestPath;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233BE20
	 * 		Name   -> Function Engine.KismetMathLibrary.RInterpTo_PerAxis
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InterpSpeedPerAxis                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RInterpTo_PerAxis(const struct FRotator& current, const struct FRotator& Target, float DeltaTime, const struct FRotator& InterpSpeedPerAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_PerAxis");
		
		UKismetMathLibrary_RInterpTo_PerAxis_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeedPerAxis = InterpSpeedPerAxis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233C0D0
	 * 		Name   -> Function Engine.KismetMathLibrary.RInterpTo_Constant_PerAxis
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    InterpSpeedPerAxis                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RInterpTo_Constant_PerAxis(const struct FRotator& current, const struct FRotator& Target, float DeltaTime, const struct FRotator& InterpSpeedPerAxis)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant_PerAxis");
		
		UKismetMathLibrary_RInterpTo_Constant_PerAxis_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeedPerAxis = InterpSpeedPerAxis;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233C380
	 * 		Name   -> Function Engine.KismetMathLibrary.RInterpTo_Constant
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RInterpTo_Constant(const struct FRotator& current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo_Constant");
		
		UKismetMathLibrary_RInterpTo_Constant_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233C610
	 * 		Name   -> Function Engine.KismetMathLibrary.RInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RInterpTo(const struct FRotator& current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RInterpTo");
		
		UKismetMathLibrary_RInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233C8B0
	 * 		Name   -> Function Engine.KismetMathLibrary.RGBToHSV_Vector
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                RGB                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                HSV                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_RGBToHSV_Vector(const struct FLinearColor& RGB, struct FLinearColor* HSV)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV_Vector");
		
		UKismetMathLibrary_RGBToHSV_Vector_Params params {};
		params.RGB = RGB;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (HSV != nullptr)
			*HSV = params.HSV;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233CA00
	 * 		Name   -> Function Engine.KismetMathLibrary.RGBToHSV
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                InColor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              H                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              S                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              V                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              A                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_RGBToHSV(const struct FLinearColor& InColor, float* H, float* S, float* V, float* A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RGBToHSV");
		
		UKismetMathLibrary_RGBToHSV_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (H != nullptr)
			*H = params.H;
		if (S != nullptr)
			*S = params.S;
		if (V != nullptr)
			*V = params.V;
		if (A != nullptr)
			*A = params.A;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233CCE0
	 * 		Name   -> Function Engine.KismetMathLibrary.ResetRandomStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	void UKismetMathLibrary::STATIC_ResetRandomStream(const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ResetRandomStream");
		
		UKismetMathLibrary_ResetRandomStream_Params params {};
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233CD90
	 * 		Name   -> Function Engine.KismetMathLibrary.REase
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bShortestPath                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEasingFunc                                        EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_REase(const struct FRotator& A, const struct FRotator& B, float Alpha, bool bShortestPath, EEasingFunc EasingFunc, float BlendExp, int32_t Steps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.REase");
		
		UKismetMathLibrary_REase_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.bShortestPath = bShortestPath;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D1B0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomUnitVectorInCone
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     ConeDir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ConeHalfAngle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorInCone(const struct FVector& ConeDir, float ConeHalfAngle)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorInCone");
		
		UKismetMathLibrary_RandomUnitVectorInCone_Params params {};
		params.ConeDir = ConeDir;
		params.ConeHalfAngle = ConeHalfAngle;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D320
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	struct FVector UKismetMathLibrary::STATIC_RandomUnitVectorFromStream(const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVectorFromStream");
		
		UKismetMathLibrary_RandomUnitVectorFromStream_Params params {};
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D3F0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomUnitVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FVector UKismetMathLibrary::STATIC_RandomUnitVector()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomUnitVector");
		
		UKismetMathLibrary_RandomUnitVector_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D430
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomRotatorFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bRoll                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RandomRotatorFromStream(bool bRoll, const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotatorFromStream");
		
		UKismetMathLibrary_RandomRotatorFromStream_Params params {};
		params.bRoll = bRoll;
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D590
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               bRoll                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_RandomRotator(bool bRoll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomRotator");
		
		UKismetMathLibrary_RandomRotator_Params params {};
		params.bRoll = bRoll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D6D0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomPointInBoundingBox
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_RandomPointInBoundingBox(const struct FVector& Origin, const struct FVector& BoxExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomPointInBoundingBox");
		
		UKismetMathLibrary_RandomPointInBoundingBox_Params params {};
		params.Origin = Origin;
		params.BoxExtent = BoxExtent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233D820
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	int32_t UKismetMathLibrary::STATIC_RandomIntegerInRangeFromStream(int32_t Min, int32_t Max, const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream");
		
		UKismetMathLibrary_RandomIntegerInRangeFromStream_Params params {};
		params.Min = Min;
		params.Max = Max;
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233DA60
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomIntegerInRange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_RandomIntegerInRange(int32_t Min, int32_t Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerInRange");
		
		UKismetMathLibrary_RandomIntegerInRange_Params params {};
		params.Min = Min;
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233DBE0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomIntegerFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	int32_t UKismetMathLibrary::STATIC_RandomIntegerFromStream(int32_t Max, const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomIntegerFromStream");
		
		UKismetMathLibrary_RandomIntegerFromStream_Params params {};
		params.Max = Max;
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233DD90
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomInteger
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_RandomInteger(int32_t Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomInteger");
		
		UKismetMathLibrary_RandomInteger_Params params {};
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233DEA0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	float UKismetMathLibrary::STATIC_RandomFloatInRangeFromStream(float Min, float Max, const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream");
		
		UKismetMathLibrary_RandomFloatInRangeFromStream_Params params {};
		params.Min = Min;
		params.Max = Max;
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E0B0
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomFloatInRange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_RandomFloatInRange(float Min, float Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatInRange");
		
		UKismetMathLibrary_RandomFloatInRange_Params params {};
		params.Min = Min;
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E240
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomFloatFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	float UKismetMathLibrary::STATIC_RandomFloatFromStream(const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloatFromStream");
		
		UKismetMathLibrary_RandomFloatFromStream_Params params {};
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E340
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	float UKismetMathLibrary::STATIC_RandomFloat()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomFloat");
		
		UKismetMathLibrary_RandomFloat_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E380
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomBoolFromStream
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRandomStream                               Stream                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	bool UKismetMathLibrary::STATIC_RandomBoolFromStream(const struct FRandomStream& Stream)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBoolFromStream");
		
		UKismetMathLibrary_RandomBoolFromStream_Params params {};
		params.Stream = Stream;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E490
	 * 		Name   -> Function Engine.KismetMathLibrary.RandomBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UKismetMathLibrary::STATIC_RandomBool()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RandomBool");
		
		UKismetMathLibrary_RandomBool_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E4E0
	 * 		Name   -> Function Engine.KismetMathLibrary.RadiansToDegrees
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_RadiansToDegrees(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.RadiansToDegrees");
		
		UKismetMathLibrary_RadiansToDegrees_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E5B0
	 * 		Name   -> Function Engine.KismetMathLibrary.QInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_QInterpTo(const struct FRotator& current, const struct FRotator& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.QInterpTo");
		
		UKismetMathLibrary_QInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233E8F0
	 * 		Name   -> Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_ProjectVectorOnToPlane(const struct FVector& V, const struct FVector& PlaneNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectVectorOnToPlane");
		
		UKismetMathLibrary_ProjectVectorOnToPlane_Params params {};
		params.V = V;
		params.PlaneNormal = PlaneNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233EAB0
	 * 		Name   -> Function Engine.KismetMathLibrary.ProjectOnTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_ProjectOnTo(const struct FVector& X, const struct FVector& Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ProjectOnTo");
		
		UKismetMathLibrary_ProjectOnTo_Params params {};
		params.X = X;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233EC80
	 * 		Name   -> Function Engine.KismetMathLibrary.PointsAreCoplanar
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<struct FVector>                             Points                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		float                                              Tolerance                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_PointsAreCoplanar(TArray<struct FVector> Points, float Tolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.PointsAreCoplanar");
		
		UKismetMathLibrary_PointsAreCoplanar_Params params {};
		params.Points = Points;
		params.Tolerance = Tolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233EDD0
	 * 		Name   -> Function Engine.KismetMathLibrary.Percent_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Percent_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_IntInt");
		
		UKismetMathLibrary_Percent_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233EF40
	 * 		Name   -> Function Engine.KismetMathLibrary.Percent_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Percent_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_FloatFloat");
		
		UKismetMathLibrary_Percent_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F0B0
	 * 		Name   -> Function Engine.KismetMathLibrary.Percent_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Percent_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_DoubleDouble");
		
		UKismetMathLibrary_Percent_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F230
	 * 		Name   -> Function Engine.KismetMathLibrary.Percent_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Percent_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Percent_ByteByte");
		
		UKismetMathLibrary_Percent_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F3A0
	 * 		Name   -> Function Engine.KismetMathLibrary.Or_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Or_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Or_IntInt");
		
		UKismetMathLibrary_Or_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F4F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Now
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_Now()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Now");
		
		UKismetMathLibrary_Now_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F590
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_VectorVector");
		
		UKismetMathLibrary_NotEqual_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F700
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan");
		
		UKismetMathLibrary_NotEqual_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F590
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_RotatorRotator");
		
		UKismetMathLibrary_NotEqual_RotatorRotator_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F840
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_ObjectObject
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_ObjectObject(class UObject* A, class UObject* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ObjectObject");
		
		UKismetMathLibrary_NotEqual_ObjectObject_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F990
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_NameName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_NameName(const class FName& A, const class FName& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_NameName");
		
		UKismetMathLibrary_NotEqual_NameName_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233FB00
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_IntInt");
		
		UKismetMathLibrary_NotEqual_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233FC50
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_FloatFloat");
		
		UKismetMathLibrary_NotEqual_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233FDC0
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DoubleDouble");
		
		UKismetMathLibrary_NotEqual_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F700
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime");
		
		UKismetMathLibrary_NotEqual_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233F840
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_ClassClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_ClassClass(class UClass* A, class UClass* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ClassClass");
		
		UKismetMathLibrary_NotEqual_ClassClass_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0233FF20
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_ByteByte");
		
		UKismetMathLibrary_NotEqual_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340070
	 * 		Name   -> Function Engine.KismetMathLibrary.NotEqual_BoolBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NotEqual_BoolBool(bool A, bool B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NotEqual_BoolBool");
		
		UKismetMathLibrary_NotEqual_BoolBool_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023401D0
	 * 		Name   -> Function Engine.KismetMathLibrary.Not_PreBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Not_PreBool(bool A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_PreBool");
		
		UKismetMathLibrary_Not_PreBool_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023402A0
	 * 		Name   -> Function Engine.KismetMathLibrary.Not_Int
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Not_Int(int32_t A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Not_Int");
		
		UKismetMathLibrary_Not_Int_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340370
	 * 		Name   -> Function Engine.KismetMathLibrary.NormalizeToRange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              RangeMin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              RangeMax                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_NormalizeToRange(float Value, float RangeMin, float RangeMax)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizeToRange");
		
		UKismetMathLibrary_NormalizeToRange_Params params {};
		params.Value = Value;
		params.RangeMin = RangeMin;
		params.RangeMax = RangeMax;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023405B0
	 * 		Name   -> Function Engine.KismetMathLibrary.NormalizedDeltaRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_NormalizedDeltaRotator(const struct FRotator& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NormalizedDeltaRotator");
		
		UKismetMathLibrary_NormalizedDeltaRotator_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340730
	 * 		Name   -> Function Engine.KismetMathLibrary.Normal2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Normal2D(const struct FVector2D& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal2D");
		
		UKismetMathLibrary_Normal2D_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340800
	 * 		Name   -> Function Engine.KismetMathLibrary.Normal
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Normal(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Normal");
		
		UKismetMathLibrary_Normal_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023408E0
	 * 		Name   -> Function Engine.KismetMathLibrary.NegateVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_NegateVector(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateVector");
		
		UKismetMathLibrary_NegateVector_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023409D0
	 * 		Name   -> Function Engine.KismetMathLibrary.NegateRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_NegateRotator(const struct FRotator& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NegateRotator");
		
		UKismetMathLibrary_NegateRotator_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340B00
	 * 		Name   -> Function Engine.KismetMathLibrary.NearlyEqual_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NearlyEqual_VectorVector(const struct FVector& A, const struct FVector& B, float ErrorTolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_VectorVector");
		
		UKismetMathLibrary_NearlyEqual_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340D20
	 * 		Name   -> Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NearlyEqual_FloatFloat(float A, float B, float ErrorTolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat");
		
		UKismetMathLibrary_NearlyEqual_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02340EF0
	 * 		Name   -> Function Engine.KismetMathLibrary.NearlyEqual_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ErrorTolerance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_NearlyEqual_DoubleDouble(double A, double B, float ErrorTolerance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.NearlyEqual_DoubleDouble");
		
		UKismetMathLibrary_NearlyEqual_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		params.ErrorTolerance = ErrorTolerance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023410E0
	 * 		Name   -> Function Engine.KismetMathLibrary.MultiplyMultiply_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Base                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Exp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_MultiplyMultiply_IntInt(int32_t Base, int32_t Exp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_IntInt");
		
		UKismetMathLibrary_MultiplyMultiply_IntInt_Params params {};
		params.Base = Base;
		params.Exp = Exp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341250
	 * 		Name   -> Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Base                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Exp                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_MultiplyMultiply_FloatFloat(float Base, float Exp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat");
		
		UKismetMathLibrary_MultiplyMultiply_FloatFloat_Params params {};
		params.Base = Base;
		params.Exp = Exp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023413B0
	 * 		Name   -> Function Engine.KismetMathLibrary.MultiplyByPi
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_MultiplyByPi(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MultiplyByPi");
		
		UKismetMathLibrary_MultiplyByPi_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341480
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Multiply_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorVector");
		
		UKismetMathLibrary_Multiply_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023415F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_VectorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Multiply_VectorFloat(const struct FVector& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_VectorFloat");
		
		UKismetMathLibrary_Multiply_VectorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341760
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Multiply_Vector2DFloat(const struct FVector2D& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_Vector2DFloat");
		
		UKismetMathLibrary_Multiply_Vector2DFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023418C0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_TimespanFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		float                                              Scalar                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_Multiply_TimespanFloat(const struct FTimespan& A, float Scalar)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_TimespanFloat");
		
		UKismetMathLibrary_Multiply_TimespanFloat_Params params {};
		params.A = A;
		params.Scalar = Scalar;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023415F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_RotatorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_Multiply_RotatorFloat(const struct FRotator& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_RotatorFloat");
		
		UKismetMathLibrary_Multiply_RotatorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341A10
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorLinearColor(const struct FLinearColor& A, const struct FLinearColor& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor");
		
		UKismetMathLibrary_Multiply_LinearColorLinearColor_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341B90
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_Multiply_LinearColorFloat(const struct FLinearColor& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_LinearColorFloat");
		
		UKismetMathLibrary_Multiply_LinearColorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341CE0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Multiply_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntInt");
		
		UKismetMathLibrary_Multiply_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341E30
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_IntFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Multiply_IntFloat(int32_t A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_IntFloat");
		
		UKismetMathLibrary_Multiply_IntFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02341F90
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Multiply_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_FloatFloat");
		
		UKismetMathLibrary_Multiply_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023420E0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_DoubleFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Multiply_DoubleFloat(double A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_DoubleFloat");
		
		UKismetMathLibrary_Multiply_DoubleFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02342240
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Multiply_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_DoubleDouble");
		
		UKismetMathLibrary_Multiply_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023423A0
	 * 		Name   -> Function Engine.KismetMathLibrary.Multiply_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Multiply_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Multiply_ByteByte");
		
		UKismetMathLibrary_Multiply_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023424F0
	 * 		Name   -> Function Engine.KismetMathLibrary.MirrorVectorByNormal
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     InVect                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     InNormal                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_MirrorVectorByNormal(const struct FVector& InVect, const struct FVector& InNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MirrorVectorByNormal");
		
		UKismetMathLibrary_MirrorVectorByNormal_Params params {};
		params.InVect = InVect;
		params.InNormal = InNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02342670
	 * 		Name   -> Function Engine.KismetMathLibrary.MinOfIntArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    IntArray                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MinOfIntArray(TArray<int32_t> IntArray, int32_t* IndexOfMinValue, int32_t* MinValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfIntArray");
		
		UKismetMathLibrary_MinOfIntArray_Params params {};
		params.IntArray = IntArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02342860
	 * 		Name   -> Function Engine.KismetMathLibrary.MinOfFloatArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<float>                                      FloatArray                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MinOfFloatArray(TArray<float> FloatArray, int32_t* IndexOfMinValue, float* MinValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfFloatArray");
		
		UKismetMathLibrary_MinOfFloatArray_Params params {};
		params.FloatArray = FloatArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02342A10
	 * 		Name   -> Function Engine.KismetMathLibrary.MinOfByteArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<unsigned char>                              ByteArray                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMinValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      MinValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MinOfByteArray(TArray<unsigned char> ByteArray, int32_t* IndexOfMinValue, unsigned char* MinValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinOfByteArray");
		
		UKismetMathLibrary_MinOfByteArray_Params params {};
		params.ByteArray = ByteArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMinValue != nullptr)
			*IndexOfMinValue = params.IndexOfMinValue;
		if (MinValue != nullptr)
			*MinValue = params.MinValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02342C00
	 * 		Name   -> Function Engine.KismetMathLibrary.MinimumAreaRectangle
	 * 		Flags  -> (Final, BlueprintAuthorityOnly, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FVector>                             InVerts                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		struct FVector                                     SampleSurfaceNormal                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     OutRectCenter                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    OutRectRotation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutSideLengthX                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutSideLengthY                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDebugDraw                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MinimumAreaRectangle(class UObject* WorldContextObject, TArray<struct FVector> InVerts, const struct FVector& SampleSurfaceNormal, struct FVector* OutRectCenter, struct FRotator* OutRectRotation, float* OutSideLengthX, float* OutSideLengthY, bool bDebugDraw)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MinimumAreaRectangle");
		
		UKismetMathLibrary_MinimumAreaRectangle_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InVerts = InVerts;
		params.SampleSurfaceNormal = SampleSurfaceNormal;
		params.bDebugDraw = bDebugDraw;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutRectCenter != nullptr)
			*OutRectCenter = params.OutRectCenter;
		if (OutRectRotation != nullptr)
			*OutRectRotation = params.OutRectRotation;
		if (OutSideLengthX != nullptr)
			*OutSideLengthX = params.OutSideLengthX;
		if (OutSideLengthY != nullptr)
			*OutSideLengthY = params.OutSideLengthY;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343030
	 * 		Name   -> Function Engine.KismetMathLibrary.Min
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Min(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Min");
		
		UKismetMathLibrary_Min_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343180
	 * 		Name   -> Function Engine.KismetMathLibrary.MaxOfIntArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<int32_t>                                    IntArray                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MaxOfIntArray(TArray<int32_t> IntArray, int32_t* IndexOfMaxValue, int32_t* MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfIntArray");
		
		UKismetMathLibrary_MaxOfIntArray_Params params {};
		params.IntArray = IntArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343370
	 * 		Name   -> Function Engine.KismetMathLibrary.MaxOfFloatArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<float>                                      FloatArray                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MaxOfFloatArray(TArray<float> FloatArray, int32_t* IndexOfMaxValue, float* MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfFloatArray");
		
		UKismetMathLibrary_MaxOfFloatArray_Params params {};
		params.FloatArray = FloatArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343520
	 * 		Name   -> Function Engine.KismetMathLibrary.MaxOfByteArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<unsigned char>                              ByteArray                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		int32_t                                            IndexOfMaxValue                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      MaxValue                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_MaxOfByteArray(TArray<unsigned char> ByteArray, int32_t* IndexOfMaxValue, unsigned char* MaxValue)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MaxOfByteArray");
		
		UKismetMathLibrary_MaxOfByteArray_Params params {};
		params.ByteArray = ByteArray;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (IndexOfMaxValue != nullptr)
			*IndexOfMaxValue = params.IndexOfMaxValue;
		if (MaxValue != nullptr)
			*MaxValue = params.MaxValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343710
	 * 		Name   -> Function Engine.KismetMathLibrary.Max
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Max(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Max");
		
		UKismetMathLibrary_Max_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343860
	 * 		Name   -> Function Engine.KismetMathLibrary.MapRange
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InRangeA                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InRangeB                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutRangeA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OutRangeB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_MapRange(float Value, float InRangeA, float InRangeB, float OutRangeA, float OutRangeB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MapRange");
		
		UKismetMathLibrary_MapRange_Params params {};
		params.Value = Value;
		params.InRangeA = InRangeA;
		params.InRangeB = InRangeB;
		params.OutRangeA = OutRangeA;
		params.OutRangeB = OutRangeB;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343B70
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeVector2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_MakeVector2D(float X, float Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector2D");
		
		UKismetMathLibrary_MakeVector2D_Params params {};
		params.X = X;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343CD0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_MakeVector(float X, float Y, float Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeVector");
		
		UKismetMathLibrary_MakeVector_Params params {};
		params.X = X;
		params.Y = Y;
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343EB0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_MakeTransform(const struct FVector& Location, const struct FRotator& Rotation, const struct FVector& Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeTransform");
		
		UKismetMathLibrary_MakeTransform_Params params {};
		params.Location = Location;
		params.Rotation = Rotation;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023440E0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZY
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZY(const struct FVector& Z, const struct FVector& Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZY");
		
		UKismetMathLibrary_MakeRotFromZY_Params params {};
		params.Z = Z;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344240
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZX
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZX(const struct FVector& Z, const struct FVector& X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZX");
		
		UKismetMathLibrary_MakeRotFromZX_Params params {};
		params.Z = Z;
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023443A0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromZ
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromZ(const struct FVector& Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromZ");
		
		UKismetMathLibrary_MakeRotFromZ_Params params {};
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344480
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromYZ
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYZ(const struct FVector& Y, const struct FVector& Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYZ");
		
		UKismetMathLibrary_MakeRotFromYZ_Params params {};
		params.Y = Y;
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023445E0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromYX
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromYX(const struct FVector& Y, const struct FVector& X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromYX");
		
		UKismetMathLibrary_MakeRotFromYX_Params params {};
		params.Y = Y;
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344740
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromY
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromY(const struct FVector& Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromY");
		
		UKismetMathLibrary_MakeRotFromY_Params params {};
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344820
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromXZ
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Z                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXZ(const struct FVector& X, const struct FVector& Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXZ");
		
		UKismetMathLibrary_MakeRotFromXZ_Params params {};
		params.X = X;
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344980
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromXY
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Y                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromXY(const struct FVector& X, const struct FVector& Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromXY");
		
		UKismetMathLibrary_MakeRotFromXY_Params params {};
		params.X = X;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344AE0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotFromX
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     X                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotFromX(const struct FVector& X)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotFromX");
		
		UKismetMathLibrary_MakeRotFromX_Params params {};
		params.X = X;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344BC0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRotationFromAxes
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Forward                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Right                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Up                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRotationFromAxes(const struct FVector& Forward, const struct FVector& Right, const struct FVector& Up)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRotationFromAxes");
		
		UKismetMathLibrary_MakeRotationFromAxes_Params params {};
		params.Forward = Forward;
		params.Right = Right;
		params.Up = Up;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02343CD0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeRot
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Pitch                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Yaw                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Roll                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_MakeRot(float Pitch, float Yaw, float Roll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeRot");
		
		UKismetMathLibrary_MakeRot_Params params {};
		params.Pitch = Pitch;
		params.Yaw = Yaw;
		params.Roll = Roll;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02344DD0
	 * 		Name   -> Function Engine.KismetMathLibrary.MakeColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              R                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              G                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_MakeColor(float R, float G, float B, float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.MakeColor");
		
		UKismetMathLibrary_MakeColor_Params params {};
		params.R = R;
		params.G = G;
		params.B = B;
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345040
	 * 		Name   -> Function Engine.KismetMathLibrary.Loge
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Loge(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Loge");
		
		UKismetMathLibrary_Loge_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345110
	 * 		Name   -> Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneOrigin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     PlaneNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              T                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Intersection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LinePlaneIntersection_OriginNormal(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FVector& PlaneOrigin, const struct FVector& PlaneNormal, float* T, struct FVector* Intersection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal");
		
		UKismetMathLibrary_LinePlaneIntersection_OriginNormal_Params params {};
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.PlaneOrigin = PlaneOrigin;
		params.PlaneNormal = PlaneNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (T != nullptr)
			*T = params.T;
		if (Intersection != nullptr)
			*Intersection = params.Intersection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345480
	 * 		Name   -> Function Engine.KismetMathLibrary.LinePlaneIntersection
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FPlane                                      APlane                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		float                                              T                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Intersection                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LinePlaneIntersection(const struct FVector& LineStart, const struct FVector& LineEnd, const struct FPlane& APlane, float* T, struct FVector* Intersection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinePlaneIntersection");
		
		UKismetMathLibrary_LinePlaneIntersection_Params params {};
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.APlane = APlane;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (T != nullptr)
			*T = params.T;
		if (Intersection != nullptr)
			*Intersection = params.Intersection;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345720
	 * 		Name   -> Function Engine.KismetMathLibrary.LinearColorLerp
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_LinearColorLerp(const struct FLinearColor& A, const struct FLinearColor& B, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LinearColorLerp");
		
		UKismetMathLibrary_LinearColorLerp_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023459A0
	 * 		Name   -> Function Engine.KismetMathLibrary.LessLess_VectorRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_LessLess_VectorRotator(const struct FVector& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessLess_VectorRotator");
		
		UKismetMathLibrary_LessLess_VectorRotator_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345B20
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan");
		
		UKismetMathLibrary_LessEqual_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345C60
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_IntInt");
		
		UKismetMathLibrary_LessEqual_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345DB0
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_FloatFloat");
		
		UKismetMathLibrary_LessEqual_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345F00
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DoubleDouble");
		
		UKismetMathLibrary_LessEqual_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02345B20
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime");
		
		UKismetMathLibrary_LessEqual_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346060
	 * 		Name   -> Function Engine.KismetMathLibrary.LessEqual_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_LessEqual_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LessEqual_ByteByte");
		
		UKismetMathLibrary_LessEqual_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023461B0
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_TimespanTimespan");
		
		UKismetMathLibrary_Less_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023462F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_IntInt");
		
		UKismetMathLibrary_Less_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346440
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_FloatFloat");
		
		UKismetMathLibrary_Less_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346590
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DoubleDouble");
		
		UKismetMathLibrary_Less_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023461B0
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_DateTimeDateTime");
		
		UKismetMathLibrary_Less_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023466F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Less_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Less_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Less_ByteByte");
		
		UKismetMathLibrary_Less_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346840
	 * 		Name   -> Function Engine.KismetMathLibrary.LerpAngle
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              startDegrees                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              endDegrees                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_LerpAngle(float startDegrees, float endDegrees, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.LerpAngle");
		
		UKismetMathLibrary_LerpAngle_Params params {};
		params.startDegrees = startDegrees;
		params.endDegrees = endDegrees;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346A10
	 * 		Name   -> Function Engine.KismetMathLibrary.Lerp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Lerp(float A, float B, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Lerp");
		
		UKismetMathLibrary_Lerp_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346BE0
	 * 		Name   -> Function Engine.KismetMathLibrary.IsRotatorInfiniteOrNaN
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_IsRotatorInfiniteOrNaN(const struct FRotator& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsRotatorInfiniteOrNaN");
		
		UKismetMathLibrary_IsRotatorInfiniteOrNaN_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346D20
	 * 		Name   -> Function Engine.KismetMathLibrary.IsPointInBox
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Point                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxOrigin                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_IsPointInBox(const struct FVector& Point, const struct FVector& BoxOrigin, const struct FVector& BoxExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsPointInBox");
		
		UKismetMathLibrary_IsPointInBox_Params params {};
		params.Point = Point;
		params.BoxOrigin = BoxOrigin;
		params.BoxExtent = BoxExtent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346F70
	 * 		Name   -> Function Engine.KismetMathLibrary.IsMorning
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_IsMorning(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsMorning");
		
		UKismetMathLibrary_IsMorning_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347070
	 * 		Name   -> Function Engine.KismetMathLibrary.IsLeapYear
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_IsLeapYear(int32_t Year)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsLeapYear");
		
		UKismetMathLibrary_IsLeapYear_Params params {};
		params.Year = Year;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02346BE0
	 * 		Name   -> Function Engine.KismetMathLibrary.IsInfiniteOrNaN
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_IsInfiniteOrNaN(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsInfiniteOrNaN");
		
		UKismetMathLibrary_IsInfiniteOrNaN_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023471A0
	 * 		Name   -> Function Engine.KismetMathLibrary.IsAfternoon
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_IsAfternoon(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.IsAfternoon");
		
		UKismetMathLibrary_IsAfternoon_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023472A0
	 * 		Name   -> Function Engine.KismetMathLibrary.InverseTransformLocation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_InverseTransformLocation(const struct FTransform& T, const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformLocation");
		
		UKismetMathLibrary_InverseTransformLocation_Params params {};
		params.T = T;
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347410
	 * 		Name   -> Function Engine.KismetMathLibrary.InverseTransformDirection
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  T                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_InverseTransformDirection(const struct FTransform& T, const struct FVector& Direction)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InverseTransformDirection");
		
		UKismetMathLibrary_InverseTransformDirection_Params params {};
		params.T = T;
		params.Direction = Direction;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347670
	 * 		Name   -> Function Engine.KismetMathLibrary.InRange_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               InclusiveMin                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               InclusiveMax                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_InRange_FloatFloat(float Value, float Min, float Max, bool InclusiveMin, bool InclusiveMax)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.InRange_FloatFloat");
		
		UKismetMathLibrary_InRange_FloatFloat_Params params {};
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;
		params.InclusiveMin = InclusiveMin;
		params.InclusiveMax = InclusiveMax;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347990
	 * 		Name   -> Function Engine.KismetMathLibrary.HSVToRGB_Vector
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                HSV                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RGB                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_HSVToRGB_Vector(const struct FLinearColor& HSV, struct FLinearColor* RGB)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB_Vector");
		
		UKismetMathLibrary_HSVToRGB_Vector_Params params {};
		params.HSV = HSV;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (RGB != nullptr)
			*RGB = params.RGB;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347AE0
	 * 		Name   -> Function Engine.KismetMathLibrary.HSVToRGB
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              H                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              S                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_HSVToRGB(float H, float S, float V, float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.HSVToRGB");
		
		UKismetMathLibrary_HSVToRGB_Params params {};
		params.H = H;
		params.S = S;
		params.V = V;
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347D60
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_GreaterGreater_VectorRotator(const struct FVector& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator");
		
		UKismetMathLibrary_GreaterGreater_VectorRotator_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347F60
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan");
		
		UKismetMathLibrary_GreaterEqual_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023480A0
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_IntInt");
		
		UKismetMathLibrary_GreaterEqual_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023481F0
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat");
		
		UKismetMathLibrary_GreaterEqual_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348340
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DoubleDouble");
		
		UKismetMathLibrary_GreaterEqual_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02347F60
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime");
		
		UKismetMathLibrary_GreaterEqual_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023484A0
	 * 		Name   -> Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_GreaterEqual_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GreaterEqual_ByteByte");
		
		UKismetMathLibrary_GreaterEqual_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023485F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_TimespanTimespan");
		
		UKismetMathLibrary_Greater_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348730
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_IntInt");
		
		UKismetMathLibrary_Greater_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348880
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_FloatFloat");
		
		UKismetMathLibrary_Greater_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023489D0
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DoubleDouble");
		
		UKismetMathLibrary_Greater_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023485F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_DateTimeDateTime");
		
		UKismetMathLibrary_Greater_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348B30
	 * 		Name   -> Function Engine.KismetMathLibrary.Greater_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Greater_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Greater_ByteByte");
		
		UKismetMathLibrary_Greater_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348C80
	 * 		Name   -> Function Engine.KismetMathLibrary.GetYear
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetYear(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetYear");
		
		UKismetMathLibrary_GetYear_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348D50
	 * 		Name   -> Function Engine.KismetMathLibrary.GetVectorArrayAverage
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<struct FVector>                             Vectors                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	struct FVector UKismetMathLibrary::STATIC_GetVectorArrayAverage(TArray<struct FVector> Vectors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetVectorArrayAverage");
		
		UKismetMathLibrary_GetVectorArrayAverage_Params params {};
		params.Vectors = Vectors;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348E20
	 * 		Name   -> Function Engine.KismetMathLibrary.GetUpVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_GetUpVector(const struct FRotator& InRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetUpVector");
		
		UKismetMathLibrary_GetUpVector_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348F20
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTotalSeconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_GetTotalSeconds(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalSeconds");
		
		UKismetMathLibrary_GetTotalSeconds_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02348FF0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTotalMinutes
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_GetTotalMinutes(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMinutes");
		
		UKismetMathLibrary_GetTotalMinutes_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023490C0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTotalMilliseconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_GetTotalMilliseconds(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalMilliseconds");
		
		UKismetMathLibrary_GetTotalMilliseconds_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349190
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTotalHours
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_GetTotalHours(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalHours");
		
		UKismetMathLibrary_GetTotalHours_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349260
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTotalDays
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	float UKismetMathLibrary::STATIC_GetTotalDays(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTotalDays");
		
		UKismetMathLibrary_GetTotalDays_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349330
	 * 		Name   -> Function Engine.KismetMathLibrary.GetTimeOfDay
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_GetTimeOfDay(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetTimeOfDay");
		
		UKismetMathLibrary_GetTimeOfDay_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349400
	 * 		Name   -> Function Engine.KismetMathLibrary.GetSeconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetSeconds(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSeconds");
		
		UKismetMathLibrary_GetSeconds_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349400
	 * 		Name   -> Function Engine.KismetMathLibrary.GetSecond
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetSecond(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetSecond");
		
		UKismetMathLibrary_GetSecond_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349500
	 * 		Name   -> Function Engine.KismetMathLibrary.GetRightVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_GetRightVector(const struct FRotator& InRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetRightVector");
		
		UKismetMathLibrary_GetRightVector_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349600
	 * 		Name   -> Function Engine.KismetMathLibrary.GetPI
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	float UKismetMathLibrary::STATIC_GetPI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetPI");
		
		UKismetMathLibrary_GetPI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349620
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMonth
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetMonth(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMonth");
		
		UKismetMathLibrary_GetMonth_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023496F0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMinutes
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetMinutes(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinutes");
		
		UKismetMathLibrary_GetMinutes_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023496F0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMinute
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetMinute(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinute");
		
		UKismetMathLibrary_GetMinute_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023497F0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMinElement
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_GetMinElement(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMinElement");
		
		UKismetMathLibrary_GetMinElement_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023498C0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMilliseconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetMilliseconds(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMilliseconds");
		
		UKismetMathLibrary_GetMilliseconds_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023498C0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMillisecond
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetMillisecond(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMillisecond");
		
		UKismetMathLibrary_GetMillisecond_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023499C0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetMaxElement
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_GetMaxElement(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetMaxElement");
		
		UKismetMathLibrary_GetMaxElement_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349A90
	 * 		Name   -> Function Engine.KismetMathLibrary.GetHours
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetHours(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHours");
		
		UKismetMathLibrary_GetHours_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349B80
	 * 		Name   -> Function Engine.KismetMathLibrary.GetHour12
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetHour12(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour12");
		
		UKismetMathLibrary_GetHour12_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349A90
	 * 		Name   -> Function Engine.KismetMathLibrary.GetHour
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetHour(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetHour");
		
		UKismetMathLibrary_GetHour_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349CA0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetForwardVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_GetForwardVector(const struct FRotator& InRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetForwardVector");
		
		UKismetMathLibrary_GetForwardVector_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349DA0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDuration
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_GetDuration(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDuration");
		
		UKismetMathLibrary_GetDuration_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349E60
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDirectionVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     From                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     To                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_GetDirectionVector(const struct FVector& From, const struct FVector& To)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDirectionVector");
		
		UKismetMathLibrary_GetDirectionVector_Params params {};
		params.From = From;
		params.To = To;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02349FE0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDays
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetDays(const struct FTimespan& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDays");
		
		UKismetMathLibrary_GetDays_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A0B0
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDayOfYear
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetDayOfYear(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDayOfYear");
		
		UKismetMathLibrary_GetDayOfYear_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A180
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDay
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetMathLibrary::STATIC_GetDay(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDay");
		
		UKismetMathLibrary_GetDay_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A250
	 * 		Name   -> Function Engine.KismetMathLibrary.GetDate
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_GetDate(const struct FDateTime& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetDate");
		
		UKismetMathLibrary_GetDate_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A320
	 * 		Name   -> Function Engine.KismetMathLibrary.GetAxes
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_GetAxes(const struct FRotator& A, struct FVector* X, struct FVector* Y, struct FVector* Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.GetAxes");
		
		UKismetMathLibrary_GetAxes_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A5D0
	 * 		Name   -> Function Engine.KismetMathLibrary.FromSeconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Seconds                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_FromSeconds(float Seconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromSeconds");
		
		UKismetMathLibrary_FromSeconds_Params params {};
		params.Seconds = Seconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A6B0
	 * 		Name   -> Function Engine.KismetMathLibrary.FromMinutes
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Minutes                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_FromMinutes(float Minutes)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMinutes");
		
		UKismetMathLibrary_FromMinutes_Params params {};
		params.Minutes = Minutes;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A790
	 * 		Name   -> Function Engine.KismetMathLibrary.FromMilliseconds
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Milliseconds                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_FromMilliseconds(float Milliseconds)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromMilliseconds");
		
		UKismetMathLibrary_FromMilliseconds_Params params {};
		params.Milliseconds = Milliseconds;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A870
	 * 		Name   -> Function Engine.KismetMathLibrary.FromHours
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Hours                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_FromHours(float Hours)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromHours");
		
		UKismetMathLibrary_FromHours_Params params {};
		params.Hours = Hours;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234A950
	 * 		Name   -> Function Engine.KismetMathLibrary.FromDays
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Days                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_FromDays(float Days)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FromDays");
		
		UKismetMathLibrary_FromDays_Params params {};
		params.Days = Days;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234AA30
	 * 		Name   -> Function Engine.KismetMathLibrary.Fraction
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Fraction(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Fraction");
		
		UKismetMathLibrary_Fraction_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234AB10
	 * 		Name   -> Function Engine.KismetMathLibrary.FMod
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Dividend                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Divisor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Remainder                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_FMod(float Dividend, float Divisor, float* Remainder)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMod");
		
		UKismetMathLibrary_FMod_Params params {};
		params.Dividend = Dividend;
		params.Divisor = Divisor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Remainder != nullptr)
			*Remainder = params.Remainder;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234ACE0
	 * 		Name   -> Function Engine.KismetMathLibrary.FMin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FMin(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMin");
		
		UKismetMathLibrary_FMin_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234AE30
	 * 		Name   -> Function Engine.KismetMathLibrary.FMax
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FMax(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FMax");
		
		UKismetMathLibrary_FMax_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234AF80
	 * 		Name   -> Function Engine.KismetMathLibrary.FlattenVectorNormal
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_FlattenVectorNormal(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FlattenVectorNormal");
		
		UKismetMathLibrary_FlattenVectorNormal_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234B060
	 * 		Name   -> Function Engine.KismetMathLibrary.FlattenVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_FlattenVector(const struct FVector& A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FlattenVector");
		
		UKismetMathLibrary_FlattenVector_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234B130
	 * 		Name   -> Function Engine.KismetMathLibrary.FInterpTo_Constant
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FInterpTo_Constant(float current, float Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo_Constant");
		
		UKismetMathLibrary_FInterpTo_Constant_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234B3C0
	 * 		Name   -> Function Engine.KismetMathLibrary.FInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FInterpTo(float current, float Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpTo");
		
		UKismetMathLibrary_FInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234B680
	 * 		Name   -> Function Engine.KismetMathLibrary.FInterpEaseInOut
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Exponent                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FInterpEaseInOut(float A, float B, float Alpha, float Exponent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FInterpEaseInOut");
		
		UKismetMathLibrary_FInterpEaseInOut_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.Exponent = Exponent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234B8D0
	 * 		Name   -> Function Engine.KismetMathLibrary.FindLookAtRotation
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Target                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_FindLookAtRotation(const struct FVector& Start, const struct FVector& Target)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FindLookAtRotation");
		
		UKismetMathLibrary_FindLookAtRotation_Params params {};
		params.Start = Start;
		params.Target = Target;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234BA60
	 * 		Name   -> Function Engine.KismetMathLibrary.FFloor
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_FFloor(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FFloor");
		
		UKismetMathLibrary_FFloor_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234BB40
	 * 		Name   -> Function Engine.KismetMathLibrary.FClamp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FClamp(float Value, float Min, float Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FClamp");
		
		UKismetMathLibrary_FClamp_Params params {};
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234BD20
	 * 		Name   -> Function Engine.KismetMathLibrary.FCeil
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_FCeil(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FCeil");
		
		UKismetMathLibrary_FCeil_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234BE00
	 * 		Name   -> Function Engine.KismetMathLibrary.FAngleInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              CurrentDegrees                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              TargetDegrees                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FAngleInterpTo(float CurrentDegrees, float TargetDegrees, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FAngleInterpTo");
		
		UKismetMathLibrary_FAngleInterpTo_Params params {};
		params.CurrentDegrees = CurrentDegrees;
		params.TargetDegrees = TargetDegrees;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C050
	 * 		Name   -> Function Engine.KismetMathLibrary.FAngleInterpEaseOut
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              startAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              endAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FAngleInterpEaseOut(float startAngle, float endAngle, float Alpha, float BlendExp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FAngleInterpEaseOut");
		
		UKismetMathLibrary_FAngleInterpEaseOut_Params params {};
		params.startAngle = startAngle;
		params.endAngle = endAngle;
		params.Alpha = Alpha;
		params.BlendExp = BlendExp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C2D0
	 * 		Name   -> Function Engine.KismetMathLibrary.FAngleInterpEaseInOut
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              startAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              endAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FAngleInterpEaseInOut(float startAngle, float endAngle, float Alpha, float BlendExp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FAngleInterpEaseInOut");
		
		UKismetMathLibrary_FAngleInterpEaseInOut_Params params {};
		params.startAngle = startAngle;
		params.endAngle = endAngle;
		params.Alpha = Alpha;
		params.BlendExp = BlendExp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C520
	 * 		Name   -> Function Engine.KismetMathLibrary.FAngleInterpEaseIn
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              startAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              endAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_FAngleInterpEaseIn(float startAngle, float endAngle, float Alpha, float BlendExp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.FAngleInterpEaseIn");
		
		UKismetMathLibrary_FAngleInterpEaseIn_Params params {};
		params.startAngle = startAngle;
		params.endAngle = endAngle;
		params.Alpha = Alpha;
		params.BlendExp = BlendExp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C780
	 * 		Name   -> Function Engine.KismetMathLibrary.Exp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Exp(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Exp");
		
		UKismetMathLibrary_Exp_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C850
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_VectorVector");
		
		UKismetMathLibrary_EqualEqual_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C9C0
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan");
		
		UKismetMathLibrary_EqualEqual_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C850
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_RotatorRotator(const struct FRotator& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator");
		
		UKismetMathLibrary_EqualEqual_RotatorRotator_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234CB00
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_ObjectObject(class UObject* A, class UObject* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ObjectObject");
		
		UKismetMathLibrary_EqualEqual_ObjectObject_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234CC50
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_NameName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_NameName(const class FName& A, const class FName& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_NameName");
		
		UKismetMathLibrary_EqualEqual_NameName_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234CDD0
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_IntInt");
		
		UKismetMathLibrary_EqualEqual_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234CF20
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_FloatFloat");
		
		UKismetMathLibrary_EqualEqual_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234D090
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DoubleDouble");
		
		UKismetMathLibrary_EqualEqual_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234C9C0
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FDateTime                                   B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_DateTimeDateTime(const struct FDateTime& A, const struct FDateTime& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime");
		
		UKismetMathLibrary_EqualEqual_DateTimeDateTime_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234CB00
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ClassClass
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_ClassClass(class UClass* A, class UClass* B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ClassClass");
		
		UKismetMathLibrary_EqualEqual_ClassClass_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234D1F0
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_ByteByte");
		
		UKismetMathLibrary_EqualEqual_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234D340
	 * 		Name   -> Function Engine.KismetMathLibrary.EqualEqual_BoolBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_EqualEqual_BoolBool(bool A, bool B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EqualEqual_BoolBool");
		
		UKismetMathLibrary_EqualEqual_BoolBool_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234D4A0
	 * 		Name   -> Function Engine.KismetMathLibrary.EaseAngle
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              startAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              endAngle                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEasingFunc                                        EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_EaseAngle(float startAngle, float endAngle, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32_t Steps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.EaseAngle");
		
		UKismetMathLibrary_EaseAngle_Params params {};
		params.startAngle = startAngle;
		params.endAngle = endAngle;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234D810
	 * 		Name   -> Function Engine.KismetMathLibrary.Ease
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EEasingFunc                                        EasingFunc                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              BlendExp                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Steps                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Ease(float A, float B, float Alpha, EEasingFunc EasingFunc, float BlendExp, int32_t Steps)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Ease");
		
		UKismetMathLibrary_Ease_Params params {};
		params.A = A;
		params.B = B;
		params.Alpha = Alpha;
		params.EasingFunc = EasingFunc;
		params.BlendExp = BlendExp;
		params.Steps = Steps;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234DB80
	 * 		Name   -> Function Engine.KismetMathLibrary.Dot_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Dot_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Dot_VectorVector");
		
		UKismetMathLibrary_Dot_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234DCE0
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Divide_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorVector");
		
		UKismetMathLibrary_Divide_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234DEA0
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_VectorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Divide_VectorFloat(const struct FVector& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_VectorFloat");
		
		UKismetMathLibrary_Divide_VectorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E070
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_Vector2DFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Divide_Vector2DFloat(const struct FVector2D& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_Vector2DFloat");
		
		UKismetMathLibrary_Divide_Vector2DFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E210
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Divide_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_IntInt");
		
		UKismetMathLibrary_Divide_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E380
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Divide_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_FloatFloat");
		
		UKismetMathLibrary_Divide_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E4F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_DoubleFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Divide_DoubleFloat(double A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_DoubleFloat");
		
		UKismetMathLibrary_Divide_DoubleFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E670
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Divide_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_DoubleDouble");
		
		UKismetMathLibrary_Divide_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E7E0
	 * 		Name   -> Function Engine.KismetMathLibrary.Divide_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Divide_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Divide_ByteByte");
		
		UKismetMathLibrary_Divide_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234E950
	 * 		Name   -> Function Engine.KismetMathLibrary.DegTan
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegTan(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegTan");
		
		UKismetMathLibrary_DegTan_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234EA30
	 * 		Name   -> Function Engine.KismetMathLibrary.DegSin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegSin(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegSin");
		
		UKismetMathLibrary_DegSin_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234EB10
	 * 		Name   -> Function Engine.KismetMathLibrary.DegreesToRadians
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegreesToRadians(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegreesToRadians");
		
		UKismetMathLibrary_DegreesToRadians_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234EBE0
	 * 		Name   -> Function Engine.KismetMathLibrary.DegCos
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegCos(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegCos");
		
		UKismetMathLibrary_DegCos_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234ECC0
	 * 		Name   -> Function Engine.KismetMathLibrary.DegAtan2
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegAtan2(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAtan2");
		
		UKismetMathLibrary_DegAtan2_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234EE20
	 * 		Name   -> Function Engine.KismetMathLibrary.DegAsin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegAsin(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAsin");
		
		UKismetMathLibrary_DegAsin_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234EF10
	 * 		Name   -> Function Engine.KismetMathLibrary.DegAcos
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_DegAcos(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DegAcos");
		
		UKismetMathLibrary_DegAcos_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F000
	 * 		Name   -> Function Engine.KismetMathLibrary.DaysInYear
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_DaysInYear(int32_t Year)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInYear");
		
		UKismetMathLibrary_DaysInYear_Params params {};
		params.Year = Year;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F130
	 * 		Name   -> Function Engine.KismetMathLibrary.DaysInMonth
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Year                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Month                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_DaysInMonth(int32_t Year, int32_t Month)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DaysInMonth");
		
		UKismetMathLibrary_DaysInMonth_Params params {};
		params.Year = Year;
		params.Month = Month;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E9EED0
	 * 		Name   -> Function Engine.KismetMathLibrary.DateTimeMinValue
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_DateTimeMinValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMinValue");
		
		UKismetMathLibrary_DateTimeMinValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F2B0
	 * 		Name   -> Function Engine.KismetMathLibrary.DateTimeMaxValue
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_DateTimeMaxValue()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.DateTimeMaxValue");
		
		UKismetMathLibrary_DateTimeMaxValue_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F2E0
	 * 		Name   -> Function Engine.KismetMathLibrary.Cross_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Cross_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cross_VectorVector");
		
		UKismetMathLibrary_Cross_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F490
	 * 		Name   -> Function Engine.KismetMathLibrary.Cos
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Cos(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Cos");
		
		UKismetMathLibrary_Cos_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F560
	 * 		Name   -> Function Engine.KismetMathLibrary.ConvertTransformToRelative
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  WorldTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  LocalTransform                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_ConvertTransformToRelative(const struct FTransform& WorldTransform, const struct FTransform& LocalTransform)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ConvertTransformToRelative");
		
		UKismetMathLibrary_ConvertTransformToRelative_Params params {};
		params.WorldTransform = WorldTransform;
		params.LocalTransform = LocalTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F6C0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToVector2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Conv_VectorToVector2D(const struct FVector& InVector)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToVector2D");
		
		UKismetMathLibrary_Conv_VectorToVector2D_Params params {};
		params.InVector = InVector;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F780
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     InLocation                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_Conv_VectorToTransform(const struct FVector& InLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToTransform");
		
		UKismetMathLibrary_Conv_VectorToTransform_Params params {};
		params.InLocation = InLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F880
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToRotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_Conv_VectorToRotator(const struct FVector& inVec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToRotator");
		
		UKismetMathLibrary_Conv_VectorToRotator_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234F9D0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_Conv_VectorToLinearColor(const struct FVector& inVec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_VectorToLinearColor");
		
		UKismetMathLibrary_Conv_VectorToLinearColor_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FAC0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_Vector2DToVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   InVector2D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Z                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Conv_Vector2DToVector(const struct FVector2D& InVector2D, float Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_Vector2DToVector");
		
		UKismetMathLibrary_Conv_Vector2DToVector_Params params {};
		params.InVector2D = InVector2D;
		params.Z = Z;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FC20
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_RotatorToVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Conv_RotatorToVector(const struct FRotator& InRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_RotatorToVector");
		
		UKismetMathLibrary_Conv_RotatorToVector_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FD00
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_LinearColorToVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                InLinearColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Conv_LinearColorToVector(const struct FLinearColor& InLinearColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToVector");
		
		UKismetMathLibrary_Conv_LinearColorToVector_Params params {};
		params.InLinearColor = InLinearColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FDE0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_LinearColorToColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                InLinearColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FColor UKismetMathLibrary::STATIC_Conv_LinearColorToColor(const struct FLinearColor& InLinearColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_LinearColorToColor");
		
		UKismetMathLibrary_Conv_LinearColorToColor_Params params {};
		params.InLinearColor = InLinearColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FEB0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_IntToFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Conv_IntToFloat(int32_t InInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToFloat");
		
		UKismetMathLibrary_Conv_IntToFloat_Params params {};
		params.InInt = InInt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00EB88F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_IntToByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Conv_IntToByte(int32_t InInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToByte");
		
		UKismetMathLibrary_Conv_IntToByte_Params params {};
		params.InInt = InInt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FF80
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_IntToBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_Conv_IntToBool(int32_t InInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_IntToBool");
		
		UKismetMathLibrary_Conv_IntToBool_Params params {};
		params.InInt = InInt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350050
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_FloatToVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Conv_FloatToVector(float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToVector");
		
		UKismetMathLibrary_Conv_FloatToVector_Params params {};
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350130
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_Conv_FloatToLinearColor(float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToLinearColor");
		
		UKismetMathLibrary_Conv_FloatToLinearColor_Params params {};
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E5D410
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_FloatToDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Conv_FloatToDouble(float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_FloatToDouble");
		
		UKismetMathLibrary_Conv_FloatToDouble_Params params {};
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350220
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_DoubleToFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             InDouble                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Conv_DoubleToFloat(double InDouble)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_DoubleToFloat");
		
		UKismetMathLibrary_Conv_DoubleToFloat_Params params {};
		params.InDouble = InDouble;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023502F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FColor                                      InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_Conv_ColorToLinearColor(const struct FColor& InColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ColorToLinearColor");
		
		UKismetMathLibrary_Conv_ColorToLinearColor_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350420
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_ByteToInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Conv_ByteToInt(unsigned char InByte)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToInt");
		
		UKismetMathLibrary_Conv_ByteToInt_Params params {};
		params.InByte = InByte;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023504E0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_ByteToFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Conv_ByteToFloat(unsigned char InByte)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_ByteToFloat");
		
		UKismetMathLibrary_Conv_ByteToFloat_Params params {};
		params.InByte = InByte;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023505A0
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Conv_BoolToInt(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToInt");
		
		UKismetMathLibrary_Conv_BoolToInt_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350670
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Conv_BoolToFloat(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToFloat");
		
		UKismetMathLibrary_Conv_BoolToFloat_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FF80
	 * 		Name   -> Function Engine.KismetMathLibrary.Conv_BoolToByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Conv_BoolToByte(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Conv_BoolToByte");
		
		UKismetMathLibrary_Conv_BoolToByte_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350750
	 * 		Name   -> Function Engine.KismetMathLibrary.ComposeTransforms
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  A                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  B                                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	struct FTransform UKismetMathLibrary::STATIC_ComposeTransforms(const struct FTransform& A, const struct FTransform& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeTransforms");
		
		UKismetMathLibrary_ComposeTransforms_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023508B0
	 * 		Name   -> Function Engine.KismetMathLibrary.ComposeRotators
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FRotator UKismetMathLibrary::STATIC_ComposeRotators(const struct FRotator& A, const struct FRotator& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ComposeRotators");
		
		UKismetMathLibrary_ComposeRotators_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350AC0
	 * 		Name   -> Function Engine.KismetMathLibrary.ClassIsChildOf
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      TestClass                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ParentClass                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_ClassIsChildOf(class UClass* TestClass, class UClass* ParentClass)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClassIsChildOf");
		
		UKismetMathLibrary_ClassIsChildOf_Params params {};
		params.TestClass = TestClass;
		params.ParentClass = ParentClass;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350C10
	 * 		Name   -> Function Engine.KismetMathLibrary.ClampVectorSize
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_ClampVectorSize(const struct FVector& A, float Min, float Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampVectorSize");
		
		UKismetMathLibrary_ClampVectorSize_Params params {};
		params.A = A;
		params.Min = Min;
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02350EC0
	 * 		Name   -> Function Engine.KismetMathLibrary.ClampAngle
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              AngleDegrees                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MinAngleDegrees                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              MaxAngleDegrees                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_ClampAngle(float AngleDegrees, float MinAngleDegrees, float MaxAngleDegrees)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.ClampAngle");
		
		UKismetMathLibrary_ClampAngle_Params params {};
		params.AngleDegrees = AngleDegrees;
		params.MinAngleDegrees = MinAngleDegrees;
		params.MaxAngleDegrees = MaxAngleDegrees;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351090
	 * 		Name   -> Function Engine.KismetMathLibrary.Clamp
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Min                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Max                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Clamp(int32_t Value, int32_t Min, int32_t Max)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Clamp");
		
		UKismetMathLibrary_Clamp_Params params {};
		params.Value = Value;
		params.Min = Min;
		params.Max = Max;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351280
	 * 		Name   -> Function Engine.KismetMathLibrary.CInterpTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                current                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                Target                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              DeltaTime                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              InterpSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetMathLibrary::STATIC_CInterpTo(const struct FLinearColor& current, const struct FLinearColor& Target, float DeltaTime, float InterpSpeed)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.CInterpTo");
		
		UKismetMathLibrary_CInterpTo_Params params {};
		params.current = current;
		params.Target = Target;
		params.DeltaTime = DeltaTime;
		params.InterpSpeed = InterpSpeed;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351510
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakVector2D
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakVector2D(const struct FVector2D& inVec, float* X, float* Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector2D");
		
		UKismetMathLibrary_BreakVector2D_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023516C0
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakVector
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakVector(const struct FVector& inVec, float* X, float* Y, float* Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakVector");
		
		UKismetMathLibrary_BreakVector_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351900
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakTransform
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  InTransform                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Scale                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakTransform(const struct FTransform& InTransform, struct FVector* Location, struct FRotator* Rotation, struct FVector* Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakTransform");
		
		UKismetMathLibrary_BreakTransform_Params params {};
		params.InTransform = InTransform;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Location != nullptr)
			*Location = params.Location;
		if (Rotation != nullptr)
			*Rotation = params.Rotation;
		if (Scale != nullptr)
			*Scale = params.Scale;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351B20
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakRotIntoAxes
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     X                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Y                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Z                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakRotIntoAxes(const struct FRotator& InRot, struct FVector* X, struct FVector* Y, struct FVector* Z)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRotIntoAxes");
		
		UKismetMathLibrary_BreakRotIntoAxes_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (X != nullptr)
			*X = params.X;
		if (Y != nullptr)
			*Y = params.Y;
		if (Z != nullptr)
			*Z = params.Z;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023516C0
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakRot
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Pitch                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Yaw                                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Roll                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakRot(const struct FRotator& InRot, float* Pitch, float* Yaw, float* Roll)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakRot");
		
		UKismetMathLibrary_BreakRot_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Pitch != nullptr)
			*Pitch = params.Pitch;
		if (Yaw != nullptr)
			*Yaw = params.Yaw;
		if (Roll != nullptr)
			*Roll = params.Roll;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02351D80
	 * 		Name   -> Function Engine.KismetMathLibrary.BreakColor
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                InColor                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              R                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              G                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              A                                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetMathLibrary::STATIC_BreakColor(const struct FLinearColor& InColor, float* R, float* G, float* B, float* A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BreakColor");
		
		UKismetMathLibrary_BreakColor_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (R != nullptr)
			*R = params.R;
		if (G != nullptr)
			*G = params.G;
		if (B != nullptr)
			*B = params.B;
		if (A != nullptr)
			*A = params.A;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352040
	 * 		Name   -> Function Engine.KismetMathLibrary.BoundToCube
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_BoundToCube(const struct FVector& A, float Radius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BoundToCube");
		
		UKismetMathLibrary_BoundToCube_Params params {};
		params.A = A;
		params.Radius = Radius;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023521E0
	 * 		Name   -> Function Engine.KismetMathLibrary.BooleanXOR
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_BooleanXOR(bool A, bool B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanXOR");
		
		UKismetMathLibrary_BooleanXOR_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352340
	 * 		Name   -> Function Engine.KismetMathLibrary.BooleanOR
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_BooleanOR(bool A, bool B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanOR");
		
		UKismetMathLibrary_BooleanOR_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023524B0
	 * 		Name   -> Function Engine.KismetMathLibrary.BooleanAND
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetMathLibrary::STATIC_BooleanAND(bool A, bool B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.BooleanAND");
		
		UKismetMathLibrary_BooleanAND_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352620
	 * 		Name   -> Function Engine.KismetMathLibrary.Atan2
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Atan2(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Atan2");
		
		UKismetMathLibrary_Atan2_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352780
	 * 		Name   -> Function Engine.KismetMathLibrary.Asin
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Asin(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Asin");
		
		UKismetMathLibrary_Asin_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352870
	 * 		Name   -> Function Engine.KismetMathLibrary.And_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_And_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.And_IntInt");
		
		UKismetMathLibrary_And_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023529C0
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_VectorVector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Add_VectorVector(const struct FVector& A, const struct FVector& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorVector");
		
		UKismetMathLibrary_Add_VectorVector_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352B30
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_VectorFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UKismetMathLibrary::STATIC_Add_VectorFloat(const struct FVector& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_VectorFloat");
		
		UKismetMathLibrary_Add_VectorFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352CA0
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_Vector2DVector2D
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DVector2D(const struct FVector2D& A, const struct FVector2D& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DVector2D");
		
		UKismetMathLibrary_Add_Vector2DVector2D_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352DF0
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_Vector2DFloat
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UKismetMathLibrary::STATIC_Add_Vector2DFloat(const struct FVector2D& A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_Vector2DFloat");
		
		UKismetMathLibrary_Add_Vector2DFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352F50
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_TimespanTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	struct FTimespan UKismetMathLibrary::STATIC_Add_TimespanTimespan(const struct FTimespan& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_TimespanTimespan");
		
		UKismetMathLibrary_Add_TimespanTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353090
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_IntInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Add_IntInt(int32_t A, int32_t B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_IntInt");
		
		UKismetMathLibrary_Add_IntInt_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023531E0
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_FloatFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Add_FloatFloat(float A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_FloatFloat");
		
		UKismetMathLibrary_Add_FloatFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353330
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_DoubleFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Add_DoubleFloat(double A, float B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DoubleFloat");
		
		UKismetMathLibrary_Add_DoubleFloat_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353490
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_DoubleDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetMathLibrary::STATIC_Add_DoubleDouble(double A, double B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DoubleDouble");
		
		UKismetMathLibrary_Add_DoubleDouble_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02352F50
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_DateTimeTimespan
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   A                                                          (Parm, ZeroConstructor)
	 * 		struct FTimespan                                   B                                                          (Parm, ZeroConstructor)
	 */
	struct FDateTime UKismetMathLibrary::STATIC_Add_DateTimeTimespan(const struct FDateTime& A, const struct FTimespan& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_DateTimeTimespan");
		
		UKismetMathLibrary_Add_DateTimeTimespan_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023535F0
	 * 		Name   -> Function Engine.KismetMathLibrary.Add_ByteByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      B                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetMathLibrary::STATIC_Add_ByteByte(unsigned char A, unsigned char B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Add_ByteByte");
		
		UKismetMathLibrary_Add_ByteByte_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353740
	 * 		Name   -> Function Engine.KismetMathLibrary.Acos
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Acos(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Acos");
		
		UKismetMathLibrary_Acos_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353830
	 * 		Name   -> Function Engine.KismetMathLibrary.Abs_Int
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetMathLibrary::STATIC_Abs_Int(int32_t A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs_Int");
		
		UKismetMathLibrary_Abs_Int_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353900
	 * 		Name   -> Function Engine.KismetMathLibrary.Abs
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              A                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetMathLibrary::STATIC_Abs(float A)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetMathLibrary.Abs");
		
		UKismetMathLibrary_Abs_Params params {};
		params.A = A;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetMathLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetMathLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetMathLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353A00
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.MarkBit
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetNodeHelperLibrary::STATIC_MarkBit(int32_t* Data, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.MarkBit");
		
		UKismetNodeHelperLibrary_MarkBit_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Data != nullptr)
			*Data = params.Data;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353B50
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetNodeHelperLibrary::STATIC_HasUnmarkedBit(int32_t Data, int32_t NumBits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit");
		
		UKismetNodeHelperLibrary_HasUnmarkedBit_Params params {};
		params.Data = Data;
		params.NumBits = NumBits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353CD0
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.HasMarkedBit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetNodeHelperLibrary::STATIC_HasMarkedBit(int32_t Data, int32_t NumBits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.HasMarkedBit");
		
		UKismetNodeHelperLibrary_HasMarkedBit_Params params {};
		params.Data = Data;
		params.NumBits = NumBits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353E50
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetValidIndex
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      EnumeratorIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetNodeHelperLibrary::STATIC_GetValidIndex(class UEnum* Enum, unsigned char EnumeratorIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetValidIndex");
		
		UKismetNodeHelperLibrary_GetValidIndex_Params params {};
		params.Enum = Enum;
		params.EnumeratorIndex = EnumeratorIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02353FD0
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bRandom                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetNodeHelperLibrary::STATIC_GetUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits, bool bRandom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit");
		
		UKismetNodeHelperLibrary_GetUnmarkedBit_Params params {};
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;
		params.bRandom = bRandom;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023542B0
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetNodeHelperLibrary::STATIC_GetRandomUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit");
		
		UKismetNodeHelperLibrary_GetRandomUnmarkedBit_Params params {};
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354480
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            StartIdx                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumBits                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetNodeHelperLibrary::STATIC_GetFirstUnmarkedBit(int32_t Data, int32_t StartIdx, int32_t NumBits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit");
		
		UKismetNodeHelperLibrary_GetFirstUnmarkedBit_Params params {};
		params.Data = Data;
		params.StartIdx = StartIdx;
		params.NumBits = NumBits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023546C0
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      EnumeratorIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetNodeHelperLibrary::STATIC_GetEnumeratorUserFriendlyName(class UEnum* Enum, unsigned char EnumeratorIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName");
		
		UKismetNodeHelperLibrary_GetEnumeratorUserFriendlyName_Params params {};
		params.Enum = Enum;
		params.EnumeratorIndex = EnumeratorIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354890
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UEnum*                                       Enum                                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      EnumeratorIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName UKismetNodeHelperLibrary::STATIC_GetEnumeratorName(class UEnum* Enum, unsigned char EnumeratorIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.GetEnumeratorName");
		
		UKismetNodeHelperLibrary_GetEnumeratorName_Params params {};
		params.Enum = Enum;
		params.EnumeratorIndex = EnumeratorIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354A10
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.ClearBit
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetNodeHelperLibrary::STATIC_ClearBit(int32_t* Data, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearBit");
		
		UKismetNodeHelperLibrary_ClearBit_Params params {};
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Data != nullptr)
			*Data = params.Data;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354B60
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.ClearAllBits
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetNodeHelperLibrary::STATIC_ClearAllBits(int32_t* Data)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.ClearAllBits");
		
		UKismetNodeHelperLibrary_ClearAllBits_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Data != nullptr)
			*Data = params.Data;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354C10
	 * 		Name   -> Function Engine.KismetNodeHelperLibrary.BitIsMarked
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Data                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetNodeHelperLibrary::STATIC_BitIsMarked(int32_t Data, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetNodeHelperLibrary.BitIsMarked");
		
		UKismetNodeHelperLibrary_BitIsMarked_Params params {};
		params.Data = Data;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetNodeHelperLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetNodeHelperLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetNodeHelperLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTexture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTexture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Texture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextureRenderTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextureRenderTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextureRenderTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextureRenderTarget2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextureRenderTarget2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextureRenderTarget2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02354D80
	 * 		Name   -> Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Name                                                       (Parm, ZeroConstructor)
	 * 		ETextureCompressionSettings                        CompressionSettings                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETextureMipGenSettings                             MipSettings                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UTexture2D* UKismetRenderingLibrary::STATIC_RenderTargetCreateStaticTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, const class FString& Name, ETextureCompressionSettings CompressionSettings, ETextureMipGenSettings MipSettings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly");
		
		UKismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly_Params params {};
		params.RenderTarget = RenderTarget;
		params.Name = Name;
		params.CompressionSettings = CompressionSettings;
		params.MipSettings = MipSettings;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355020
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetRenderingLibrary::STATIC_ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D");
		
		UKismetRenderingLibrary_ReleaseRenderTarget2D_Params params {};
		params.TextureRenderTarget = TextureRenderTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355110
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ReadRenderTargetUV
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              U                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FColor UKismetRenderingLibrary::STATIC_ReadRenderTargetUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetUV");
		
		UKismetRenderingLibrary_ReadRenderTargetUV_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.U = U;
		params.V = V;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355410
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              U                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              V                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetRenderingLibrary::STATIC_ReadRenderTargetRawUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawUV");
		
		UKismetRenderingLibrary_ReadRenderTargetRawUV_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.U = U;
		params.V = V;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355730
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UKismetRenderingLibrary::STATIC_ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetRawPixel");
		
		UKismetRenderingLibrary_ReadRenderTargetRawPixel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.X = X;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023559B0
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FColor UKismetRenderingLibrary::STATIC_ReadRenderTargetPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32_t X, int32_t Y)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ReadRenderTargetPixel");
		
		UKismetRenderingLibrary_ReadRenderTargetPixel_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.X = X;
		params.Y = Y;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355C10
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      filename                                                   (Parm, ZeroConstructor)
	 */
	class UTexture2D* UKismetRenderingLibrary::STATIC_ImportFileAsTexture2D(class UObject* WorldContextObject, const class FString& filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ImportFileAsTexture2D");
		
		UKismetRenderingLibrary_ImportFileAsTexture2D_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.filename = filename;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02355DB0
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ExportTexture2D
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FilePath                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      filename                                                   (Parm, ZeroConstructor)
	 */
	void UKismetRenderingLibrary::STATIC_ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, const class FString& FilePath, const class FString& filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportTexture2D");
		
		UKismetRenderingLibrary_ExportTexture2D_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Texture = Texture;
		params.FilePath = FilePath;
		params.filename = filename;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356070
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ExportRenderTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FilePath                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      filename                                                   (Parm, ZeroConstructor)
	 */
	void UKismetRenderingLibrary::STATIC_ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const class FString& FilePath, const class FString& filename)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ExportRenderTarget");
		
		UKismetRenderingLibrary_ExportRenderTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.FilePath = FilePath;
		params.filename = filename;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356310
	 * 		Name   -> Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDrawToRenderTargetContext                  Context                                                    (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UKismetRenderingLibrary::STATIC_EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const struct FDrawToRenderTargetContext& Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget");
		
		UKismetRenderingLibrary_EndDrawCanvasToRenderTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Context = Context;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356450
	 * 		Name   -> Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInterface*                          Material                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetRenderingLibrary::STATIC_DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget");
		
		UKismetRenderingLibrary_DrawMaterialToRenderTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.Material = Material;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356630
	 * 		Name   -> Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETextureRenderTargetFormat                         Format                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UTextureRenderTarget2D* UKismetRenderingLibrary::STATIC_CreateRenderTarget2D(class UObject* WorldContextObject, int32_t Width, int32_t Height, ETextureRenderTargetFormat Format)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.CreateRenderTarget2D");
		
		UKismetRenderingLibrary_CreateRenderTarget2D_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Width = Width;
		params.Height = Height;
		params.Format = Format;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356890
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      RenderTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture2D*                                  Texture                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetRenderingLibrary::STATIC_ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly");
		
		UKismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.RenderTarget = RenderTarget;
		params.Texture = Texture;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356A60
	 * 		Name   -> Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                ClearColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetRenderingLibrary::STATIC_ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, const struct FLinearColor& ClearColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.ClearRenderTarget2D");
		
		UKismetRenderingLibrary_ClearRenderTarget2D_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		params.ClearColor = ClearColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356C40
	 * 		Name   -> Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTextureRenderTarget2D*                      TextureRenderTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UCanvas*                                     Canvas                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   Size                                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDrawToRenderTargetContext                  Context                                                    (Parm, OutParm)
	 */
	void UKismetRenderingLibrary::STATIC_BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas** Canvas, struct FVector2D* Size, struct FDrawToRenderTargetContext* Context)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget");
		
		UKismetRenderingLibrary_BeginDrawCanvasToRenderTarget_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextureRenderTarget = TextureRenderTarget;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Canvas != nullptr)
			*Canvas = params.Canvas;
		if (Size != nullptr)
			*Size = params.Size;
		if (Context != nullptr)
			*Context = params.Context;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetRenderingLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetRenderingLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetRenderingLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02356EF0
	 * 		Name   -> Function Engine.KismetStringLibrary.TrimTrailing
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_TrimTrailing(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.TrimTrailing");
		
		UKismetStringLibrary_TrimTrailing_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357080
	 * 		Name   -> Function Engine.KismetStringLibrary.Trim
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_Trim(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Trim");
		
		UKismetStringLibrary_Trim_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357210
	 * 		Name   -> Function Engine.KismetStringLibrary.ToUpper
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_ToUpper(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToUpper");
		
		UKismetStringLibrary_ToUpper_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023573A0
	 * 		Name   -> Function Engine.KismetStringLibrary.ToLower
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_ToLower(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ToLower");
		
		UKismetStringLibrary_ToLower_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357530
	 * 		Name   -> Function Engine.KismetStringLibrary.StartsWith
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      InPrefix                                                   (Parm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetStringLibrary::STATIC_StartsWith(const class FString& SourceString, const class FString& InPrefix, ESearchCase SearchCase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.StartsWith");
		
		UKismetStringLibrary_StartsWith_Params params {};
		params.SourceString = SourceString;
		params.InPrefix = InPrefix;
		params.SearchCase = SearchCase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023577D0
	 * 		Name   -> Function Engine.KismetStringLibrary.Split
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      InStr                                                      (Parm, ZeroConstructor)
	 * 		class FString                                      LeftS                                                      (Parm, OutParm, ZeroConstructor)
	 * 		class FString                                      RightS                                                     (Parm, OutParm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ESearchDir                                         SearchDir                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetStringLibrary::STATIC_Split(const class FString& SourceString, const class FString& InStr, class FString* LeftS, class FString* RightS, ESearchCase SearchCase, ESearchDir SearchDir)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Split");
		
		UKismetStringLibrary_Split_Params params {};
		params.SourceString = SourceString;
		params.InStr = InStr;
		params.SearchCase = SearchCase;
		params.SearchDir = SearchDir;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (LeftS != nullptr)
			*LeftS = params.LeftS;
		if (RightS != nullptr)
			*RightS = params.RightS;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357BA0
	 * 		Name   -> Function Engine.KismetStringLibrary.RightPad
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            ChCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_RightPad(const class FString& SourceString, int32_t ChCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightPad");
		
		UKismetStringLibrary_RightPad_Params params {};
		params.SourceString = SourceString;
		params.ChCount = ChCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357DB0
	 * 		Name   -> Function Engine.KismetStringLibrary.RightChop
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_RightChop(const class FString& SourceString, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.RightChop");
		
		UKismetStringLibrary_RightChop_Params params {};
		params.SourceString = SourceString;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02357FC0
	 * 		Name   -> Function Engine.KismetStringLibrary.Right
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Right(const class FString& SourceString, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Right");
		
		UKismetStringLibrary_Right_Params params {};
		params.SourceString = SourceString;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023581D0
	 * 		Name   -> Function Engine.KismetStringLibrary.Reverse
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_Reverse(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Reverse");
		
		UKismetStringLibrary_Reverse_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02358360
	 * 		Name   -> Function Engine.KismetStringLibrary.ReplaceInline
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, OutParm, ZeroConstructor)
	 * 		class FString                                      SearchText                                                 (Parm, ZeroConstructor)
	 * 		class FString                                      ReplacementText                                            (Parm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetStringLibrary::STATIC_ReplaceInline(class FString* SourceString, const class FString& SearchText, const class FString& ReplacementText, ESearchCase SearchCase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ReplaceInline");
		
		UKismetStringLibrary_ReplaceInline_Params params {};
		params.SearchText = SearchText;
		params.ReplacementText = ReplacementText;
		params.SearchCase = SearchCase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (SourceString != nullptr)
			*SourceString = params.SourceString;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02358640
	 * 		Name   -> Function Engine.KismetStringLibrary.Replace
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      From                                                       (Parm, ZeroConstructor)
	 * 		class FString                                      To                                                         (Parm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Replace(const class FString& SourceString, const class FString& From, const class FString& To, ESearchCase SearchCase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Replace");
		
		UKismetStringLibrary_Replace_Params params {};
		params.SourceString = SourceString;
		params.From = From;
		params.To = To;
		params.SearchCase = SearchCase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023589D0
	 * 		Name   -> Function Engine.KismetStringLibrary.ParseIntoArray
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      Delimiter                                                  (Parm, ZeroConstructor)
	 * 		bool                                               CullEmptyStrings                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	TArray<class FString> UKismetStringLibrary::STATIC_ParseIntoArray(const class FString& SourceString, const class FString& Delimiter, bool CullEmptyStrings)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.ParseIntoArray");
		
		UKismetStringLibrary_ParseIntoArray_Params params {};
		params.SourceString = SourceString;
		params.Delimiter = Delimiter;
		params.CullEmptyStrings = CullEmptyStrings;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02358C40
	 * 		Name   -> Function Engine.KismetStringLibrary.NotEqual_StrStr
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetStringLibrary::STATIC_NotEqual_StrStr(const class FString& A, const class FString& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StrStr");
		
		UKismetStringLibrary_NotEqual_StrStr_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02358E30
	 * 		Name   -> Function Engine.KismetStringLibrary.NotEqual_StriStri
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetStringLibrary::STATIC_NotEqual_StriStri(const class FString& A, const class FString& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.NotEqual_StriStri");
		
		UKismetStringLibrary_NotEqual_StriStri_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359060
	 * 		Name   -> Function Engine.KismetStringLibrary.Mid
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            Start                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Mid(const class FString& SourceString, int32_t Start, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Mid");
		
		UKismetStringLibrary_Mid_Params params {};
		params.SourceString = SourceString;
		params.Start = Start;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023592F0
	 * 		Name   -> Function Engine.KismetStringLibrary.MatchesWildcard
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      Wildcard                                                   (Parm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetStringLibrary::STATIC_MatchesWildcard(const class FString& SourceString, const class FString& Wildcard, ESearchCase SearchCase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.MatchesWildcard");
		
		UKismetStringLibrary_MatchesWildcard_Params params {};
		params.SourceString = SourceString;
		params.Wildcard = Wildcard;
		params.SearchCase = SearchCase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359530
	 * 		Name   -> Function Engine.KismetStringLibrary.Len
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      S                                                          (Parm, ZeroConstructor)
	 */
	int32_t UKismetStringLibrary::STATIC_Len(const class FString& S)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Len");
		
		UKismetStringLibrary_Len_Params params {};
		params.S = S;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359630
	 * 		Name   -> Function Engine.KismetStringLibrary.LeftPad
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            ChCount                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_LeftPad(const class FString& SourceString, int32_t ChCount)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftPad");
		
		UKismetStringLibrary_LeftPad_Params params {};
		params.SourceString = SourceString;
		params.ChCount = ChCount;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359840
	 * 		Name   -> Function Engine.KismetStringLibrary.LeftChop
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_LeftChop(const class FString& SourceString, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.LeftChop");
		
		UKismetStringLibrary_LeftChop_Params params {};
		params.SourceString = SourceString;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359A50
	 * 		Name   -> Function Engine.KismetStringLibrary.Left
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            Count                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Left(const class FString& SourceString, int32_t Count)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Left");
		
		UKismetStringLibrary_Left_Params params {};
		params.SourceString = SourceString;
		params.Count = Count;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359C60
	 * 		Name   -> Function Engine.KismetStringLibrary.JoinStringArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		TArray<class FString>                              SourceArray                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class FString                                      Separator                                                  (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_JoinStringArray(TArray<class FString> SourceArray, const class FString& Separator)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.JoinStringArray");
		
		UKismetStringLibrary_JoinStringArray_Params params {};
		params.SourceArray = SourceArray;
		params.Separator = Separator;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359E70
	 * 		Name   -> Function Engine.KismetStringLibrary.IsNumeric
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	bool UKismetStringLibrary::STATIC_IsNumeric(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.IsNumeric");
		
		UKismetStringLibrary_IsNumeric_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359060
	 * 		Name   -> Function Engine.KismetStringLibrary.GetSubstring
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            StartIndex                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_GetSubstring(const class FString& SourceString, int32_t StartIndex, int32_t Length)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetSubstring");
		
		UKismetStringLibrary_GetSubstring_Params params {};
		params.SourceString = SourceString;
		params.StartIndex = StartIndex;
		params.Length = Length;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02359F70
	 * 		Name   -> Function Engine.KismetStringLibrary.GetCharacterAsNumber
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		int32_t                                            index                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetStringLibrary::STATIC_GetCharacterAsNumber(const class FString& SourceString, int32_t index)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterAsNumber");
		
		UKismetStringLibrary_GetCharacterAsNumber_Params params {};
		params.SourceString = SourceString;
		params.index = index;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235A120
	 * 		Name   -> Function Engine.KismetStringLibrary.GetCharacterArrayFromString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 */
	TArray<class FString> UKismetStringLibrary::STATIC_GetCharacterArrayFromString(const class FString& SourceString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.GetCharacterArrayFromString");
		
		UKismetStringLibrary_GetCharacterArrayFromString_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235A240
	 * 		Name   -> Function Engine.KismetStringLibrary.FindSubstring
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SearchIn                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Substring                                                  (Parm, ZeroConstructor)
	 * 		bool                                               bUseCase                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bSearchFromEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            StartPosition                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetStringLibrary::STATIC_FindSubstring(const class FString& SearchIn, const class FString& Substring, bool bUseCase, bool bSearchFromEnd, int32_t StartPosition)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.FindSubstring");
		
		UKismetStringLibrary_FindSubstring_Params params {};
		params.SearchIn = SearchIn;
		params.Substring = Substring;
		params.bUseCase = bUseCase;
		params.bSearchFromEnd = bSearchFromEnd;
		params.StartPosition = StartPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235A5E0
	 * 		Name   -> Function Engine.KismetStringLibrary.EqualEqual_StrStr
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetStringLibrary::STATIC_EqualEqual_StrStr(const class FString& A, const class FString& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StrStr");
		
		UKismetStringLibrary_EqualEqual_StrStr_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235A7D0
	 * 		Name   -> Function Engine.KismetStringLibrary.EqualEqual_StriStri
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 */
	bool UKismetStringLibrary::STATIC_EqualEqual_StriStri(const class FString& A, const class FString& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EqualEqual_StriStri");
		
		UKismetStringLibrary_EqualEqual_StriStri_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235AA00
	 * 		Name   -> Function Engine.KismetStringLibrary.EndsWith
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		class FString                                      InSuffix                                                   (Parm, ZeroConstructor)
	 * 		ESearchCase                                        SearchCase                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetStringLibrary::STATIC_EndsWith(const class FString& SourceString, const class FString& InSuffix, ESearchCase SearchCase)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.EndsWith");
		
		UKismetStringLibrary_EndsWith_Params params {};
		params.SourceString = SourceString;
		params.InSuffix = InSuffix;
		params.SearchCase = SearchCase;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235AC40
	 * 		Name   -> Function Engine.KismetStringLibrary.CullArray
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      SourceString                                               (Parm, ZeroConstructor)
	 * 		TArray<class FString>                              InArray                                                    (Parm, OutParm, ZeroConstructor)
	 */
	int32_t UKismetStringLibrary::STATIC_CullArray(const class FString& SourceString, TArray<class FString>* InArray)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.CullArray");
		
		UKismetStringLibrary_CullArray_Params params {};
		params.SourceString = SourceString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (InArray != nullptr)
			*InArray = params.InArray;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235AE10
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_VectorToString
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector                                     inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_VectorToString(const struct FVector& inVec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_VectorToString");
		
		UKismetStringLibrary_Conv_VectorToString_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235AF80
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_Vector2dToString
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FVector2D                                   inVec                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_Vector2dToString(const struct FVector2D& inVec)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_Vector2dToString");
		
		UKismetStringLibrary_Conv_Vector2dToString_Params params {};
		params.inVec = inVec;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B0D0
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_TransformToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTransform                                  InTrans                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_TransformToString(const struct FTransform& InTrans)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_TransformToString");
		
		UKismetStringLibrary_Conv_TransformToString_Params params {};
		params.InTrans = InTrans;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B220
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_StringToName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	class FName UKismetStringLibrary::STATIC_Conv_StringToName(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToName");
		
		UKismetStringLibrary_Conv_StringToName_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B350
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_StringToInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	int32_t UKismetStringLibrary::STATIC_Conv_StringToInt(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToInt");
		
		UKismetStringLibrary_Conv_StringToInt_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B460
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_StringToFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	float UKismetStringLibrary::STATIC_Conv_StringToFloat(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToFloat");
		
		UKismetStringLibrary_Conv_StringToFloat_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B580
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_StringToDouble
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	double UKismetStringLibrary::STATIC_Conv_StringToDouble(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_StringToDouble");
		
		UKismetStringLibrary_Conv_StringToDouble_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B690
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_RotatorToString
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_RotatorToString(const struct FRotator& InRot)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_RotatorToString");
		
		UKismetStringLibrary_Conv_RotatorToString_Params params {};
		params.InRot = InRot;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B800
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_ObjectToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     InObj                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_ObjectToString(class UObject* InObj)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ObjectToString");
		
		UKismetStringLibrary_Conv_ObjectToString_Params params {};
		params.InObj = InObj;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235B960
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_NameToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_NameToString(const class FName& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_NameToString");
		
		UKismetStringLibrary_Conv_NameToString_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235BAC0
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_IntToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_IntToString(int32_t InInt)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_IntToString");
		
		UKismetStringLibrary_Conv_IntToString_Params params {};
		params.InInt = InInt;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235BC20
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_FloatToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_FloatToString(float InFloat)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_FloatToString");
		
		UKismetStringLibrary_Conv_FloatToString_Params params {};
		params.InFloat = InFloat;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235BD80
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_DoubleToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		double                                             InDouble                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_DoubleToString(double InDouble)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_DoubleToString");
		
		UKismetStringLibrary_Conv_DoubleToString_Params params {};
		params.InDouble = InDouble;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235BEE0
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_ColorToString
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FLinearColor                                InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_ColorToString(const struct FLinearColor& InColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ColorToString");
		
		UKismetStringLibrary_Conv_ColorToString_Params params {};
		params.InColor = InColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235C040
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_ByteToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      InByte                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_ByteToString(unsigned char InByte)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_ByteToString");
		
		UKismetStringLibrary_Conv_ByteToString_Params params {};
		params.InByte = InByte;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235C1A0
	 * 		Name   -> Function Engine.KismetStringLibrary.Conv_BoolToString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetStringLibrary::STATIC_Conv_BoolToString(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Conv_BoolToString");
		
		UKismetStringLibrary_Conv_BoolToString_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235C300
	 * 		Name   -> Function Engine.KismetStringLibrary.Concat_StrStr
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      A                                                          (Parm, ZeroConstructor)
	 * 		class FString                                      B                                                          (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_Concat_StrStr(const class FString& A, const class FString& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.Concat_StrStr");
		
		UKismetStringLibrary_Concat_StrStr_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235C540
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Vector2d
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		struct FVector2D                                   InVector2D                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Vector2d(const class FString& AppendTo, const class FString& Prefix, const struct FVector2D& InVector2D, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector2d");
		
		UKismetStringLibrary_BuildString_Vector2d_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InVector2D = InVector2D;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235C8D0
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Vector
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		struct FVector                                     InVector                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Vector(const class FString& AppendTo, const class FString& Prefix, const struct FVector& InVector, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Vector");
		
		UKismetStringLibrary_BuildString_Vector_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InVector = InVector;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235CC60
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Rotator
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		struct FRotator                                    InRot                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Rotator(const class FString& AppendTo, const class FString& Prefix, const struct FRotator& InRot, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Rotator");
		
		UKismetStringLibrary_BuildString_Rotator_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InRot = InRot;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235CFF0
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Object
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		class UObject*                                     InObj                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Object(const class FString& AppendTo, const class FString& Prefix, class UObject* InObj, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Object");
		
		UKismetStringLibrary_BuildString_Object_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InObj = InObj;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235D380
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Name
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Name(const class FString& AppendTo, const class FString& Prefix, const class FName& InName, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Name");
		
		UKismetStringLibrary_BuildString_Name_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InName = InName;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235D710
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Int
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		int32_t                                            InInt                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Int(const class FString& AppendTo, const class FString& Prefix, int32_t InInt, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Int");
		
		UKismetStringLibrary_BuildString_Int_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InInt = InInt;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235DAA0
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Float
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		float                                              InFloat                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Float(const class FString& AppendTo, const class FString& Prefix, float InFloat, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Float");
		
		UKismetStringLibrary_BuildString_Float_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InFloat = InFloat;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235DE40
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Color
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		struct FLinearColor                                InColor                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Color(const class FString& AppendTo, const class FString& Prefix, const struct FLinearColor& InColor, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Color");
		
		UKismetStringLibrary_BuildString_Color_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InColor = InColor;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235E1E0
	 * 		Name   -> Function Engine.KismetStringLibrary.BuildString_Bool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      AppendTo                                                   (Parm, ZeroConstructor)
	 * 		class FString                                      Prefix                                                     (Parm, ZeroConstructor)
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Suffix                                                     (Parm, ZeroConstructor)
	 */
	class FString UKismetStringLibrary::STATIC_BuildString_Bool(const class FString& AppendTo, const class FString& Prefix, bool InBool, const class FString& Suffix)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetStringLibrary.BuildString_Bool");
		
		UKismetStringLibrary_BuildString_Bool_Params params {};
		params.AppendTo = AppendTo;
		params.Prefix = Prefix;
		params.InBool = InBool;
		params.Suffix = Suffix;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetStringLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetStringLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetStringLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235E580
	 * 		Name   -> Function Engine.KismetSystemLibrary.SwitchNetworkMode
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ENetModeBP                                         OutNetworkMode                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SwitchNetworkMode(class UObject* WorldContextObject, ENetModeBP* OutNetworkMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SwitchNetworkMode");
		
		UKismetSystemLibrary_SwitchNetworkMode_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNetworkMode != nullptr)
			*OutNetworkMode = params.OutNetworkMode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E2F5C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.StackTrace
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UKismetSystemLibrary::STATIC_StackTrace()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.StackTrace");
		
		UKismetSystemLibrary_StackTrace_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235E6C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects");
		
		UKismetSystemLibrary_SphereTraceSingleForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235EC50
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingleByObject_DEPRECATED");
		
		UKismetSystemLibrary_SphereTraceSingleByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235F1E0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingle_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle_NEW");
		
		UKismetSystemLibrary_SphereTraceSingle_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235F7A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceSingle_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceSingle_DEPRECATED");
		
		UKismetSystemLibrary_SphereTraceSingle_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0235FD10
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects");
		
		UKismetSystemLibrary_SphereTraceMultiForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023602A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMultiByObject_DEPRECATED");
		
		UKismetSystemLibrary_SphereTraceMultiByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02360830
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMulti_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti_NEW");
		
		UKismetSystemLibrary_SphereTraceMulti_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02360DF0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereTraceMulti_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereTraceMulti_DEPRECATED");
		
		UKismetSystemLibrary_SphereTraceMulti_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02361360
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapComponents_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents_NEW");
		
		UKismetSystemLibrary_SphereOverlapComponents_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02361760
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapComponents_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_SphereOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, EOverlapFilterOption Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapComponents_DEPRECATED");
		
		UKismetSystemLibrary_SphereOverlapComponents_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02361B40
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapActorsSimple
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EObjectTypeQuery                                   ObjectType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereOverlapActorsSimple(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, EObjectTypeQuery ObjectType, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActorsSimple");
		
		UKismetSystemLibrary_SphereOverlapActorsSimple_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.ObjectType = ObjectType;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02361F20
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapActors_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors_NEW");
		
		UKismetSystemLibrary_SphereOverlapActors_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362320
	 * 		Name   -> Function Engine.KismetSystemLibrary.SphereOverlapActors_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     SpherePos                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_SphereOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& SpherePos, float SphereRadius, EOverlapFilterOption Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SphereOverlapActors_DEPRECATED");
		
		UKismetSystemLibrary_SphereOverlapActors_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpherePos = SpherePos;
		params.SphereRadius = SphereRadius;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362700
	 * 		Name   -> Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      CategoryName                                               (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_ShowPlatformSpecificLeaderboardScreen(const class FString& CategoryName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen");
		
		UKismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen_Params params {};
		params.CategoryName = CategoryName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362860
	 * 		Name   -> Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_ShowPlatformSpecificAchievementsScreen(class APlayerController* SpecificPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen");
		
		UKismetSystemLibrary_ShowPlatformSpecificAchievementsScreen_Params params {};
		params.SpecificPlayer = SpecificPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362920
	 * 		Name   -> Function Engine.KismetSystemLibrary.ShowAdBanner
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShowOnBottomOfScreen                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_ShowAdBanner(bool bShowOnBottomOfScreen)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ShowAdBanner");
		
		UKismetSystemLibrary_ShowAdBanner_Params params {};
		params.bShowOnBottomOfScreen = bShowOnBottomOfScreen;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362A30
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetVectorPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetVectorPropertyByName(class UObject* Object, const class FName& PropertyName, const struct FVector& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetVectorPropertyByName");
		
		UKismetSystemLibrary_SetVectorPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362BF0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetTransformPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  Value                                                      (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetTransformPropertyByName(class UObject* Object, const class FName& PropertyName, const struct FTransform& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTransformPropertyByName");
		
		UKismetSystemLibrary_SetTransformPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362DB0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetTextPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FText                                        Value                                                      (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UKismetSystemLibrary::STATIC_SetTextPropertyByName(class UObject* Object, const class FName& PropertyName, const class FText& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetTextPropertyByName");
		
		UKismetSystemLibrary_SetTextPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02362FC0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetSupressViewportTransitionMessage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bState                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetSupressViewportTransitionMessage(class UObject* WorldContextObject, bool bState)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetSupressViewportTransitionMessage");
		
		UKismetSystemLibrary_SetSupressViewportTransitionMessage_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.bState = bState;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378B10
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetStructurePropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FGenericStruct                              Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetStructurePropertyByName(class UObject* Object, const class FName& PropertyName, const struct FGenericStruct& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStructurePropertyByName");
		
		UKismetSystemLibrary_SetStructurePropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363170
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetStringPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_SetStringPropertyByName(class UObject* Object, const class FName& PropertyName, const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetStringPropertyByName");
		
		UKismetSystemLibrary_SetStringPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023633A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetRotatorPropertyByName(class UObject* Object, const class FName& PropertyName, const struct FRotator& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetRotatorPropertyByName");
		
		UKismetSystemLibrary_SetRotatorPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363560
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetObjectPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UObject*                                     Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetObjectPropertyByName(class UObject* Object, const class FName& PropertyName, class UObject* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetObjectPropertyByName");
		
		UKismetSystemLibrary_SetObjectPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363780
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetNamePropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetNamePropertyByName(class UObject* Object, const class FName& PropertyName, const class FName& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetNamePropertyByName");
		
		UKismetSystemLibrary_SetNamePropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363960
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                Value                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetLinearColorPropertyByName(class UObject* Object, const class FName& PropertyName, const struct FLinearColor& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName");
		
		UKismetSystemLibrary_SetLinearColorPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363B20
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetIntPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetIntPropertyByName(class UObject* Object, const class FName& PropertyName, int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetIntPropertyByName");
		
		UKismetSystemLibrary_SetIntPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363D10
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetFloatPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetFloatPropertyByName(class UObject* Object, const class FName& PropertyName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetFloatPropertyByName");
		
		UKismetSystemLibrary_SetFloatPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02363F10
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetDoublePropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		double                                             Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetDoublePropertyByName(class UObject* Object, const class FName& PropertyName, double Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetDoublePropertyByName");
		
		UKismetSystemLibrary_SetDoublePropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02364110
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetClassPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetClassPropertyByName(class UObject* Object, const class FName& PropertyName, class UClass* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetClassPropertyByName");
		
		UKismetSystemLibrary_SetClassPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023642F0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetBytePropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetBytePropertyByName(class UObject* Object, const class FName& PropertyName, unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBytePropertyByName");
		
		UKismetSystemLibrary_SetBytePropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023644E0
	 * 		Name   -> Function Engine.KismetSystemLibrary.SetBoolPropertyByName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FName                                        PropertyName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_SetBoolPropertyByName(class UObject* Object, const class FName& PropertyName, bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.SetBoolPropertyByName");
		
		UKismetSystemLibrary_SetBoolPropertyByName_Params params {};
		params.Object = Object;
		params.PropertyName = PropertyName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023646F0
	 * 		Name   -> Function Engine.KismetSystemLibrary.RetriggerableDelay
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 */
	void UKismetSystemLibrary::STATIC_RetriggerableDelay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.RetriggerableDelay");
		
		UKismetSystemLibrary_RetriggerableDelay_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Duration = Duration;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023648F0
	 * 		Name   -> Function Engine.KismetSystemLibrary.QuitGame
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EQuitPreference                                    QuitPreference                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_QuitGame(class UObject* WorldContextObject, class APlayerController* SpecificPlayer, EQuitPreference QuitPreference)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.QuitGame");
		
		UKismetSystemLibrary_QuitGame_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.SpecificPlayer = SpecificPlayer;
		params.QuitPreference = QuitPreference;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E42C90
	 * 		Name   -> Function Engine.KismetSystemLibrary.PrintWarning
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_PrintWarning(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintWarning");
		
		UKismetSystemLibrary_PrintWarning_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02364AD0
	 * 		Name   -> Function Engine.KismetSystemLibrary.PrintString
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 * 		bool                                               bPrintToScreen                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bPrintToLog                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            AtIndex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	void UKismetSystemLibrary::STATIC_PrintString(class UObject* WorldContextObject, const class FString& InString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration, int32_t AtIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.PrintString");
		
		UKismetSystemLibrary_PrintString_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.InString = InString;
		params.bPrintToScreen = bPrintToScreen;
		params.bPrintToLog = bPrintToLog;
		params.TextColor = TextColor;
		params.Duration = Duration;
		params.AtIndex = AtIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02364EC0
	 * 		Name   -> Function Engine.KismetSystemLibrary.MoveComponentTo
	 * 		Flags  -> (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TargetRelativeLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    TargetRelativeRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEaseOut                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bEaseIn                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              OverTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EMoveComponentAction                               MoveAction                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 * 		bool                                               bSweep                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_MoveComponentTo(class USceneComponent* Component, const struct FVector& TargetRelativeLocation, const struct FRotator& TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, EMoveComponentAction MoveAction, const struct FLatentActionInfo& LatentInfo, bool bSweep)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MoveComponentTo");
		
		UKismetSystemLibrary_MoveComponentTo_Params params {};
		params.Component = Component;
		params.TargetRelativeLocation = TargetRelativeLocation;
		params.TargetRelativeRotation = TargetRelativeRotation;
		params.bEaseOut = bEaseOut;
		params.bEaseIn = bEaseIn;
		params.OverTime = OverTime;
		params.MoveAction = MoveAction;
		params.LatentInfo = LatentInfo;
		params.bSweep = bSweep;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02365400
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        Value                                                      (Parm)
	 */
	class FText UKismetSystemLibrary::STATIC_MakeLiteralText(const class FText& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralText");
		
		UKismetSystemLibrary_MakeLiteralText_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02365640
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralString
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      Value                                                      (Parm, ZeroConstructor)
	 */
	class FString UKismetSystemLibrary::STATIC_MakeLiteralString(const class FString& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralString");
		
		UKismetSystemLibrary_MakeLiteralString_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E618B0
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FName UKismetSystemLibrary::STATIC_MakeLiteralName(const class FName& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralName");
		
		UKismetSystemLibrary_MakeLiteralName_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023657D0
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralInt
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	int32_t UKismetSystemLibrary::STATIC_MakeLiteralInt(int32_t Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralInt");
		
		UKismetSystemLibrary_MakeLiteralInt_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023658A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralFloat
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UKismetSystemLibrary::STATIC_MakeLiteralFloat(float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralFloat");
		
		UKismetSystemLibrary_MakeLiteralFloat_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02365970
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralByte
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	unsigned char UKismetSystemLibrary::STATIC_MakeLiteralByte(unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralByte");
		
		UKismetSystemLibrary_MakeLiteralByte_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0234FF80
	 * 		Name   -> Function Engine.KismetSystemLibrary.MakeLiteralBool
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_MakeLiteralBool(bool Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.MakeLiteralBool");
		
		UKismetSystemLibrary_MakeLiteralBool_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02365A30
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleForObjects");
		
		UKismetSystemLibrary_LineTraceSingleForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02365F30
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingleByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingleByObject_DEPRECATED");
		
		UKismetSystemLibrary_LineTraceSingleByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02366430
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingle_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle_NEW");
		
		UKismetSystemLibrary_LineTraceSingle_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02366920
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceSingle_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceSingle_DEPRECATED");
		
		UKismetSystemLibrary_LineTraceSingle_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02366E10
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiForObjects");
		
		UKismetSystemLibrary_LineTraceMultiForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02367310
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceMultiByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMultiByObject_DEPRECATED");
		
		UKismetSystemLibrary_LineTraceMultiByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02367810
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceMulti_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti_NEW");
		
		UKismetSystemLibrary_LineTraceMulti_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02367D30
	 * 		Name   -> Function Engine.KismetSystemLibrary.LineTraceMulti_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_LineTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LineTraceMulti_DEPRECATED");
		
		UKismetSystemLibrary_LineTraceMulti_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368220
	 * 		Name   -> Function Engine.KismetSystemLibrary.LaunchURL
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_LaunchURL(const class FString& URL)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.LaunchURL");
		
		UKismetSystemLibrary_LaunchURL_Params params {};
		params.URL = URL;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368330
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_UnPauseTimer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_UnPauseTimer(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_UnPauseTimer");
		
		UKismetSystemLibrary_K2_UnPauseTimer_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023684E0
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_TimerExists
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_K2_TimerExists(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_TimerExists");
		
		UKismetSystemLibrary_K2_TimerExists_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023686A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimerForNextTickDelegate
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FScriptDelegate                              Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_SetTimerForNextTickDelegate(const class FScriptDelegate& Delegate, bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerForNextTickDelegate");
		
		UKismetSystemLibrary_K2_SetTimerForNextTickDelegate_Params params {};
		params.Delegate = Delegate;
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368810
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimerForNextTick
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_SetTimerForNextTick(class UObject* Object, const class FString& FunctionName, bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerForNextTick");
		
		UKismetSystemLibrary_K2_SetTimerForNextTick_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368A40
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FScriptDelegate                              Delegate                                                   (Parm, ZeroConstructor, NoDestructor)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_SetTimerDelegate(const class FScriptDelegate& Delegate, float Time, bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimerDelegate");
		
		UKismetSystemLibrary_K2_SetTimerDelegate_Params params {};
		params.Delegate = Delegate;
		params.Time = Time;
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368C40
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_SetTimer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 * 		float                                              Time                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bLooping                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_SetTimer(class UObject* Object, const class FString& FunctionName, float Time, bool bLooping)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_SetTimer");
		
		UKismetSystemLibrary_K2_SetTimer_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		params.Time = Time;
		params.bLooping = bLooping;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02368F10
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_PauseTimer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_PauseTimer(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_PauseTimer");
		
		UKismetSystemLibrary_K2_PauseTimer_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023690C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerPaused
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_K2_IsTimerPaused(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerPaused");
		
		UKismetSystemLibrary_K2_IsTimerPaused_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369280
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_IsTimerActive
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_K2_IsTimerActive(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_IsTimerActive");
		
		UKismetSystemLibrary_K2_IsTimerActive_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369440
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	float UKismetSystemLibrary::STATIC_K2_GetTimerRemainingTime(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime");
		
		UKismetSystemLibrary_K2_GetTimerRemainingTime_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369600
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	float UKismetSystemLibrary::STATIC_K2_GetTimerElapsedTime(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime");
		
		UKismetSystemLibrary_K2_GetTimerElapsedTime_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023697C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.K2_ClearTimer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      FunctionName                                               (Parm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_K2_ClearTimer(class UObject* Object, const class FString& FunctionName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.K2_ClearTimer");
		
		UKismetSystemLibrary_K2_ClearTimer_Params params {};
		params.Object = Object;
		params.FunctionName = FunctionName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369970
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsValid
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsValid(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsValid");
		
		UKismetSystemLibrary_IsValid_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369A50
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsStandalone
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsStandalone(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsStandalone");
		
		UKismetSystemLibrary_IsStandalone_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369B60
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsServer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsServer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsServer");
		
		UKismetSystemLibrary_IsServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369C70
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsRunningOnServer
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ENetworkModeResult                                 OutNetworkMode                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_IsRunningOnServer(class UObject* WorldContextObject, ENetworkModeResult* OutNetworkMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsRunningOnServer");
		
		UKismetSystemLibrary_IsRunningOnServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNetworkMode != nullptr)
			*OutNetworkMode = params.OutNetworkMode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E50BC0
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsPackagedForDistribution
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	bool UKismetSystemLibrary::STATIC_IsPackagedForDistribution()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsPackagedForDistribution");
		
		UKismetSystemLibrary_IsPackagedForDistribution_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369DF0
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsListenServer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsListenServer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsListenServer");
		
		UKismetSystemLibrary_IsListenServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02369F00
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsDedicatedServer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsDedicatedServer(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsDedicatedServer");
		
		UKismetSystemLibrary_IsDedicatedServer_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A010
	 * 		Name   -> Function Engine.KismetSystemLibrary.IsClient
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_IsClient(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.IsClient");
		
		UKismetSystemLibrary_IsClient_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A120
	 * 		Name   -> Function Engine.KismetSystemLibrary.HideAdBanner
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UKismetSystemLibrary::STATIC_HideAdBanner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.HideAdBanner");
		
		UKismetSystemLibrary_HideAdBanner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A190
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetUniqueDeviceId
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UKismetSystemLibrary::STATIC_GetUniqueDeviceId()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetUniqueDeviceId");
		
		UKismetSystemLibrary_GetUniqueDeviceId_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A260
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t UKismetSystemLibrary::STATIC_GetRenderingMaterialQualityLevel()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel");
		
		UKismetSystemLibrary_GetRenderingMaterialQualityLevel_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A290
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetRenderingDetailMode
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	int32_t UKismetSystemLibrary::STATIC_GetRenderingDetailMode()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetRenderingDetailMode");
		
		UKismetSystemLibrary_GetRenderingDetailMode_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A2C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetPlatformUserName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UKismetSystemLibrary::STATIC_GetPlatformUserName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetPlatformUserName");
		
		UKismetSystemLibrary_GetPlatformUserName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A390
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	double UKismetSystemLibrary::STATIC_GetGameTimeInSeconds(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameTimeInSeconds");
		
		UKismetSystemLibrary_GetGameTimeInSeconds_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A480
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetGameName
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UKismetSystemLibrary::STATIC_GetGameName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetGameName");
		
		UKismetSystemLibrary_GetGameName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A550
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetEngineVersion
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FString UKismetSystemLibrary::STATIC_GetEngineVersion()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetEngineVersion");
		
		UKismetSystemLibrary_GetEngineVersion_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A620
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetDisplayName
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     Object                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetSystemLibrary::STATIC_GetDisplayName(class UObject* Object)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetDisplayName");
		
		UKismetSystemLibrary_GetDisplayName_Params params {};
		params.Object = Object;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236A780
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetComponentBounds
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class USceneComponent*                             Component                                                  (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              SphereRadius                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_GetComponentBounds(class USceneComponent* Component, struct FVector* Origin, struct FVector* BoxExtent, float* SphereRadius)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetComponentBounds");
		
		UKismetSystemLibrary_GetComponentBounds_Params params {};
		params.Component = Component;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
		if (SphereRadius != nullptr)
			*SphereRadius = params.SphereRadius;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236AA00
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetClassDisplayName
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UClass*                                      Class                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UKismetSystemLibrary::STATIC_GetClassDisplayName(class UClass* Class)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetClassDisplayName");
		
		UKismetSystemLibrary_GetClassDisplayName_Params params {};
		params.Class = Class;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236AB60
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetActorListFromComponentList
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		TArray<class UPrimitiveComponent*>                 ComponentList                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              OutActorList                                               (Parm, OutParm, ZeroConstructor)
	 */
	void UKismetSystemLibrary::STATIC_GetActorListFromComponentList(TArray<class UPrimitiveComponent*> ComponentList, class UClass* ActorClassFilter, TArray<class AActor*>* OutActorList)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorListFromComponentList");
		
		UKismetSystemLibrary_GetActorListFromComponentList_Params params {};
		params.ComponentList = ComponentList;
		params.ActorClassFilter = ActorClassFilter;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActorList != nullptr)
			*OutActorList = params.OutActorList;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236AD20
	 * 		Name   -> Function Engine.KismetSystemLibrary.GetActorBounds
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class AActor*                                      Actor                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_GetActorBounds(class AActor* Actor, struct FVector* Origin, struct FVector* BoxExtent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.GetActorBounds");
		
		UKismetSystemLibrary_GetActorBounds_Params params {};
		params.Actor = Actor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Origin != nullptr)
			*Origin = params.Origin;
		if (BoxExtent != nullptr)
			*BoxExtent = params.BoxExtent;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236AEE0
	 * 		Name   -> Function Engine.KismetSystemLibrary.ForceCloseAdBanner
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UKismetSystemLibrary::STATIC_ForceCloseAdBanner()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ForceCloseAdBanner");
		
		UKismetSystemLibrary_ForceCloseAdBanner_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236AF50
	 * 		Name   -> Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_FlushPersistentDebugLines(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushPersistentDebugLines");
		
		UKismetSystemLibrary_FlushPersistentDebugLines_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236B050
	 * 		Name   -> Function Engine.KismetSystemLibrary.FlushDebugStrings
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_FlushDebugStrings(class UObject* WorldContextObject)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.FlushDebugStrings");
		
		UKismetSystemLibrary_FlushDebugStrings_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236B140
	 * 		Name   -> Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor)
	 * 		class APlayerController*                           SpecificPlayer                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_ExecuteConsoleCommand(class UObject* WorldContextObject, const class FString& Command, class APlayerController* SpecificPlayer)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ExecuteConsoleCommand");
		
		UKismetSystemLibrary_ExecuteConsoleCommand_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Command = Command;
		params.SpecificPlayer = SpecificPlayer;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236B3A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugString
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TextLocation                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Text                                                       (Parm, ZeroConstructor)
	 * 		class AActor*                                      TestBaseActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                TextColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugString(class UObject* WorldContextObject, const struct FVector& TextLocation, const class FString& Text, class AActor* TestBaseActor, const struct FLinearColor& TextColor, float Duration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugString");
		
		UKismetSystemLibrary_DrawDebugString_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.TextLocation = TextLocation;
		params.Text = Text;
		params.TestBaseActor = TestBaseActor;
		params.TextColor = TextColor;
		params.Duration = Duration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236B7A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugSphere
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugSphere(class UObject* WorldContextObject, const struct FVector& Center, float Radius, int32_t Segments, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugSphere");
		
		UKismetSystemLibrary_DrawDebugSphere_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236BBE0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugPoint
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Position                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                PointColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugPoint(class UObject* WorldContextObject, const struct FVector& Position, float Size, const struct FLinearColor& PointColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPoint");
		
		UKismetSystemLibrary_DrawDebugPoint_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Position = Position;
		params.Size = Size;
		params.PointColor = PointColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236BFA0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugPlane
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FPlane                                      PlaneCoordinates                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Location                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Size                                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                PlaneColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugPlane(class UObject* WorldContextObject, const struct FPlane& PlaneCoordinates, const struct FVector& Location, float Size, const struct FLinearColor& PlaneColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugPlane");
		
		UKismetSystemLibrary_DrawDebugPlane_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.PlaneCoordinates = PlaneCoordinates;
		params.Location = Location;
		params.Size = Size;
		params.PlaneColor = PlaneColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236C3F0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugLineTraceHitResult
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  Hit                                                        (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     TraceStart                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     TraceEnd                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                StartColor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                HitColor                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LineThickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HitSize                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDrawHitNormal                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                HitNormalColor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HitNormalLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugLineTraceHitResult(class UObject* WorldContextObject, const struct FHitResult& Hit, const struct FVector& TraceStart, const struct FVector& TraceEnd, const struct FLinearColor& StartColor, const struct FLinearColor& HitColor, float LineThickness, float HitSize, bool bDrawHitNormal, const struct FLinearColor& HitNormalColor, float HitNormalLength, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLineTraceHitResult");
		
		UKismetSystemLibrary_DrawDebugLineTraceHitResult_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Hit = Hit;
		params.TraceStart = TraceStart;
		params.TraceEnd = TraceEnd;
		params.StartColor = StartColor;
		params.HitColor = HitColor;
		params.LineThickness = LineThickness;
		params.HitSize = HitSize;
		params.bDrawHitNormal = bDrawHitNormal;
		params.HitNormalColor = HitNormalColor;
		params.HitNormalLength = HitNormalLength;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236CB10
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugLine
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugLine(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, const struct FLinearColor& LineColor, float Duration, float Thickness, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugLine");
		
		UKismetSystemLibrary_DrawDebugLine_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.Thickness = Thickness;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236D040
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFrustum
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  FrustumTransform                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                FrustumColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugFrustum(class UObject* WorldContextObject, const struct FTransform& FrustumTransform, const struct FLinearColor& FrustumColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFrustum");
		
		UKismetSystemLibrary_DrawDebugFrustum_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FrustumTransform = FrustumTransform;
		params.FrustumColor = FrustumColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236D330
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FTransform                                  DrawTransform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   DrawSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                DrawColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryTransform(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FTransform& DrawTransform, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform");
		
		UKismetSystemLibrary_DrawDebugFloatHistoryTransform_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FloatHistory = FloatHistory;
		params.DrawTransform = DrawTransform;
		params.DrawSize = DrawSize;
		params.DrawColor = DrawColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236D760
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		struct FVector                                     DrawLocation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   DrawSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                DrawColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugFloatHistoryLocation(class UObject* WorldContextObject, const struct FDebugFloatHistory& FloatHistory, const struct FVector& DrawLocation, const struct FVector2D& DrawSize, const struct FLinearColor& DrawColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation");
		
		UKismetSystemLibrary_DrawDebugFloatHistoryLocation_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.FloatHistory = FloatHistory;
		params.DrawLocation = DrawLocation;
		params.DrawSize = DrawSize;
		params.DrawColor = DrawColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236DC90
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCylinder
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCylinder(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, int32_t Segments, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCylinder");
		
		UKismetSystemLibrary_DrawDebugCylinder_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236E180
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     AxisLoc                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    AxisRot                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCoordinateSystem(class UObject* WorldContextObject, const struct FVector& AxisLoc, const struct FRotator& AxisRot, float Scale, float Thickness, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem");
		
		UKismetSystemLibrary_DrawDebugCoordinateSystem_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.AxisLoc = AxisLoc;
		params.AxisRot = AxisRot;
		params.Scale = Scale;
		params.Thickness = Thickness;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236E5D0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AngleWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AngleHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumSides                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugConeInDegrees(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees");
		
		UKismetSystemLibrary_DrawDebugConeInDegrees_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Origin = Origin;
		params.Direction = Direction;
		params.Length = Length;
		params.AngleWidth = AngleWidth;
		params.AngleHeight = AngleHeight;
		params.NumSides = NumSides;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236EBE0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCone
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Origin                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Direction                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Length                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AngleWidth                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              AngleHeight                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumSides                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              LifeTime                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCone(class UObject* WorldContextObject, const struct FVector& Origin, const struct FVector& Direction, float Length, float AngleWidth, float AngleHeight, int32_t NumSides, const struct FLinearColor& LineColor, float LifeTime, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCone");
		
		UKismetSystemLibrary_DrawDebugCone_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Origin = Origin;
		params.Direction = Direction;
		params.Length = Length;
		params.AngleWidth = AngleWidth;
		params.AngleHeight = AngleHeight;
		params.NumSides = NumSides;
		params.LineColor = LineColor;
		params.LifeTime = LifeTime;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236F1E0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCircle
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Segments                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCircle(class UObject* WorldContextObject, const struct FVector& Center, const struct FRotator& Rotation, float Radius, int32_t Segments, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCircle");
		
		UKismetSystemLibrary_DrawDebugCircle_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Rotation = Rotation;
		params.Radius = Radius;
		params.Segments = Segments;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236F670
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCapsuleWithExtents
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Top                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Bottom                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCapsuleWithExtents(class UObject* WorldContextObject, const struct FVector& Top, const struct FVector& Bottom, float Radius, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsuleWithExtents");
		
		UKismetSystemLibrary_DrawDebugCapsuleWithExtents_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Top = Top;
		params.Bottom = Bottom;
		params.Radius = Radius;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236FAB0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCapsule
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCapsule(class UObject* WorldContextObject, const struct FVector& Center, float HalfHeight, float Radius, const struct FRotator& Rotation, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCapsule");
		
		UKismetSystemLibrary_DrawDebugCapsule_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.HalfHeight = HalfHeight;
		params.Radius = Radius;
		params.Rotation = Rotation;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0236FFC0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugCamera
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class ACameraActor*                                CameraActor                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                CameraColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugCamera(class ACameraActor* CameraActor, const struct FLinearColor& CameraColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugCamera");
		
		UKismetSystemLibrary_DrawDebugCamera_Params params {};
		params.CameraActor = CameraActor;
		params.CameraColor = CameraColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370230
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugBox
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Center                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Rotation                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugBox(class UObject* WorldContextObject, const struct FVector& Center, const struct FVector& Extent, const struct FLinearColor& LineColor, const struct FRotator& Rotation, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugBox");
		
		UKismetSystemLibrary_DrawDebugBox_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Center = Center;
		params.Extent = Extent;
		params.LineColor = LineColor;
		params.Rotation = Rotation;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370750
	 * 		Name   -> Function Engine.KismetSystemLibrary.DrawDebugArrow
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineStart                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     LineEnd                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              ArrowSize                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                LineColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bPersistent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_DrawDebugArrow(class UObject* WorldContextObject, const struct FVector& LineStart, const struct FVector& LineEnd, float ArrowSize, const struct FLinearColor& LineColor, float Duration, bool bPersistent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DrawDebugArrow");
		
		UKismetSystemLibrary_DrawDebugArrow_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.LineStart = LineStart;
		params.LineEnd = LineEnd;
		params.ArrowSize = ArrowSize;
		params.LineColor = LineColor;
		params.Duration = Duration;
		params.bPersistent = bPersistent;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370BB0
	 * 		Name   -> Function Engine.KismetSystemLibrary.DoesImplementInterface
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class UObject*                                     TestObject                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      Interface                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_DoesImplementInterface(class UObject* TestObject, class UClass* Interface)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.DoesImplementInterface");
		
		UKismetSystemLibrary_DoesImplementInterface_Params params {};
		params.TestObject = TestObject;
		params.Interface = Interface;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370D00
	 * 		Name   -> Function Engine.KismetSystemLibrary.Delay
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Duration                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLatentActionInfo                           LatentInfo                                                 (Parm)
	 */
	void UKismetSystemLibrary::STATIC_Delay(class UObject* WorldContextObject, float Duration, const struct FLatentActionInfo& LatentInfo)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Delay");
		
		UKismetSystemLibrary_Delay_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Duration = Duration;
		params.LatentInfo = LatentInfo;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370F00
	 * 		Name   -> Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     ObjectToModify                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_CreateCopyForUndoBuffer(class UObject* ObjectToModify)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer");
		
		UKismetSystemLibrary_CreateCopyForUndoBuffer_Params params {};
		params.ObjectToModify = ObjectToModify;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02370FD0
	 * 		Name   -> Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 */
	class UObject* UKismetSystemLibrary::STATIC_Conv_InterfaceToObject()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.Conv_InterfaceToObject");
		
		UKismetSystemLibrary_Conv_InterfaceToObject_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E8ADB0
	 * 		Name   -> Function Engine.KismetSystemLibrary.ControlScreensaver
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bAllowScreenSaver                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_ControlScreensaver(bool bAllowScreenSaver)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ControlScreensaver");
		
		UKismetSystemLibrary_ControlScreensaver_Params params {};
		params.bAllowScreenSaver = bAllowScreenSaver;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02371090
	 * 		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapComponents_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents_NEW");
		
		UKismetSystemLibrary_ComponentOverlapComponents_NEW_Params params {};
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023713C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapComponents_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_ComponentOverlapComponents_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, EOverlapFilterOption Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapComponents_DEPRECATED");
		
		UKismetSystemLibrary_ComponentOverlapComponents_DEPRECATED_Params params {};
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02371700
	 * 		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapActors_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_NEW(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors_NEW");
		
		UKismetSystemLibrary_ComponentOverlapActors_NEW_Params params {};
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02371A30
	 * 		Name   -> Function Engine.KismetSystemLibrary.ComponentOverlapActors_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UPrimitiveComponent*                         Component                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FTransform                                  ComponentTransform                                         (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_ComponentOverlapActors_DEPRECATED(class UPrimitiveComponent* Component, const struct FTransform& ComponentTransform, EOverlapFilterOption Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.ComponentOverlapActors_DEPRECATED");
		
		UKismetSystemLibrary_ComponentOverlapActors_DEPRECATED_Params params {};
		params.Component = Component;
		params.ComponentTransform = ComponentTransform;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02371D70
	 * 		Name   -> Function Engine.KismetSystemLibrary.CollectGarbage
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 */
	void UKismetSystemLibrary::STATIC_CollectGarbage()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CollectGarbage");
		
		UKismetSystemLibrary_CollectGarbage_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02371D90
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects");
		
		UKismetSystemLibrary_CapsuleTraceSingleForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023723A0
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingleByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingleByObject_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleTraceSingleByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023729B0
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingle_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle_NEW");
		
		UKismetSystemLibrary_CapsuleTraceSingle_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02373000
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceSingle_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceSingle_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceSingle_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleTraceSingle_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02373600
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects");
		
		UKismetSystemLibrary_CapsuleTraceMultiForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02373C10
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<ECollisionChannel>                          ObjectsToTrace                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceMultiByObject_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, TArray<ECollisionChannel> ObjectsToTrace, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMultiByObject_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleTraceMultiByObject_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectsToTrace = ObjectsToTrace;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02374220
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMulti_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_NEW(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti_NEW");
		
		UKismetSystemLibrary_CapsuleTraceMulti_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02374870
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleTraceMulti_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ECollisionChannel                                  TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleTraceMulti_DEPRECATED(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ECollisionChannel TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleTraceMulti_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleTraceMulti_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02374E70
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_NEW");
		
		UKismetSystemLibrary_CapsuleOverlapComponents_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023752C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, EOverlapFilterOption Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapComponents_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleOverlapComponents_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02375720
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapActors_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors_NEW");
		
		UKismetSystemLibrary_CapsuleOverlapActors_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02375B70
	 * 		Name   -> Function Engine.KismetSystemLibrary.CapsuleOverlapActors_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     CapsulePos                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              HalfHeight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_CapsuleOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& CapsulePos, float Radius, float HalfHeight, EOverlapFilterOption Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CapsuleOverlapActors_DEPRECATED");
		
		UKismetSystemLibrary_CapsuleOverlapActors_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.CapsulePos = CapsulePos;
		params.Radius = Radius;
		params.HalfHeight = HalfHeight;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02375FD0
	 * 		Name   -> Function Engine.KismetSystemLibrary.CanRunCosmeticEvents
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ENetworkModeResult                                 OutNetworkMode                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UKismetSystemLibrary::STATIC_CanRunCosmeticEvents(class UObject* WorldContextObject, ENetworkModeResult* OutNetworkMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.CanRunCosmeticEvents");
		
		UKismetSystemLibrary_CanRunCosmeticEvents_Params params {};
		params.WorldContextObject = WorldContextObject;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutNetworkMode != nullptr)
			*OutNetworkMode = params.OutNetworkMode;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02376140
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxTraceSingleForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects");
		
		UKismetSystemLibrary_BoxTraceSingleForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02376770
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxTraceSingle
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FHitResult                                  OutHit                                                     (Parm, OutParm)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxTraceSingle(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceSingle");
		
		UKismetSystemLibrary_BoxTraceSingle_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHit != nullptr)
			*OutHit = params.OutHit;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02376D80
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HalfSize                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxTraceMultiForObjects(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, TArray<EObjectTypeQuery> ObjectTypes, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects");
		
		UKismetSystemLibrary_BoxTraceMultiForObjects_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.ObjectTypes = ObjectTypes;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023773B0
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxTraceMulti
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Start                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     End                                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     HalfSize                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FRotator                                    Orientation                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ETraceTypeQuery                                    TraceChannel                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bTraceComplex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		EDrawDebugTrace                                    DrawDebugType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FHitResult>                          OutHits                                                    (Parm, OutParm, ZeroConstructor)
	 * 		bool                                               bIgnoreSelf                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxTraceMulti(class UObject* WorldContextObject, const struct FVector& Start, const struct FVector& End, const struct FVector& HalfSize, const struct FRotator& Orientation, ETraceTypeQuery TraceChannel, bool bTraceComplex, TArray<class AActor*> ActorsToIgnore, EDrawDebugTrace DrawDebugType, TArray<struct FHitResult>* OutHits, bool bIgnoreSelf)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxTraceMulti");
		
		UKismetSystemLibrary_BoxTraceMulti_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.Start = Start;
		params.End = End;
		params.HalfSize = HalfSize;
		params.Orientation = Orientation;
		params.TraceChannel = TraceChannel;
		params.bTraceComplex = bTraceComplex;
		params.ActorsToIgnore = ActorsToIgnore;
		params.DrawDebugType = DrawDebugType;
		params.bIgnoreSelf = bIgnoreSelf;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutHits != nullptr)
			*OutHits = params.OutHits;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023779C0
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapComponents_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents_NEW");
		
		UKismetSystemLibrary_BoxOverlapComponents_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.Extent = Extent;
		params.ObjectTypes = ObjectTypes;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02377DA0
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapComponents_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     Extent                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ComponentClassFilter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class UPrimitiveComponent*>                 OutComponents                                              (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
	 */
	bool UKismetSystemLibrary::STATIC_BoxOverlapComponents_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& Extent, EOverlapFilterOption Filter, class UClass* ComponentClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class UPrimitiveComponent*>* OutComponents)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapComponents_DEPRECATED");
		
		UKismetSystemLibrary_BoxOverlapComponents_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.Extent = Extent;
		params.Filter = Filter;
		params.ComponentClassFilter = ComponentClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutComponents != nullptr)
			*OutComponents = params.OutComponents;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378190
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapActors_NEW
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<EObjectTypeQuery>                           ObjectTypes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxOverlapActors_NEW(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, TArray<EObjectTypeQuery> ObjectTypes, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors_NEW");
		
		UKismetSystemLibrary_BoxOverlapActors_NEW_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.BoxExtent = BoxExtent;
		params.ObjectTypes = ObjectTypes;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378570
	 * 		Name   -> Function Engine.KismetSystemLibrary.BoxOverlapActors_DEPRECATED
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UObject*                                     WorldContextObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxPos                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     BoxExtent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EOverlapFilterOption                               Filter                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UClass*                                      ActorClassFilter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<class AActor*>                              ActorsToIgnore                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		TArray<class AActor*>                              OutActors                                                  (Parm, OutParm, ZeroConstructor)
	 */
	bool UKismetSystemLibrary::STATIC_BoxOverlapActors_DEPRECATED(class UObject* WorldContextObject, const struct FVector& BoxPos, const struct FVector& BoxExtent, EOverlapFilterOption Filter, class UClass* ActorClassFilter, TArray<class AActor*> ActorsToIgnore, TArray<class AActor*>* OutActors)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BoxOverlapActors_DEPRECATED");
		
		UKismetSystemLibrary_BoxOverlapActors_DEPRECATED_Params params {};
		params.WorldContextObject = WorldContextObject;
		params.BoxPos = BoxPos;
		params.BoxExtent = BoxExtent;
		params.Filter = Filter;
		params.ActorClassFilter = ActorClassFilter;
		params.ActorsToIgnore = ActorsToIgnore;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutActors != nullptr)
			*OutActors = params.OutActors;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.KismetSystemLibrary.BlueprintTimerDynamicDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UKismetSystemLibrary::BlueprintTimerDynamicDelegate__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.BlueprintTimerDynamicDelegate__DelegateSignature");
		
		UKismetSystemLibrary_BlueprintTimerDynamicDelegate__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378960
	 * 		Name   -> Function Engine.KismetSystemLibrary.AddFloatHistorySample
	 * 		Flags  -> (Final, RequiredAPI, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FDebugFloatHistory                          FloatHistory                                               (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	struct FDebugFloatHistory UKismetSystemLibrary::STATIC_AddFloatHistorySample(float Value, const struct FDebugFloatHistory& FloatHistory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetSystemLibrary.AddFloatHistorySample");
		
		UKismetSystemLibrary_AddFloatHistorySample_Params params {};
		params.Value = Value;
		params.FloatHistory = FloatHistory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetSystemLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetSystemLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetSystemLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378D20
	 * 		Name   -> Function Engine.KismetTextLibrary.TextTrimTrailing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_TextTrimTrailing(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimTrailing");
		
		UKismetTextLibrary_TextTrimTrailing_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378E80
	 * 		Name   -> Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_TextTrimPrecedingAndTrailing(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing");
		
		UKismetTextLibrary_TextTrimPrecedingAndTrailing_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02378FE0
	 * 		Name   -> Function Engine.KismetTextLibrary.TextTrimPreceding
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_TextTrimPreceding(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextTrimPreceding");
		
		UKismetTextLibrary_TextTrimPreceding_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379140
	 * 		Name   -> Function Engine.KismetTextLibrary.TextIsTransient
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_TextIsTransient(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsTransient");
		
		UKismetTextLibrary_TextIsTransient_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379200
	 * 		Name   -> Function Engine.KismetTextLibrary.TextIsEmpty
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_TextIsEmpty(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsEmpty");
		
		UKismetTextLibrary_TextIsEmpty_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023792D0
	 * 		Name   -> Function Engine.KismetTextLibrary.TextIsCultureInvariant
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_TextIsCultureInvariant(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.TextIsCultureInvariant");
		
		UKismetTextLibrary_TextIsCultureInvariant_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379390
	 * 		Name   -> Function Engine.KismetTextLibrary.NotEqual_TextText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class FText                                        B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_NotEqual_TextText(const class FText& A, const class FText& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_TextText");
		
		UKismetTextLibrary_NotEqual_TextText_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x023794D0
	 * 		Name   -> Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class FText                                        B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_NotEqual_IgnoreCase_TextText(const class FText& A, const class FText& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText");
		
		UKismetTextLibrary_NotEqual_IgnoreCase_TextText_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379620
	 * 		Name   -> Function Engine.KismetTextLibrary.GetEmptyText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 */
	class FText UKismetTextLibrary::STATIC_GetEmptyText()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.GetEmptyText");
		
		UKismetTextLibrary_GetEmptyText_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379710
	 * 		Name   -> Function Engine.KismetTextLibrary.Format
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InPattern                                                  (Parm)
	 * 		TArray<struct FFormatTextArgument>                 InArgs                                                     (Parm, ZeroConstructor)
	 */
	class FText UKismetTextLibrary::STATIC_Format(const class FText& InPattern, TArray<struct FFormatTextArgument> InArgs)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Format");
		
		UKismetTextLibrary_Format_Params params {};
		params.InPattern = InPattern;
		params.InArgs = InArgs;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379A30
	 * 		Name   -> Function Engine.KismetTextLibrary.FindTextInLocalizationTable
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      Namespace                                                  (Parm, ZeroConstructor)
	 * 		class FString                                      Key                                                        (Parm, ZeroConstructor)
	 * 		class FText                                        OutText                                                    (Parm, OutParm)
	 */
	bool UKismetTextLibrary::STATIC_FindTextInLocalizationTable(const class FString& Namespace, const class FString& Key, class FText* OutText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.FindTextInLocalizationTable");
		
		UKismetTextLibrary_FindTextInLocalizationTable_Params params {};
		params.Namespace = Namespace;
		params.Key = Key;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (OutText != nullptr)
			*OutText = params.OutText;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379C70
	 * 		Name   -> Function Engine.KismetTextLibrary.EqualEqual_TextText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class FText                                        B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_EqualEqual_TextText(const class FText& A, const class FText& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_TextText");
		
		UKismetTextLibrary_EqualEqual_TextText_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379DB0
	 * 		Name   -> Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        A                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 * 		class FText                                        B                                                          (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	bool UKismetTextLibrary::STATIC_EqualEqual_IgnoreCase_TextText(const class FText& A, const class FText& B)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText");
		
		UKismetTextLibrary_EqualEqual_IgnoreCase_TextText_Params params {};
		params.A = A;
		params.B = B;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02379F00
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_TextToString
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FText                                        InText                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	class FString UKismetTextLibrary::STATIC_Conv_TextToString(const class FText& InText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_TextToString");
		
		UKismetTextLibrary_Conv_TextToString_Params params {};
		params.InText = InText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237A050
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_StringToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FString                                      InString                                                   (Parm, ZeroConstructor)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_StringToText(const class FString& InString)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_StringToText");
		
		UKismetTextLibrary_Conv_StringToText_Params params {};
		params.InString = InString;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237A200
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_NameToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		class FName                                        InName                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_NameToText(const class FName& InName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_NameToText");
		
		UKismetTextLibrary_Conv_NameToText_Params params {};
		params.InName = InName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237A380
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_IntToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_IntToText(int32_t Value, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_IntToText");
		
		UKismetTextLibrary_Conv_IntToText_Params params {};
		params.Value = Value;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237A6B0
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_FloatToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERoundingMode                                      RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_FloatToText(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_FloatToText");
		
		UKismetTextLibrary_Conv_FloatToText_Params params {};
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237AB60
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_ByteToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		unsigned char                                      Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_ByteToText(unsigned char Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_ByteToText");
		
		UKismetTextLibrary_Conv_ByteToText_Params params {};
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237ACD0
	 * 		Name   -> Function Engine.KismetTextLibrary.Conv_BoolToText
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		bool                                               InBool                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FText UKismetTextLibrary::STATIC_Conv_BoolToText(bool InBool)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.Conv_BoolToText");
		
		UKismetTextLibrary_Conv_BoolToText_Params params {};
		params.InBool = InBool;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237AE50
	 * 		Name   -> Function Engine.KismetTextLibrary.AsTimespan_Timespan
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FTimespan                                   InTimespan                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_AsTimespan_Timespan(const struct FTimespan& InTimespan)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTimespan_Timespan");
		
		UKismetTextLibrary_AsTimespan_Timespan_Params params {};
		params.InTimespan = InTimespan;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237AFB0
	 * 		Name   -> Function Engine.KismetTextLibrary.AsTime_DateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   In                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_AsTime_DateTime(const struct FDateTime& In)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsTime_DateTime");
		
		UKismetTextLibrary_AsTime_DateTime_Params params {};
		params.In = In;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237B110
	 * 		Name   -> Function Engine.KismetTextLibrary.AsPercent_Float
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERoundingMode                                      RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 */
	class FText UKismetTextLibrary::STATIC_AsPercent_Float(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsPercent_Float");
		
		UKismetTextLibrary_AsPercent_Float_Params params {};
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237B5C0
	 * 		Name   -> Function Engine.KismetTextLibrary.AsDateTime_DateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   In                                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_AsDateTime_DateTime(const struct FDateTime& In)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDateTime_DateTime");
		
		UKismetTextLibrary_AsDateTime_DateTime_Params params {};
		params.In = In;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237B720
	 * 		Name   -> Function Engine.KismetTextLibrary.AsDate_DateTime
	 * 		Flags  -> (Final, Native, Static, Public, HasOutParms, HasDefaults, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		struct FDateTime                                   InDateTime                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 */
	class FText UKismetTextLibrary::STATIC_AsDate_DateTime(const struct FDateTime& InDateTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsDate_DateTime");
		
		UKismetTextLibrary_AsDate_DateTime_Params params {};
		params.InDateTime = InDateTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237B880
	 * 		Name   -> Function Engine.KismetTextLibrary.AsCurrency_Integer
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		int32_t                                            Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERoundingMode                                      RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class FString                                      CurrencyCode                                               (Parm, ZeroConstructor, AdvancedDisplay)
	 */
	class FText UKismetTextLibrary::STATIC_AsCurrency_Integer(int32_t Value, ERoundingMode RoundingMode, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, const class FString& CurrencyCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Integer");
		
		UKismetTextLibrary_AsCurrency_Integer_Params params {};
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		params.CurrencyCode = CurrencyCode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237BDF0
	 * 		Name   -> Function Engine.KismetTextLibrary.AsCurrency_Float
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
	 * Parameters:
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ERoundingMode                                      RoundingMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		bool                                               bUseGrouping                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumIntegralDigits                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MinimumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		int32_t                                            MaximumFractionalDigits                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay)
	 * 		class FString                                      CurrencyCode                                               (Parm, ZeroConstructor, AdvancedDisplay)
	 */
	class FText UKismetTextLibrary::STATIC_AsCurrency_Float(float Value, ERoundingMode RoundingMode, bool bUseGrouping, int32_t MinimumIntegralDigits, int32_t MaximumIntegralDigits, int32_t MinimumFractionalDigits, int32_t MaximumFractionalDigits, const class FString& CurrencyCode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.KismetTextLibrary.AsCurrency_Float");
		
		UKismetTextLibrary_AsCurrency_Float_Params params {};
		params.Value = Value;
		params.RoundingMode = RoundingMode;
		params.bUseGrouping = bUseGrouping;
		params.MinimumIntegralDigits = MinimumIntegralDigits;
		params.MaximumIntegralDigits = MaximumIntegralDigits;
		params.MinimumFractionalDigits = MinimumFractionalDigits;
		params.MaximumFractionalDigits = MaximumFractionalDigits;
		params.CurrencyCode = CurrencyCode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UKismetTextLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UKismetTextLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.KismetTextLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UAnimBlueprintGeneratedClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UAnimBlueprintGeneratedClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.AnimBlueprintGeneratedClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBodySetup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBodySetup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BodySetup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBodySetup2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBodySetup2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BodySetup2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBoneMaskFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBoneMaskFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BoneMaskFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBookMark.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBookMark::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BookMark");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBookMark2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBookMark2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BookMark2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBreakpoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBreakpoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Breakpoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBrushBuilder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBrushBuilder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BrushBuilder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UButtonStyleAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UButtonStyleAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ButtonStyleAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraAnim.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraAnim::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraAnim");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715800
	 * 		Name   -> Function Engine.CameraAnimInst.Stop
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bImmediate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCameraAnimInst::Stop(bool bImmediate)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.Stop");
		
		UCameraAnimInst_Stop_Params params {};
		params.bImmediate = bImmediate;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02715910
	 * 		Name   -> Function Engine.CameraAnimInst.SetDuration
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		float                                              NewDuration                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCameraAnimInst::SetDuration(float NewDuration)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CameraAnimInst.SetDuration");
		
		UCameraAnimInst_SetDuration_Params params {};
		params.NewDuration = NewDuration;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraAnimInst.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraAnimInst::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraAnimInst");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraModifier_CameraShake.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraModifier_CameraShake::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraModifier_CameraShake");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCameraShake.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCameraShake::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CameraShake");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711BC0
	 * 		Name   -> Function Engine.Canvas.SetDrawColor
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FColor                                      C                                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::SetDrawColor(const struct FColor& C)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.SetDrawColor");
		
		UCanvas_SetDrawColor_Params params {};
		params.C = C;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711C80
	 * 		Name   -> Function Engine.Canvas.K2_TextSize
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      RenderText                                                 (Parm, ZeroConstructor)
	 * 		struct FVector2D                                   Scale                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector2D UCanvas::K2_TextSize(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& Scale)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_TextSize");
		
		UCanvas_K2_TextSize_Params params {};
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;
		params.Scale = Scale;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02711EA0
	 * 		Name   -> Function Engine.Canvas.K2_StrLen
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      RenderText                                                 (Parm, ZeroConstructor)
	 */
	struct FVector2D UCanvas::K2_StrLen(class UFont* RenderFont, const class FString& RenderText)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_StrLen");
		
		UCanvas_K2_StrLen_Params params {};
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027120E0
	 * 		Name   -> Function Engine.Canvas.K2_Project
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UCanvas::K2_Project(const struct FVector& WorldLocation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Project");
		
		UCanvas_K2_Project_Params params {};
		params.WorldLocation = WorldLocation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027122F0
	 * 		Name   -> Function Engine.Canvas.K2_DrawTriangle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		TArray<struct FCanvasUVTri>                        Triangles                                                  (Parm, ZeroConstructor)
	 */
	void UCanvas::K2_DrawTriangle(class UTexture* RenderTexture, TArray<struct FCanvasUVTri> Triangles)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTriangle");
		
		UCanvas_K2_DrawTriangle_Params params {};
		params.RenderTexture = RenderTexture;
		params.Triangles = Triangles;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02712500
	 * 		Name   -> Function Engine.Canvas.K2_DrawTexture
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBlendMode                                         BlendMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawTexture(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, EBlendMode BlendMode, float Rotation, const struct FVector2D& PivotPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawTexture");
		
		UCanvas_K2_DrawTexture_Params params {};
		params.RenderTexture = RenderTexture;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.RenderColor = RenderColor;
		params.BlendMode = BlendMode;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02712A40
	 * 		Name   -> Function Engine.Canvas.K2_DrawText
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       RenderFont                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      RenderText                                                 (Parm, ZeroConstructor)
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Kerning                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                ShadowColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ShadowOffset                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bCentreX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bCentreY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bOutlined                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                OutlineColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawText(class UFont* RenderFont, const class FString& RenderText, const struct FVector2D& ScreenPosition, const struct FLinearColor& RenderColor, float Kerning, const struct FLinearColor& ShadowColor, const struct FVector2D& ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, const struct FLinearColor& OutlineColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawText");
		
		UCanvas_K2_DrawText_Params params {};
		params.RenderFont = RenderFont;
		params.RenderText = RenderText;
		params.ScreenPosition = ScreenPosition;
		params.RenderColor = RenderColor;
		params.Kerning = Kerning;
		params.ShadowColor = ShadowColor;
		params.ShadowOffset = ShadowOffset;
		params.bCentreX = bCentreX;
		params.bCentreY = bCentreY;
		params.bOutlined = bOutlined;
		params.OutlineColor = OutlineColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02713180
	 * 		Name   -> Function Engine.Canvas.K2_DrawPolygon
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    RenderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   Radius                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            NumberOfSides                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawPolygon(class UTexture* RenderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& Radius, int32_t NumberOfSides, const struct FLinearColor& RenderColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawPolygon");
		
		UCanvas_K2_DrawPolygon_Params params {};
		params.RenderTexture = RenderTexture;
		params.ScreenPosition = ScreenPosition;
		params.Radius = Radius;
		params.NumberOfSides = NumberOfSides;
		params.RenderColor = RenderColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02713490
	 * 		Name   -> Function Engine.Canvas.K2_DrawMaterial
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          RenderMaterial                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawMaterial(class UMaterialInterface* RenderMaterial, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, float Rotation, const struct FVector2D& PivotPoint)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawMaterial");
		
		UCanvas_K2_DrawMaterial_Params params {};
		params.RenderMaterial = RenderMaterial;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027138B0
	 * 		Name   -> Function Engine.Canvas.K2_DrawLine
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   ScreenPositionA                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenPositionB                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawLine(const struct FVector2D& ScreenPositionA, const struct FVector2D& ScreenPositionB, float Thickness, const struct FLinearColor& RenderColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawLine");
		
		UCanvas_K2_DrawLine_Params params {};
		params.ScreenPositionA = ScreenPositionA;
		params.ScreenPositionB = ScreenPositionB;
		params.Thickness = Thickness;
		params.RenderColor = RenderColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02713B20
	 * 		Name   -> Function Engine.Canvas.K2_DrawBoxEx
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		EBlendMode                                         BlendMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawBoxEx(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness, const struct FLinearColor& RenderColor, EBlendMode BlendMode)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBoxEx");
		
		UCanvas_K2_DrawBoxEx_Params params {};
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.Thickness = Thickness;
		params.RenderColor = RenderColor;
		params.BlendMode = BlendMode;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02713E10
	 * 		Name   -> Function Engine.Canvas.K2_DrawBox
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Thickness                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawBox(const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, float Thickness)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBox");
		
		UCanvas_K2_DrawBox_Params params {};
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.Thickness = Thickness;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02713FE0
	 * 		Name   -> Function Engine.Canvas.K2_DrawBorder
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UTexture*                                    BorderTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    BackgroundTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    LeftBorderTexture                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    RightBorderTexture                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    TopBorderTexture                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    BottomBorderTexture                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   ScreenSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinatePosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CoordinateSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                RenderColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   BorderScale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   BackgroundScale                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Rotation                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   PivotPoint                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   CornerSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, const struct FVector2D& ScreenPosition, const struct FVector2D& ScreenSize, const struct FVector2D& CoordinatePosition, const struct FVector2D& CoordinateSize, const struct FLinearColor& RenderColor, const struct FVector2D& BorderScale, const struct FVector2D& BackgroundScale, float Rotation, const struct FVector2D& PivotPoint, const struct FVector2D& CornerSize)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_DrawBorder");
		
		UCanvas_K2_DrawBorder_Params params {};
		params.BorderTexture = BorderTexture;
		params.BackgroundTexture = BackgroundTexture;
		params.LeftBorderTexture = LeftBorderTexture;
		params.RightBorderTexture = RightBorderTexture;
		params.TopBorderTexture = TopBorderTexture;
		params.BottomBorderTexture = BottomBorderTexture;
		params.ScreenPosition = ScreenPosition;
		params.ScreenSize = ScreenSize;
		params.CoordinatePosition = CoordinatePosition;
		params.CoordinateSize = CoordinateSize;
		params.RenderColor = RenderColor;
		params.BorderScale = BorderScale;
		params.BackgroundScale = BackgroundScale;
		params.Rotation = Rotation;
		params.PivotPoint = PivotPoint;
		params.CornerSize = CornerSize;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02714890
	 * 		Name   -> Function Engine.Canvas.K2_Deproject
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		struct FVector2D                                   ScreenPosition                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldOrigin                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldDirection                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvas::K2_Deproject(const struct FVector2D& ScreenPosition, struct FVector* WorldOrigin, struct FVector* WorldDirection)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.K2_Deproject");
		
		UCanvas_K2_Deproject_Params params {};
		params.ScreenPosition = ScreenPosition;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (WorldOrigin != nullptr)
			*WorldOrigin = params.WorldOrigin;
		if (WorldDirection != nullptr)
			*WorldDirection = params.WorldDirection;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02714AA0
	 * 		Name   -> Function Engine.Canvas.IsPositionInFrontOfViewport
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		struct FVector                                     Location                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UCanvas::IsPositionInFrontOfViewport(const struct FVector& Location)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.IsPositionInFrontOfViewport");
		
		UCanvas_IsPositionInFrontOfViewport_Params params {};
		params.Location = Location;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x02714C10
	 * 		Name   -> Function Engine.Canvas.BPDrawTextWrapped
	 * 		Flags  -> (Final, Native, Public, HasOutParms, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       InFont                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      InText                                                     (Parm, ZeroConstructor)
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              XWidth                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              YWidth                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              XScale                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              YScale                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoCenterX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoCenterY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector2D                                   SpacingAdjust                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
	 */
	float UCanvas::BPDrawTextWrapped(class UFont* InFont, const class FString& InText, float X, float Y, float XWidth, float YWidth, float XScale, float YScale, bool bDoCenterX, bool bDoCenterY, const struct FVector2D& SpacingAdjust)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.BPDrawTextWrapped");
		
		UCanvas_BPDrawTextWrapped_Params params {};
		params.InFont = InFont;
		params.InText = InText;
		params.X = X;
		params.Y = Y;
		params.XWidth = XWidth;
		params.YWidth = YWidth;
		params.XScale = XScale;
		params.YScale = YScale;
		params.bDoCenterX = bDoCenterX;
		params.bDoCenterY = bDoCenterY;
		params.SpacingAdjust = SpacingAdjust;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x027152E0
	 * 		Name   -> Function Engine.Canvas.BPDrawTextCentered
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UFont*                                       InFont                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      InText                                                     (Parm, ZeroConstructor)
	 * 		float                                              X                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Y                                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              XScale                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              YScale                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoCenterX                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bDoCenterY                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UCanvas::BPDrawTextCentered(class UFont* InFont, const class FString& InText, float X, float Y, float XScale, float YScale, bool bDoCenterX, bool bDoCenterY)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Canvas.BPDrawTextCentered");
		
		UCanvas_BPDrawTextCentered_Params params {};
		params.InFont = InFont;
		params.InText = InText;
		params.X = X;
		params.Y = Y;
		params.XScale = XScale;
		params.YScale = YScale;
		params.bDoCenterX = bDoCenterX;
		params.bDoCenterY = bDoCenterY;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanvas.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanvas::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Canvas");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Channel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UActorChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UActorChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ActorChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UBattlEyeChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UBattlEyeChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.BattlEyeChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClassInfoChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClassInfoChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ClassInfoChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UControlChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UControlChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ControlChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVoiceChannel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVoiceChannel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VoiceChannel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCheckBoxStyleAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCheckBoxStyleAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CheckBoxStyleAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UClipPadEntry.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UClipPadEntry::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ClipPadEntry");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCollisionProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCollisionProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CollisionProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCommandlet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCommandlet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Commandlet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USmokeTestCommandlet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USmokeTestCommandlet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SmokeTestCommandlet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UConsole.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UConsole::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Console");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FEF0
	 * 		Name   -> Function Engine.CurveLinearColor.GetLinearColorValue
	 * 		Flags  -> (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UCurveLinearColor::GetLinearColorValue(float InTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CurveLinearColor.GetLinearColorValue");
		
		UCurveLinearColor_GetLinearColorValue_Params params {};
		params.InTime = InTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveLinearColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveLinearColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveLinearColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FDA0
	 * 		Name   -> Function Engine.CurveVector.GetVectorValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		float                                              InTime                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FVector UCurveVector::GetVectorValue(float InTime)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CurveVector.GetVectorValue");
		
		UCurveVector_GetVectorValue_Params params {};
		params.InTime = InTime;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveVector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveVector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveVector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveEdPresetCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveEdPresetCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveEdPresetCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCurveTable.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCurveTable::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CurveTable");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTireType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTireType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TireType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDestructibleFractureSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDestructibleFractureSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DestructibleFractureSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeviceProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeviceProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DeviceProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDeviceProfileManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDeviceProfileManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DeviceProfileManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDialogueVoice.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDialogueVoice::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DialogueVoice");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDialogueWave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDialogueWave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DialogueWave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistribution.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistribution::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Distribution");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloat.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloat::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloat");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatParameterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatParameterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatParameterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatParticleParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatParticleParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatParticleParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatSoundParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatSoundParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatSoundParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatConstantCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatConstantCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatConstantCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatUniform.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatUniform::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatUniform");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionFloatUniformCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionFloatUniformCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionFloatUniformCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorParameterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorParameterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorParameterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorParticleParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorParticleParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorParticleParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorConstantCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorConstantCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorConstantCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorUniform.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorUniform::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorUniform");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDistributionVectorUniformCurve.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDistributionVectorUniformCurve::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DistributionVectorUniformCurve");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicBlueprintBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicBlueprintBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DynamicBlueprintBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UComponentDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UComponentDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ComponentDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputActionDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputActionDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputActionDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputAxisDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputAxisDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputAxisDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputAxisKeyDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputAxisKeyDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputAxisKeyDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputVectorAxisDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputVectorAxisDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputVectorAxisDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputKeyDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputKeyDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputKeyDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputTouchDelegateBinding.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputTouchDelegateBinding::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputTouchDelegateBinding");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDynamicCaptureData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDynamicCaptureData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DynamicCaptureData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraphNode_Comment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraphNode_Comment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraphNode_Comment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraphNode_Documentation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraphNode_Documentation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraphNode_Documentation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEdGraphSchema.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEdGraphSchema::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EdGraphSchema");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UExporter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UExporter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Exporter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageAttachedComponentInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageAttachedComponentInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FoliageAttachedComponentInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageType.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageType::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FoliageType");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFoliageType_InstancedStaticMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFoliageType_InstancedStaticMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FoliageType_InstancedStaticMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFontImportOptions.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFontImportOptions::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.FontImportOptions");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UFont.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UFont::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Font");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F5D0
	 * 		Name   -> Function Engine.PlayerInput.SetMouseSensitivityToDefault
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UPlayerInput::SetMouseSensitivityToDefault()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivityToDefault");
		
		UPlayerInput_SetMouseSensitivityToDefault_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F5F0
	 * 		Name   -> Function Engine.PlayerInput.SetMouseSensitivity
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		float                                              Sensitivity                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPlayerInput::SetMouseSensitivity(float Sensitivity)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetMouseSensitivity");
		
		UPlayerInput_SetMouseSensitivity_Params params {};
		params.Sensitivity = Sensitivity;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F6C0
	 * 		Name   -> Function Engine.PlayerInput.SetBind
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        BindName                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Command                                                    (Parm, ZeroConstructor)
	 */
	void UPlayerInput::SetBind(const class FName& BindName, const class FString& Command)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.SetBind");
		
		UPlayerInput_SetBind_Params params {};
		params.BindName = BindName;
		params.Command = Command;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F840
	 * 		Name   -> Function Engine.PlayerInput.InvertMouse
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UPlayerInput::InvertMouse()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertMouse");
		
		UPlayerInput_InvertMouse_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F8A0
	 * 		Name   -> Function Engine.PlayerInput.InvertAxisKey
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		struct FKey                                        AxisKey                                                    (ConstParm, Parm)
	 */
	void UPlayerInput::InvertAxisKey(const struct FKey& AxisKey)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxisKey");
		
		UPlayerInput_InvertAxisKey_Params params {};
		params.AxisKey = AxisKey;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F9D0
	 * 		Name   -> Function Engine.PlayerInput.InvertAxis
	 * 		Flags  -> (Final, Exec, Native, Public)
	 * Parameters:
	 * 		class FName                                        AxisName                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UPlayerInput::InvertAxis(const class FName& AxisName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.InvertAxis");
		
		UPlayerInput_InvertAxis_Params params {};
		params.AxisName = AxisName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270FAA0
	 * 		Name   -> Function Engine.PlayerInput.ClearSmoothing
	 * 		Flags  -> (Final, Exec, Native, Public)
	 */
	void UPlayerInput::ClearSmoothing()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlayerInput.ClearSmoothing");
		
		UPlayerInput_ClearSmoothing_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlayerInput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlayerInput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlayerInput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInputSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInputSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InputSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpCurveEdSetup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpCurveEdSetup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpCurveEdSetup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpFilter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpFilter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpFilter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpFilter_Classes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpFilter_Classes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpFilter_Classes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpFilter_Custom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpFilter_Custom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpFilter_Custom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroup.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroup::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroup");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroupCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroupCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroupCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroupDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroupDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroupDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroupInst.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroupInst::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroupInst");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroupInstCamera.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroupInstCamera::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroupInstCamera");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpGroupInstDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpGroupInstDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpGroupInstDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrack.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrack::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrack");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackBoolProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackBoolProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackBoolProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackFloatBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackFloatBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackFloatBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackAnimControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackAnimControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackAnimControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackFloatMaterialParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackFloatMaterialParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackFloatMaterialParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackFloatParticleParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackFloatParticleParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackFloatParticleParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackFloatProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackFloatProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackFloatProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackMoveAxis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackMoveAxis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackMoveAxis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackSlomo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackSlomo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackSlomo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackLinearColorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackLinearColorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackLinearColorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackLinearColorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackLinearColorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackLinearColorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackParticleReplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackParticleReplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackParticleReplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackToggle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackToggle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackToggle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackVectorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackVectorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackVectorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackAudioMaster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackAudioMaster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackAudioMaster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackColorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackColorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackColorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackColorScale.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackColorScale::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackColorScale");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackVectorMaterialParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackVectorMaterialParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackVectorMaterialParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackVectorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackVectorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackVectorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackVisibility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackVisibility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackVisibility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInst.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInst::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInst");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstAnimControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstAnimControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstAnimControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstAudioMaster.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstAudioMaster::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstAudioMaster");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstColorScale.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstColorScale::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstColorScale");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstDirector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstDirector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstDirector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstEvent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstEvent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstEvent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstFloatMaterialParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstFloatMaterialParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstFloatMaterialParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstFloatParticleParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstFloatParticleParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstFloatParticleParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstMove.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstMove::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstMove");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstParticleReplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstParticleReplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstParticleReplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstProperty.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstProperty::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstProperty");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstBoolProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstBoolProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstBoolProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstColorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstColorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstColorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstFloatProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstFloatProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstFloatProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstLinearColorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstLinearColorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstLinearColorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstVectorProp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstVectorProp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstVectorProp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstSlomo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstSlomo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstSlomo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstSound.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstSound::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstSound");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstToggle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstToggle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstToggle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstVectorMaterialParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstVectorMaterialParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstVectorMaterialParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInterpTrackInstVisibility.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInterpTrackInstVisibility::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InterpTrackInstVisibility");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UIntSerialization.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UIntSerialization::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.IntSerialization");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeLayerInfoObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeLayerInfoObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeLayerInfoObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeSplineSegment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeSplineSegment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeSplineSegment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeSplineControlPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeSplineControlPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeSplineControlPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Layer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.LevelStreaming.LevelStreamingVisibilityStatus__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void ULevelStreaming::LevelStreamingVisibilityStatus__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.LevelStreamingVisibilityStatus__DelegateSignature");
		
		ULevelStreaming_LevelStreamingVisibilityStatus__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.LevelStreaming.LevelStreamingLoadedStatus__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 */
	void ULevelStreaming::LevelStreamingLoadedStatus__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.LevelStreamingLoadedStatus__DelegateSignature");
		
		ULevelStreaming_LevelStreamingLoadedStatus__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F1D0
	 * 		Name   -> Function Engine.LevelStreaming.IsTileStreamingEnabled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ULevelStreaming::IsTileStreamingEnabled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsTileStreamingEnabled");
		
		ULevelStreaming_IsTileStreamingEnabled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F1F0
	 * 		Name   -> Function Engine.LevelStreaming.IsLevelVisible
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ULevelStreaming::IsLevelVisible()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelVisible");
		
		ULevelStreaming_IsLevelVisible_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F230
	 * 		Name   -> Function Engine.LevelStreaming.IsLevelLoaded
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool ULevelStreaming::IsLevelLoaded()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.IsLevelLoaded");
		
		ULevelStreaming_IsLevelLoaded_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F260
	 * 		Name   -> Function Engine.LevelStreaming.CreateInstance
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FString                                      UniqueInstanceName                                         (Parm, ZeroConstructor)
	 */
	class ULevelStreaming* ULevelStreaming::CreateInstance(const class FString& UniqueInstanceName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.CreateInstance");
		
		ULevelStreaming_CreateInstance_Params params {};
		params.UniqueInstanceName = UniqueInstanceName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F3A0
	 * 		Name   -> Function Engine.LevelStreaming.BPSetLevelVisibility
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bVisible                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		bool                                               bIsLowMemory                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void ULevelStreaming::BPSetLevelVisibility(bool bVisible, bool bIsLowMemory)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.BPSetLevelVisibility");
		
		ULevelStreaming_BPSetLevelVisibility_Params params {};
		params.bVisible = bVisible;
		params.bIsLowMemory = bIsLowMemory;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F500
	 * 		Name   -> Function Engine.LevelStreaming.BPGetPackageName
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString ULevelStreaming::BPGetPackageName()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.LevelStreaming.BPGetPackageName");
		
		ULevelStreaming_BPGetPackageName_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelStreaming.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelStreaming::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreaming");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelStreamingAlwaysLoaded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelStreamingAlwaysLoaded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreamingAlwaysLoaded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelStreamingBounds.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelStreamingBounds::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreamingBounds");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelStreamingKismet.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelStreamingKismet::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreamingKismet");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULevelStreamingPersistent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULevelStreamingPersistent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LevelStreamingPersistent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightmappedSurfaceCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightmappedSurfaceCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightmappedSurfaceCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightmassPrimitiveSettingsObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightmassPrimitiveSettingsObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightmassPrimitiveSettingsObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULocalMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULocalMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LocalMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UEngineMessage.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UEngineMessage::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.EngineMessage");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpression.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpression::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpression");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionAbs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionAbs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionAbs");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionActorPositionWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionActorPositionWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionActorPositionWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionAdd.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionAdd::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionAdd");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionAppendVector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionAppendVector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionAppendVector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionAtmosphericFogColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionAtmosphericFogColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionAtmosphericFogColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionBlackBody.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionBlackBody::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionBlackBody");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionBreakMaterialAttributes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionBreakMaterialAttributes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionBreakMaterialAttributes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionBumpOffset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionBumpOffset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionBumpOffset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCameraPositionWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCameraPositionWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCameraPositionWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCameraVectorWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCameraVectorWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCameraVectorWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCeil.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCeil::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCeil");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionClamp.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionClamp::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionClamp");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCollectionParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCollectionParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCollectionParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionComment.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionComment::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionComment");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionComponentMask.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionComponentMask::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionComponentMask");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionConstant2Vector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionConstant2Vector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionConstant2Vector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionConstant3Vector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionConstant3Vector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionConstant3Vector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionConstant4Vector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionConstant4Vector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionConstant4Vector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionConstantBiasScale.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionConstantBiasScale::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionConstantBiasScale");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCosine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCosine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCosine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCrossProduct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCrossProduct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCrossProduct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCustom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCustom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCustom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionCustomTexture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionCustomTexture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionCustomTexture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDDX.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDDX::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDDX");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDDY.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDDY::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDDY");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDepthFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDepthFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDepthFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDepthOfFieldFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDepthOfFieldFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDepthOfFieldFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDeriveNormalZ.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDeriveNormalZ::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDeriveNormalZ");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDesaturation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDesaturation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDesaturation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDistance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDistance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDistance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDistanceCullFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDistanceCullFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDistanceCullFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDistanceFieldGradient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDistanceFieldGradient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDistanceFieldGradient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDistanceToNearestSurface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDistanceToNearestSurface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDistanceToNearestSurface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDivide.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDivide::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDivide");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDotProduct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDotProduct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDotProduct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionDynamicParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionDynamicParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionDynamicParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionEyeAdaptation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionEyeAdaptation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionEyeAdaptation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFeatureLevelSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFeatureLevelSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFeatureLevelSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFloor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFloor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFloor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFmod.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFmod::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFmod");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFontSample.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFontSample::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFontSample");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFontSampleParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFontSampleParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFontSampleParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFrac.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFrac::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFrac");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFresnel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFresnel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFresnel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFunctionInput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFunctionInput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFunctionInput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionFunctionOutput.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionFunctionOutput::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionFunctionOutput");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionGIReplace.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionGIReplace::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionGIReplace");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionIf.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionIf::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionIf");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeLayerBlend.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeLayerBlend::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeLayerBlend");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeLayerCoords.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeLayerCoords::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeLayerCoords");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeLayerSample.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeLayerSample::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeLayerSample");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeLayerSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeLayerSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeLayerSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeLayerWeight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeLayerWeight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeLayerWeight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLandscapeVisibilityMask.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLandscapeVisibilityMask::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLandscapeVisibilityMask");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLightmapUVs.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLightmapUVs::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLightmapUVs");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLightmassReplace.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLightmassReplace::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLightmassReplace");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLightVector.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLightVector::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLightVector");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionLinearInterpolate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionLinearInterpolate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionLinearInterpolate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionMakeMaterialAttributes.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionMakeMaterialAttributes::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionMakeMaterialAttributes");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionMaterialFunctionCall.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionMaterialFunctionCall::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionMaterialFunctionCall");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionMax.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionMax::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionMax");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionMin.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionMin::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionMin");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionMultiply.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionMultiply::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionMultiply");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionNoise.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionNoise::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionNoise");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionNormalize.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionNormalize::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionNormalize");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionObjectBounds.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionObjectBounds::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionObjectBounds");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionObjectId.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionObjectId::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionObjectId");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionObjectOrientation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionObjectOrientation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionObjectOrientation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionObjectPositionWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionObjectPositionWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionObjectPositionWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionObjectRadius.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionObjectRadius::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionObjectRadius");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionOneMinus.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionOneMinus::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionOneMinus");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPanner.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPanner::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPanner");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionScalarParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionScalarParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionScalarParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionStaticBoolParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionStaticBoolParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionStaticBoolParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionStaticSwitchParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionStaticSwitchParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionStaticSwitchParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionStaticComponentMaskParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionStaticComponentMaskParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionStaticComponentMaskParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionVectorParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionVectorParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionVectorParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleDirection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleDirection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleDirection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleMacroUV.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleMacroUV::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleMacroUV");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleMotionBlurFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleMotionBlurFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleMotionBlurFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticlePositionWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticlePositionWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticlePositionWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleRadius.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleRadius::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleRadius");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleRelativeTime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleRelativeTime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleRelativeTime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleSize.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleSize::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleSize");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleSpeed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleSpeed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleSpeed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPerInstanceFadeAmount.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPerInstanceFadeAmount::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPerInstanceFadeAmount");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPerInstanceRandom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPerInstanceRandom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPerInstanceRandom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPixelDepth.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPixelDepth::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPixelDepth");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPixelNormalWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPixelNormalWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPixelNormalWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPlatformSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPlatformSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPlatformSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPower.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPower::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPower");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPreSkinnedNormal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPreSkinnedNormal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPreSkinnedNormal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionPreSkinnedPosition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionPreSkinnedPosition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionPreSkinnedPosition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionQualitySwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionQualitySwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionQualitySwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionReflectionVectorWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionReflectionVectorWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionReflectionVectorWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionRotateAboutAxis.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionRotateAboutAxis::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionRotateAboutAxis");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionRotator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionRotator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionRotator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSceneColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSceneColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSceneColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSceneDepth.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSceneDepth::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSceneDepth");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSceneTexelSize.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSceneTexelSize::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSceneTexelSize");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSceneTexture.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSceneTexture::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSceneTexture");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionScreenPosition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionScreenPosition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionScreenPosition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSpeedTree.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSpeedTree::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSpeedTree");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSphereMask.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSphereMask::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSphereMask");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSphericalParticleOpacity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSphericalParticleOpacity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSphericalParticleOpacity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSquareRoot.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSquareRoot::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSquareRoot");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionStaticBool.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionStaticBool::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionStaticBool");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionStaticSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionStaticSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionStaticSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionSubtract.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionSubtract::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionSubtract");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureSample.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureSample::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureSample");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionParticleSubUV.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionParticleSubUV::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionParticleSubUV");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureSampleParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureSampleParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureObjectParameter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureObjectParameter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureObjectParameter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureSampleParameter2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureSampleParameter2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameter2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionAntialiasedTextureMask.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionAntialiasedTextureMask::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionAntialiasedTextureMask");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureSampleParameterSubUV.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureSampleParameterSubUV::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterSubUV");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureSampleParameterCube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureSampleParameterCube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureSampleParameterCube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTextureCoordinate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTextureCoordinate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTextureCoordinate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTransform.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTransform::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTransform");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTransformPosition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTransformPosition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTransformPosition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionTwoSidedSign.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionTwoSidedSign::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionTwoSidedSign");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionVertexColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionVertexColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionVertexColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionVertexNormalWS.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionVertexNormalWS::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionVertexNormalWS");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionViewSize.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionViewSize::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionViewSize");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialExpressionWorldPosition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialExpressionWorldPosition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialExpressionWorldPosition");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialFunction.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialFunction::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialFunction");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Material");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialInstanceConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialInstanceConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialInstanceConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULandscapeMaterialInstanceConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULandscapeMaterialInstanceConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LandscapeMaterialInstanceConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E710
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::SetVectorParameterValue(const class FName& ParameterName, const struct FLinearColor& Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetVectorParameterValue");
		
		UMaterialInstanceDynamic_SetVectorParameterValue_Params params {};
		params.ParameterName = ParameterName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E880
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UTexture*                                    Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::SetTextureParameterValue(const class FName& ParameterName, class UTexture* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetTextureParameterValue");
		
		UMaterialInstanceDynamic_SetTextureParameterValue_Params params {};
		params.ParameterName = ParameterName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E9D0
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Value                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::SetScalarParameterValue(const class FName& ParameterName, float Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.SetScalarParameterValue");
		
		UMaterialInstanceDynamic_SetScalarParameterValue_Params params {};
		params.ParameterName = ParameterName;
		params.Value = Value;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270EB30
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInstance*                           MaterialA                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class UMaterialInstance*                           MaterialB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		float                                              Alpha                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::K2_InterpolateMaterialInstanceParams(class UMaterialInstance* MaterialA, class UMaterialInstance* MaterialB, float Alpha)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams");
		
		UMaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams_Params params {};
		params.MaterialA = MaterialA;
		params.MaterialB = MaterialB;
		params.Alpha = Alpha;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270ED10
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	struct FLinearColor UMaterialInstanceDynamic::K2_GetVectorParameterValue(const class FName& ParameterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue");
		
		UMaterialInstanceDynamic_K2_GetVectorParameterValue_Params params {};
		params.ParameterName = ParameterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270EE70
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UTexture* UMaterialInstanceDynamic::K2_GetTextureParameterValue(const class FName& ParameterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue");
		
		UMaterialInstanceDynamic_K2_GetTextureParameterValue_Params params {};
		params.ParameterName = ParameterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270EF50
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class FName                                        ParameterName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	float UMaterialInstanceDynamic::K2_GetScalarParameterValue(const class FName& ParameterName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue");
		
		UMaterialInstanceDynamic_K2_GetScalarParameterValue_Params params {};
		params.ParameterName = ParameterName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F030
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInterface*                          SourceMaterialToCopyFrom                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::K2_CopyMaterialInstanceParameters(class UMaterialInterface* SourceMaterialToCopyFrom)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters");
		
		UMaterialInstanceDynamic_K2_CopyMaterialInstanceParameters_Params params {};
		params.SourceMaterialToCopyFrom = SourceMaterialToCopyFrom;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270F100
	 * 		Name   -> Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UMaterialInstance*                           MaterialInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UMaterialInstanceDynamic::CopyParameterOverrides(class UMaterialInstance* MaterialInstance)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.MaterialInstanceDynamic.CopyParameterOverrides");
		
		UMaterialInstanceDynamic_CopyParameterOverrides_Params params {};
		params.MaterialInstance = MaterialInstance;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialInstanceDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialInstanceDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialInstanceDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialParameterCollection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialParameterCollection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialParameterCollection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMaterialParameterCollectionInstance.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMaterialParameterCollectionInstance::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MaterialParameterCollectionInstance");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMatineeInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMatineeInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MatineeInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMountedDLCManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMountedDLCManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MountedDLCManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUWPMountedDLCManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUWPMountedDLCManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.UWPMountedDLCManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UXboxOneMountedDLCManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UXboxOneMountedDLCManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.XboxOneMountedDLCManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Default.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Default::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavArea_Default");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavArea_Null.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavArea_Null::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavArea_Null");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavAreaMeta.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavAreaMeta::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavAreaMeta");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavAreaMeta_SwitchByAgent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavAreaMeta_SwitchByAgent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavAreaMeta_SwitchByAgent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavCollision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavCollision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavCollision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.NavigationPath.OnNavigationPathUpdated__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UNavigationPath*                             AffectedPath                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		ENavPathEvent                                      PathEvent                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavigationPath::OnNavigationPathUpdated__DelegateSignature(class UNavigationPath* AffectedPath, ENavPathEvent PathEvent)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.OnNavigationPathUpdated__DelegateSignature");
		
		UNavigationPath_OnNavigationPathUpdated__DelegateSignature_Params params {};
		params.AffectedPath = AffectedPath;
		params.PathEvent = PathEvent;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CF30
	 * 		Name   -> Function Engine.NavigationPath.IsValid
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavigationPath::IsValid()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsValid");
		
		UNavigationPath_IsValid_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00E4A4C0
	 * 		Name   -> Function Engine.NavigationPath.IsStringPulled
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavigationPath::IsStringPulled()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsStringPulled");
		
		UNavigationPath_IsStringPulled_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CF50
	 * 		Name   -> Function Engine.NavigationPath.IsPartial
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	bool UNavigationPath::IsPartial()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.IsPartial");
		
		UNavigationPath_IsPartial_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CF90
	 * 		Name   -> Function Engine.NavigationPath.GetPathLength
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UNavigationPath::GetPathLength()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetPathLength");
		
		UNavigationPath_GetPathLength_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237D010
	 * 		Name   -> Function Engine.NavigationPath.GetPathCost
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	float UNavigationPath::GetPathCost()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetPathCost");
		
		UNavigationPath_GetPathCost_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237D060
	 * 		Name   -> Function Engine.NavigationPath.GetDebugString
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	class FString UNavigationPath::GetDebugString()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.GetDebugString");
		
		UNavigationPath_GetDebugString_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237D130
	 * 		Name   -> Function Engine.NavigationPath.EnableRecalculationOnInvalidation
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 * Parameters:
	 * 		ENavigationOptionFlag                              DoRecalculation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavigationPath::EnableRecalculationOnInvalidation(ENavigationOptionFlag DoRecalculation)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.EnableRecalculationOnInvalidation");
		
		UNavigationPath_EnableRecalculationOnInvalidation_Params params {};
		params.DoRecalculation = DoRecalculation;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237D230
	 * 		Name   -> Function Engine.NavigationPath.EnableDebugDrawing
	 * 		Flags  -> (Final, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		bool                                               bShouldDrawDebugData                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FLinearColor                                PathColor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UNavigationPath::EnableDebugDrawing(bool bShouldDrawDebugData, const struct FLinearColor& PathColor)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.NavigationPath.EnableDebugDrawing");
		
		UNavigationPath_EnableDebugDrawing_Params params {};
		params.bShouldDrawDebugData = bShouldDrawDebugData;
		params.PathColor = PathColor;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationPath.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationPath::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationPath");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavigationPathGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavigationPathGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavigationPathGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URecastFilter_UseDefaultArea.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URecastFilter_UseDefaultArea::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RecastFilter_UseDefaultArea");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavLinkTrivial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavLinkTrivial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavLinkTrivial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNavNodeInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNavNodeInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NavNodeInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNetworkSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNetworkSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NetworkSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNiagaraEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNiagaraEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NiagaraEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNiagaraScript.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNiagaraScript::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NiagaraScript");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UNiagaraScriptSourceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UNiagaraScriptSourceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.NiagaraScriptSourceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectLibrary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectLibrary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ObjectLibrary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UObjectReferencer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UObjectReferencer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ObjectReferencer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPackageMapClient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPackageMapClient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PackageMapClient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleSpriteEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleSpriteEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleSpriteEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleLODLevel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleLODLevel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleLODLevel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModule.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModule::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModule");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAccelerationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAccelerationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAccelerationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAcceleration.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAcceleration::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAcceleration");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAccelerationConstant.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAccelerationConstant::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAccelerationConstant");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAccelerationDrag.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAccelerationDrag::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAccelerationDrag");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAccelerationDragScaleOverLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAccelerationDragScaleOverLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAccelerationDragScaleOverLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAccelerationOverLifetime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAccelerationOverLifetime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAccelerationOverLifetime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAttractorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAttractorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAttractorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAttractorLine.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAttractorLine::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAttractorLine");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAttractorParticle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAttractorParticle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAttractorParticle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAttractorPoint.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAttractorPoint::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAttractorPoint");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleAttractorPointGravity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleAttractorPointGravity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleAttractorPointGravity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleBeamBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleBeamBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleBeamBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleBeamModifier.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleBeamModifier::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleBeamModifier");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleBeamNoise.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleBeamNoise::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleBeamNoise");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleBeamSource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleBeamSource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleBeamSource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleBeamTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleBeamTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleBeamTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleCameraBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleCameraBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleCameraBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleCameraOffset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleCameraOffset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleCameraOffset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleCollisionBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleCollisionBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleCollisionBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleCollision.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleCollision::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleCollision");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleCollisionGPU.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleCollisionGPU::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleCollisionGPU");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleColorBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleColorBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleColorBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleColor.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleColor::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleColor");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleColor_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleColor_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleColor_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleColorOverLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleColorOverLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleColorOverLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleColorScaleOverLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleColorScaleOverLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleColorScaleOverLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventGenerator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventGenerator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventGenerator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventReceiverBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventReceiverBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventReceiverBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventReceiverKillParticles.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventReceiverKillParticles::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventReceiverKillParticles");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventReceiverSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventReceiverSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventReceiverSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleKillBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleKillBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleKillBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleKillBox.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleKillBox::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleKillBox");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleKillHeight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleKillHeight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleKillHeight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLifetimeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLifetimeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLifetimeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLifetime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLifetime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLifetime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLifetime_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLifetime_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLifetime_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLightBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLightBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLightBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLight.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLight::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLight");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLight_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLight_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLight_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocation_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocation_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocation_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationWorldOffset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationWorldOffset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationWorldOffset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationWorldOffset_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationWorldOffset_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationWorldOffset_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationBoneSocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationBoneSocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationBoneSocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationDirect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationDirect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationDirect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationEmitter.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationEmitter::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationEmitter");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationEmitterDirect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationEmitterDirect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationEmitterDirect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveCylinder.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveCylinder::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveCylinder");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveCylinder_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveCylinder_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveCylinder_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveSphere.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveSphere::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveSphere");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveSphere_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveSphere_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveSphere_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationPrimitiveTriangle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationPrimitiveTriangle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationPrimitiveTriangle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleLocationSkelVertSurface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleLocationSkelVertSurface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleLocationSkelVertSurface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModulePivotOffset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModulePivotOffset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModulePivotOffset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSourceMovement.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSourceMovement::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSourceMovement");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMaterialBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMaterialBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMaterialBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleOrbitBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleOrbitBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleOrbitBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleOrbit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleOrbit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleOrbit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleOrientationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleOrientationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleOrientationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleOrientationAxisLock.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleOrientationAxisLock::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleOrientationAxisLock");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleParameterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleParameterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleParameterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleParameterDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleParameterDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleParameterDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleParameterDynamic_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleParameterDynamic_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleParameterDynamic_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRequired.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRequired::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRequired");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotation_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotation_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotation_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotation_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotation_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotation_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationOverLifetime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationOverLifetime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationOverLifetime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationRateBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationRateBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationRateBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotationRate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotationRate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationRate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationRate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationRate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotationRate_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotationRate_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRate_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotationRateMultiplyLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotationRateMultiplyLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRateMultiplyLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleMeshRotationRateOverLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleMeshRotationRateOverLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleMeshRotationRateOverLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationRate_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationRate_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationRate_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleRotationRateMultiplyLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleRotationRateMultiplyLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleRotationRateMultiplyLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSizeBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSizeBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSizeBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSize.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSize::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSize");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSize_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSize_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSize_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSizeMultiplyLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSizeMultiplyLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSizeMultiplyLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSizeScale.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSizeScale::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSizeScale");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSizeScaleBySpeed.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSizeScaleBySpeed::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSizeScaleBySpeed");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSpawnBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSpawnBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSpawnBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSpawn.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSpawn::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSpawn");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSpawnPerUnit.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSpawnPerUnit::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSpawnPerUnit");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSubUVBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSubUVBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSubUVBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSubUV.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSubUV::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSubUV");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleSubUVMovie.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleSubUVMovie::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleSubUVMovie");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTrailBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTrailBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTrailBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTrailSource.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTrailSource::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTrailSource");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataAnimTrail.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataAnimTrail::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataAnimTrail");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataBeam2.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataBeam2::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataBeam2");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataGpu.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataGpu::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataGpu");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleTypeDataRibbon.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleTypeDataRibbon::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleTypeDataRibbon");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldGlobal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldGlobal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldGlobal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldLocal.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldLocal::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldLocal");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldRotation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldRotation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldRotation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldRotationRate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldRotationRate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldRotationRate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldScale.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldScale::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldScale");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVectorFieldScaleOverLife.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVectorFieldScaleOverLife::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVectorFieldScaleOverLife");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocityBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocityBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocityBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocity.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocity::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocity");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocity_Seeded.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocity_Seeded::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocity_Seeded");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocityCone.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocityCone::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocityCone");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocityInheritParent.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocityInheritParent::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocityInheritParent");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleVelocityOverLifetime.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleVelocityOverLifetime::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleVelocityOverLifetime");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleModuleEventSendToGame.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleModuleEventSendToGame::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleModuleEventSendToGame");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UParticleSystemReplay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UParticleSystemReplay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ParticleSystemReplay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicalMaterial.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicalMaterial::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicalMaterial");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicalMaterialPropertyBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicalMaterialPropertyBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicalMaterialPropertyBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsCollisionHandler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsCollisionHandler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsCollisionHandler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPhysicsConstraintTemplate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPhysicsConstraintTemplate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PhysicsConstraintTemplate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.PlatformInterfaceBase.PlatformInterfaceDelegate__DelegateSignature
	 * 		Flags  -> (Public, Delegate, HasOutParms)
	 * Parameters:
	 * 		struct FPlatformInterfaceDelegateResult            Result                                                     (ConstParm, Parm, OutParm, ReferenceParm)
	 */
	void UPlatformInterfaceBase::PlatformInterfaceDelegate__DelegateSignature(const struct FPlatformInterfaceDelegateResult& Result)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceBase.PlatformInterfaceDelegate__DelegateSignature");
		
		UPlatformInterfaceBase_PlatformInterfaceDelegate__DelegateSignature_Params params {};
		params.Result = Result;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlatformInterfaceBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlatformInterfaceBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlatformInterfaceBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCloudStorageBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCloudStorageBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CloudStorageBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InGameAdManager.OnUserClosedAdvertisement__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UInGameAdManager::OnUserClosedAdvertisement__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InGameAdManager.OnUserClosedAdvertisement__DelegateSignature");
		
		UInGameAdManager_OnUserClosedAdvertisement__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.InGameAdManager.OnUserClickedBanner__DelegateSignature
	 * 		Flags  -> (Public, Delegate)
	 */
	void UInGameAdManager::OnUserClickedBanner__DelegateSignature()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.InGameAdManager.OnUserClickedBanner__DelegateSignature");
		
		UInGameAdManager_OnUserClickedBanner__DelegateSignature_Params params {};
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UInGameAdManager.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UInGameAdManager::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.InGameAdManager");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMicroTransactionBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMicroTransactionBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MicroTransactionBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DF00
	 * 		Name   -> Function Engine.TwitterIntegrationBase.TwitterRequest
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 * 		TArray<class FString>                              ParamKeysAndValues                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm)
	 * 		ETwitterRequestMethod                              RequestMethod                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            AccountIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	bool UTwitterIntegrationBase::TwitterRequest(const class FString& URL, TArray<class FString> ParamKeysAndValues, ETwitterRequestMethod RequestMethod, int32_t AccountIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.TwitterRequest");
		
		UTwitterIntegrationBase_TwitterRequest_Params params {};
		params.URL = URL;
		params.ParamKeysAndValues = ParamKeysAndValues;
		params.RequestMethod = RequestMethod;
		params.AccountIndex = AccountIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E1D0
	 * 		Name   -> Function Engine.TwitterIntegrationBase.ShowTweetUI
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class FString                                      InitialMessage                                             (Parm, ZeroConstructor)
	 * 		class FString                                      URL                                                        (Parm, ZeroConstructor)
	 * 		class FString                                      Picture                                                    (Parm, ZeroConstructor)
	 */
	bool UTwitterIntegrationBase::ShowTweetUI(const class FString& InitialMessage, const class FString& URL, const class FString& Picture)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.ShowTweetUI");
		
		UTwitterIntegrationBase_ShowTweetUI_Params params {};
		params.InitialMessage = InitialMessage;
		params.URL = URL;
		params.Picture = Picture;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E470
	 * 		Name   -> Function Engine.TwitterIntegrationBase.Init
	 * 		Flags  -> (Native, Public)
	 */
	void UTwitterIntegrationBase::Init()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.Init");
		
		UTwitterIntegrationBase_Init_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E4B0
	 * 		Name   -> Function Engine.TwitterIntegrationBase.GetNumAccounts
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UTwitterIntegrationBase::GetNumAccounts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetNumAccounts");
		
		UTwitterIntegrationBase_GetNumAccounts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E500
	 * 		Name   -> Function Engine.TwitterIntegrationBase.GetAccountName
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		int32_t                                            AccountIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class FString UTwitterIntegrationBase::GetAccountName(int32_t AccountIndex)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.GetAccountName");
		
		UTwitterIntegrationBase_GetAccountName_Params params {};
		params.AccountIndex = AccountIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E670
	 * 		Name   -> Function Engine.TwitterIntegrationBase.CanShowTweetUI
	 * 		Flags  -> (Native, Public)
	 */
	bool UTwitterIntegrationBase::CanShowTweetUI()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.CanShowTweetUI");
		
		UTwitterIntegrationBase_CanShowTweetUI_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270E6C0
	 * 		Name   -> Function Engine.TwitterIntegrationBase.AuthorizeAccounts
	 * 		Flags  -> (Native, Public)
	 */
	bool UTwitterIntegrationBase::AuthorizeAccounts()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.TwitterIntegrationBase.AuthorizeAccounts");
		
		UTwitterIntegrationBase_AuthorizeAccounts_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTwitterIntegrationBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTwitterIntegrationBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TwitterIntegrationBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DB60
	 * 		Name   -> Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
	 * 		Flags  -> (Native, Public)
	 */
	int32_t UPlatformInterfaceWebResponse::GetNumHeaders()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetNumHeaders");
		
		UPlatformInterfaceWebResponse_GetNumHeaders_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DBB0
	 * 		Name   -> Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
	 * 		Flags  -> (Native, Public)
	 * Parameters:
	 * 		class FString                                      HeaderName                                                 (Parm, ZeroConstructor)
	 */
	class FString UPlatformInterfaceWebResponse::GetHeaderValue(const class FString& HeaderName)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeaderValue");
		
		UPlatformInterfaceWebResponse_GetHeaderValue_Params params {};
		params.HeaderName = HeaderName;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270DD40
	 * 		Name   -> Function Engine.PlatformInterfaceWebResponse.GetHeader
	 * 		Flags  -> (Native, Public, HasOutParms)
	 * Parameters:
	 * 		int32_t                                            HeaderIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		class FString                                      Header                                                     (Parm, OutParm, ZeroConstructor)
	 * 		class FString                                      Value                                                      (Parm, OutParm, ZeroConstructor)
	 */
	void UPlatformInterfaceWebResponse::GetHeader(int32_t HeaderIndex, class FString* Header, class FString* Value)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.PlatformInterfaceWebResponse.GetHeader");
		
		UPlatformInterfaceWebResponse_GetHeader_Params params {};
		params.HeaderIndex = HeaderIndex;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Header != nullptr)
			*Header = params.Header;
		if (Value != nullptr)
			*Value = params.Value;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPlatformInterfaceWebResponse.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPlatformInterfaceWebResponse::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.PlatformInterfaceWebResponse");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UChildConnection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UChildConnection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ChildConnection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UPolys.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UPolys::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Polys");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReflectionCaptureData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReflectionCaptureData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReflectionCaptureData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URendererSettings.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URendererSettings::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RendererSettings");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReporterBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReporterBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReporterBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReporterGraph.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReporterGraph::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReporterGraph");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UReverbEffect.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UReverbEffect::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ReverbEffect");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URig.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URig::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Rig");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction URuntimeMovieScenePlayerInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* URuntimeMovieScenePlayerInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.RuntimeMovieScenePlayerInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USaveGameSummary.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USaveGameSummary::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SaveGameSummary");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USCS_Node.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USCS_Node::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SCS_Node");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USelection.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USelection::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Selection");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USimpleConstructionScript.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USimpleConstructionScript::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SimpleConstructionScript");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDestructibleMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDestructibleMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DestructibleMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D6F0
	 * 		Name   -> Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkelComp                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldLocation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		struct FVector                                     WorldNormal                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void USkeletalMeshSocket::InitializeSocketFromLocation(class USkeletalMeshComponent* SkelComp, const struct FVector& WorldLocation, const struct FVector& WorldNormal)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation");
		
		USkeletalMeshSocket_InitializeSocketFromLocation_Params params {};
		params.SkelComp = SkelComp;
		params.WorldLocation = WorldLocation;
		params.WorldNormal = WorldNormal;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D900
	 * 		Name   -> Function Engine.SkeletalMeshSocket.GetSocketLocation
	 * 		Flags  -> (Final, RequiredAPI, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
	 * Parameters:
	 * 		class USkeletalMeshComponent*                      SkelComp                                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor)
	 */
	struct FVector USkeletalMeshSocket::GetSocketLocation(class USkeletalMeshComponent* SkelComp)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SkeletalMeshSocket.GetSocketLocation");
		
		USkeletalMeshSocket_GetSocketLocation_Params params {};
		params.SkelComp = SkelComp;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkeletalMeshSocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkeletalMeshSocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkeletalMeshSocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USkyLightData.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USkyLightData::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SkyLightData");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USlateBrushAsset.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USlateBrushAsset::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SlateBrushAsset");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CE30
	 * 		Name   -> Function Engine.SoundBase.GetDuration
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	float USoundBase::GetDuration()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.SoundBase.GetDuration");
		
		USoundBase_GetDuration_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UDialogueSoundWaveProxy.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UDialogueSoundWaveProxy::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.DialogueSoundWaveProxy");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundCue.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundCue::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundCue");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundGroups.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundGroups::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundGroups");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundWave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundWave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundWave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundWaveStreaming.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundWaveStreaming::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundWaveStreaming");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundMix.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundMix::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundMix");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeAttenuation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeAttenuation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeAttenuation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeBranch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeBranch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeBranch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeConcatenator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeConcatenator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeConcatenator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeDelay.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeDelay::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeDelay");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeDeprecated.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeDeprecated::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeDeprecated");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeAmbient.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeAmbient::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeAmbient");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeAmbientNonLoop.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeAmbientNonLoop::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeAmbientNonLoop");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeAmbientNonLoopToggle.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeAmbientNonLoopToggle::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeAmbientNonLoopToggle");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeConcatenatorRadio.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeConcatenatorRadio::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeConcatenatorRadio");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeWave.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeWave::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeWave");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeDialoguePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeDialoguePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeDialoguePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeDistanceCrossFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeDistanceCrossFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeDistanceCrossFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeParamCrossFade.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeParamCrossFade::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeParamCrossFade");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeDoppler.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeDoppler::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeDoppler");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeEnveloper.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeEnveloper::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeEnveloper");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeGroupControl.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeGroupControl::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeGroupControl");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeLooping.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeLooping::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeLooping");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeMature.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeMature::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeMature");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeMixer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeMixer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeMixer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeModulator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeModulator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeModulator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeModulatorContinuous.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeModulatorContinuous::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeModulatorContinuous");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeOscillator.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeOscillator::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeOscillator");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeRandom.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeRandom::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeRandom");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeSoundClass.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeSoundClass::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeSoundClass");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeSwitch.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeSwitch::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeSwitch");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeWaveParam.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeWaveParam::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeWaveParam");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USoundNodeWavePlayer.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USoundNodeWavePlayer::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SoundNodeWavePlayer");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStaticMesh.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStaticMesh::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.StaticMesh");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UStaticMeshSocket.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UStaticMeshSocket::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.StaticMeshSocket");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction USubsurfaceProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* USubsurfaceProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.SubsurfaceProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextPropertyTestObject.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextPropertyTestObject::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextPropertyTestObject");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D690
	 * 		Name   -> Function Engine.Texture2D.Blueprint_GetSizeY
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UTexture2D::Blueprint_GetSizeY()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeY");
		
		UTexture2D_Blueprint_GetSizeY_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D6C0
	 * 		Name   -> Function Engine.Texture2D.Blueprint_GetSizeX
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
	 */
	int32_t UTexture2D::Blueprint_GetSizeX()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.Texture2D.Blueprint_GetSizeX");
		
		UTexture2D_Blueprint_GetSizeX_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTexture2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTexture2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Texture2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction ULightMapTexture2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* ULightMapTexture2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.LightMapTexture2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UShadowMapTexture2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UShadowMapTexture2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ShadowMapTexture2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextureLightProfile.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextureLightProfile::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextureLightProfile");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTexture2DDynamic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTexture2DDynamic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.Texture2DDynamic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextureCube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextureCube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextureCube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x01CD2930
	 * 		Name   -> Function Engine.CanvasRenderTarget2D.UpdateResource
	 * 		Flags  -> (Native, Public, BlueprintCallable)
	 */
	void UCanvasRenderTarget2D::UpdateResource()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.UpdateResource");
		
		UCanvasRenderTarget2D_UpdateResource_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.CanvasRenderTarget2D.ReceiveUpdate
	 * 		Flags  -> (Event, Public, BlueprintCallable, BlueprintEvent)
	 * Parameters:
	 * 		class UCanvas*                                     Canvas                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvasRenderTarget2D::ReceiveUpdate(class UCanvas* Canvas, int32_t Width, int32_t Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.ReceiveUpdate");
		
		UCanvasRenderTarget2D_ReceiveUpdate_Params params {};
		params.Canvas = Canvas;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0178CEC0
	 * 		Name   -> Function Engine.CanvasRenderTarget2D.OnCanvasRenderTargetUpdate__DelegateSignature
	 * 		Flags  -> (MulticastDelegate, Public, Delegate)
	 * Parameters:
	 * 		class UCanvas*                                     Canvas                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvasRenderTarget2D::OnCanvasRenderTargetUpdate__DelegateSignature(class UCanvas* Canvas, int32_t Width, int32_t Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.OnCanvasRenderTargetUpdate__DelegateSignature");
		
		UCanvasRenderTarget2D_OnCanvasRenderTargetUpdate__DelegateSignature_Params params {};
		params.Canvas = Canvas;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D370
	 * 		Name   -> Function Engine.CanvasRenderTarget2D.GetSize
	 * 		Flags  -> (Final, Native, Public, HasOutParms, BlueprintCallable)
	 * Parameters:
	 * 		int32_t                                            Width                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Height                                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	void UCanvasRenderTarget2D::GetSize(int32_t* Width, int32_t* Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.GetSize");
		
		UCanvasRenderTarget2D_GetSize_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		if (Width != nullptr)
			*Width = params.Width;
		if (Height != nullptr)
			*Height = params.Height;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0270D4B0
	 * 		Name   -> Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
	 * 		Flags  -> (Final, Native, Static, Public, BlueprintCallable)
	 * Parameters:
	 * 		class UClass*                                      CanvasRenderTarget2DClass                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Width                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 * 		int32_t                                            Height                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
	 */
	class UCanvasRenderTarget2D* UCanvasRenderTarget2D::STATIC_CreateCanvasRenderTarget2D(class UClass* CanvasRenderTarget2DClass, int32_t Width, int32_t Height)
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D");
		
		UCanvasRenderTarget2D_CreateCanvasRenderTarget2D_Params params {};
		params.CanvasRenderTarget2DClass = CanvasRenderTarget2DClass;
		params.Width = Width;
		params.Height = Height;
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UCanvasRenderTarget2D.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UCanvasRenderTarget2D::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.CanvasRenderTarget2D");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTextureRenderTargetCube.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTextureRenderTargetCube::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TextureRenderTargetCube");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UThumbnailInfo.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UThumbnailInfo::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.ThumbnailInfo");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTimelineTemplate.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTimelineTemplate::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TimelineTemplate");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UTouchInterface.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UTouchInterface::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.TouchInterface");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUserDefinedEnum.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUserDefinedEnum::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.UserDefinedEnum");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UUserDefinedStruct.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UUserDefinedStruct::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.UserDefinedStruct");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVectorField.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVectorField::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VectorField");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVectorFieldAnimated.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVectorFieldAnimated::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VectorFieldAnimated");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVectorFieldStatic.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVectorFieldStatic::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VectorFieldStatic");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CE70
	 * 		Name   -> Function Engine.VehicleWheel.GetSuspensionOffset
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UVehicleWheel::GetSuspensionOffset()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.VehicleWheel.GetSuspensionOffset");
		
		UVehicleWheel_GetSuspensionOffset_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CEA0
	 * 		Name   -> Function Engine.VehicleWheel.GetSteerAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UVehicleWheel::GetSteerAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.VehicleWheel.GetSteerAngle");
		
		UVehicleWheel_GetSteerAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x0237CED0
	 * 		Name   -> Function Engine.VehicleWheel.GetRotationAngle
	 * 		Flags  -> (Final, Native, Public, BlueprintCallable)
	 */
	float UVehicleWheel::GetRotationAngle()
	{
		static UFunction* fn = nullptr;
		if (!fn)
			fn = UObject::FindObject<UFunction>("Function Engine.VehicleWheel.GetRotationAngle");
		
		UVehicleWheel_GetRotationAngle_Params params {};
		
		auto flags = fn->FunctionFlags;
		fn->FunctionFlags |= 0x00000400;
		UObject::ProcessEvent(fn, &params);
		fn->FunctionFlags = flags;
		
		return params.ReturnValue;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVehicleWheel.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVehicleWheel::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VehicleWheel");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVertexAnimBase.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVertexAnimBase::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VertexAnimBase");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UMorphTarget.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UMorphTarget::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.MorphTarget");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UVertexAnimation.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UVertexAnimation::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.VertexAnimation");
		return ptr;
	}

	/**
	 * Function:
	 * 		RVA    -> 0x00000000
	 * 		Name   -> PredefinedFunction UWorldComposition.StaticClass
	 * 		Flags  -> (Predefined, Static)
	 */
	UClass* UWorldComposition::StaticClass()
	{
		static UClass* ptr = nullptr;
		if (!ptr)
			ptr = UObject::FindClass("Class Engine.WorldComposition");
		return ptr;
	}

}


